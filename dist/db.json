{
  "folders": [
    {
      "name": "NodeJS",
      "parentId": "y-C8x3sP",
      "isOpen": true,
      "isSystem": false,
      "defaultLanguage": "javascript",
      "id": "TGQqRGFr",
      "createdAt": 1687255378341,
      "updatedAt": 1693552124644,
      "index": 0
    },
    {
      "name": "lodash",
      "parentId": "y-C8x3sP",
      "isOpen": true,
      "isSystem": false,
      "defaultLanguage": "plain_text",
      "id": "uIXLFdiz",
      "createdAt": 1682661303338,
      "updatedAt": 1693552124644,
      "index": 1
    },
    {
      "name": "小技巧",
      "parentId": "y-C8x3sP",
      "isOpen": true,
      "isSystem": false,
      "defaultLanguage": "javascript",
      "id": "MFd514cI",
      "createdAt": 1692155892160,
      "updatedAt": 1693552124645,
      "index": 2
    },
    {
      "name": "javascript",
      "parentId": null,
      "isOpen": true,
      "isSystem": false,
      "defaultLanguage": "javascript",
      "id": "y-C8x3sP",
      "createdAt": 1677574921501,
      "updatedAt": 1693552124646,
      "index": 0,
      "icon": "javascript"
    },
    {
      "name": "图像相关",
      "parentId": "3BVGYMMN",
      "isOpen": false,
      "isSystem": false,
      "defaultLanguage": "css",
      "id": "d_FAu2Me",
      "createdAt": 1703153088965,
      "updatedAt": 1703153175537,
      "index": 0
    },
    {
      "name": "css 调试技巧",
      "parentId": "3BVGYMMN",
      "isOpen": false,
      "isSystem": false,
      "defaultLanguage": "css",
      "id": "6Ixdd13H",
      "createdAt": 1697810265202,
      "updatedAt": 1697810294667,
      "index": 1
    },
    {
      "name": "媒体/容器查询",
      "parentId": "3BVGYMMN",
      "isOpen": false,
      "isSystem": false,
      "defaultLanguage": "css",
      "id": "yJren5oY",
      "createdAt": 1702191905015,
      "updatedAt": 1702191933979,
      "index": 2
    },
    {
      "name": "CSS",
      "parentId": null,
      "isOpen": true,
      "isSystem": false,
      "defaultLanguage": "css",
      "id": "3BVGYMMN",
      "createdAt": 1677579960490,
      "updatedAt": 1693552124666,
      "index": 1
    },
    {
      "name": "form 表单",
      "parentId": "-fio_qG6",
      "isOpen": false,
      "isSystem": false,
      "defaultLanguage": "vue",
      "id": "db9Zyb5Z",
      "createdAt": 1706150361748,
      "updatedAt": 1706150672606,
      "index": 0
    },
    {
      "name": "vue",
      "parentId": null,
      "isOpen": true,
      "isSystem": false,
      "defaultLanguage": "javascript",
      "id": "-fio_qG6",
      "createdAt": 1678105368093,
      "updatedAt": 1693552124668,
      "index": 2,
      "icon": "vue"
    },
    {
      "name": "element ui",
      "parentId": null,
      "isOpen": true,
      "isSystem": false,
      "defaultLanguage": "javascript",
      "id": "kYeA3Yuv",
      "createdAt": 1678621283163,
      "updatedAt": 1693552124668,
      "index": 3
    },
    {
      "name": "electron",
      "parentId": null,
      "isOpen": true,
      "isSystem": false,
      "defaultLanguage": "javascript",
      "id": "ejtoZnYa",
      "createdAt": 1679982761618,
      "updatedAt": 1693552124669,
      "index": 4
    },
    {
      "name": "echarts",
      "parentId": null,
      "isOpen": true,
      "isSystem": false,
      "defaultLanguage": "javascript",
      "id": "CIqaS_Yh",
      "createdAt": 1681288611405,
      "updatedAt": 1693552124673,
      "index": 5
    },
    {
      "name": "VSCode",
      "parentId": null,
      "isOpen": true,
      "isSystem": false,
      "defaultLanguage": "javascript",
      "id": "WblIddgQ",
      "createdAt": 1685590221911,
      "updatedAt": 1693552124674,
      "index": 6,
      "icon": "vscode"
    },
    {
      "name": "HTML",
      "parentId": null,
      "isOpen": true,
      "isSystem": false,
      "defaultLanguage": "html",
      "id": "MqWdF2i4",
      "createdAt": 1685696039426,
      "updatedAt": 1693552124691,
      "index": 7
    },
    {
      "name": "C",
      "parentId": null,
      "isOpen": true,
      "isSystem": false,
      "defaultLanguage": "c_cpp",
      "id": "OEEtQJ4O",
      "createdAt": 1692495522396,
      "updatedAt": 1693552124697,
      "index": 8
    },
    {
      "name": "多态",
      "parentId": "ztpcuydj",
      "isOpen": false,
      "isSystem": false,
      "defaultLanguage": "java",
      "id": "WiVmIFIe",
      "createdAt": 1693830344884,
      "updatedAt": 1693830372314,
      "index": 0
    },
    {
      "name": "编程技巧",
      "parentId": "ztpcuydj",
      "isOpen": false,
      "isSystem": false,
      "defaultLanguage": "java",
      "id": "T0GXZDoL",
      "createdAt": 1693552143324,
      "updatedAt": 1693552175880,
      "index": 1
    },
    {
      "name": "基础知识点",
      "parentId": "ztpcuydj",
      "isOpen": false,
      "isSystem": false,
      "defaultLanguage": "java",
      "id": "HbQza7qh",
      "createdAt": 1693619792948,
      "updatedAt": 1693619835483,
      "index": 2
    },
    {
      "name": "java",
      "parentId": null,
      "isOpen": true,
      "isSystem": false,
      "defaultLanguage": "java",
      "id": "ztpcuydj",
      "createdAt": 1693548431974,
      "updatedAt": 1693552124697,
      "icon": "javaclass",
      "index": 9
    }
  ],
  "snippets": [
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": "array.from() 是比fill加map更现代的方式",
      "name": "array.from()",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "// Array.from\nconst y = Array.from({ length: 7 }, () => 1);\nconsole.log(y);\n// this '_'to represent some parameyer no used\nconst z = Array.from({ length: 7 }, (_, i) => i + 1);\nconsole.log(z); //[1,2,3,4,5,6,7]\n\nlabelBalance.addEventListener('click', function () {\n  const movementsUI = Array.from(\n    document.querySelectorAll('.movements__value'),\n    //第二个参数相当于map()函数\n    el => Number(el.textContent.replace('€', ''))  //去除字符串里的€符号\n  );\n  console.log(movementsUI);\n  //下面如果不用Array.from 用扩展运算符也可以实现，但需要另外用一次map()，而Array.from结合其第二个参数可以一次完成\n  // const movementsUI2 = [...document.querySelectorAll('.movements__value')];\n  // movementsUI2.map(...)\n});\n\n//array.from() 是比fill加map更现代的方式.下面的方式用array.from()一样可以实现\n//创建空数组，填充fill，然后map\nfunction createData() {\n  // 如果不 fill 循环默认会跳过空值\n  return new Array(1000).fill(null).map((v, i) => ({ name: `name${i + 1}` }));\n}\n\nconst data = createData();\nconsole.log(data);\n\n//另一种实现方式，用for循环\nfunction createData() {\n  const data = [];\n  for (let i = 0; i < 1000; i++) {\n    data.push({\n      name: `name${i + 1}`,\n    });\n  }\n  return data;\n}\n\nconst data = createData();\nconsole.log(data);"
        }
      ],
      "id": "bZ1RBcHH",
      "createdAt": 1677574971683,
      "updatedAt": 1677581484402
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "sort forEach insertAdjacentHTML",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "const displayMovements = function (acc, sort = false) {\n  containerMovements.innerHTML = \"\";\n\n  const movs = sort\n    ? acc.movements.slice().sort((a, b) => a - b)\n    : acc.movements;\n\n  movs.forEach(function (mov, i) {\n    const type = mov > 0 ? \"deposit\" : \"withdrawal\";\n\n    const date = new Date(acc.movementsDates[i]);\n    const displayDate = formatMovementDate(date, acc.locale);\n\n    const formattedMov = formatCur(mov, acc.locale, acc.currency);\n\n    const html = `\n      <div class=\"movements__row\">\n        <div class=\"movements__type movements__type--${type}\">${\n      i + 1\n    } ${type}</div>\n        <div class=\"movements__date\">${displayDate}</div>\n        <div class=\"movements__value\">${formattedMov}</div>\n      </div>\n    `;\n\n    containerMovements.insertAdjacentHTML(\"afterbegin\", html);\n  });\n};"
        }
      ],
      "id": "xdOPwTuH",
      "createdAt": 1677575344168,
      "updatedAt": 1677575362825
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "a_KWSk9m"
      ],
      "description": "js的classList.toggle方法可以将一个css类在存在和去除之间通过点击切换\n此外classList后面可以跟add、remove等",
      "name": "Toggle",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "let sorted = false;\nbtnSort.addEventListener('click', function (e){\n  e.preventDefault(); //阻止默认的表单提交刷新页面\n  displayMovements(currentAccount.movements,!sorted);\n  sorted = !sorted;\n})\n\n//========================= 侧边栏伸缩效果\n\nconst toggle = document.getElementById('toggle');\nconst modal = document.getElementById('modal');\n// Toggle nav;\ntoggle.addEventListener('click',() =>\n  document.body.classList.toggle('show-nav')\n}\n\n// Hide modal on outside click\nwindow.addEventListener('click', e => \n e.target == modal ? modal.classList.remove('show-modal') : false\n)\n\n// css\nbody{\n  //dom变化时平滑处理\n  transition: transform 0.3s ease;\n}\nbody.show-nav{\n  /* Width of nav */\n  transform: translateX(200px)\n} "
        },
        {
          "label": "Fragment 2",
          "language": "javascript",
          "value": ""
        }
      ],
      "id": "4YRe80Xi",
      "createdAt": 1677575412067,
      "updatedAt": 1690539473358
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "CTWrptR8"
      ],
      "description": null,
      "name": "reduce()",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "const people = [\n  { id: \"1\", name: \"Leigh\", age: 35 },\n  { id: \"2\", name: \"Jenny\", age: 30 },\n  { id: \"3\", name: \"Heather\", age: 28 },\n];\n\nlet result;\n//count\nresult = people.reduce((acc, person) => acc + 1, 0);\nconsole.log(result); // 3\n\n//sum ages\nresult = people.reduce((acc, person) => acc + person.age, 0);\nconsole.log(result); // 93\n\n// array of names(map)\nresult = people.reduce((acc, person) => [...acc, person.name], []);\nconsole.log(result); // [\"Leigh\", \"Jenny\", \"Heather\"]\n\n//log\nresult = people.reduce((acc, person) => {\n  //参数person.name是要迭代的元素，而...acc是要累加的数组。在这个表达式中，...acc表示将已经累加的数组展开，然后再添加上person.name作为新的元素，最终返回一个新的累加数组。\n  const newAcc = [...acc, person.name]; // 更新累积值,acc 是一个累积的结果数组，初始值为一个空数组 [],每次迭代中，...acc 会展开之前累积的结果数组，然后将当前 person 对象的 name 属性插入到新数组中。因此，打印...acc 的值会是一个包含之前迭代过程中所有人名的数组。\n  console.log(newAcc); // 输出每次迭代的结果 // [\"Leigh\"] // [\"Leigh\", \"Jenny\"] // [\"Leigh\", \"Jenny\", \"Heather\"]\n  return newAcc; // 返回更新的累积值\n}, []);\n\nconsole.log(result); // 输出最终的 result // [\"Leigh\", \"Jenny\", \"Heather\"]\n\n// convert to id => person lookup (dict) 以id为key，person为value,这样就可以通过id来查找person了,是更好的数据结构\nresult = people.reduce((acc, person) => {\n  return { ...acc, [person.id]: person };\n}, {});\nconsole.log(result); // {1: {…}, 2: {…}, 3: {…}}\nconsole.log(result[\"3\"]); // {id: \"3\", name: \"Heather\", age: 28}\n\n// max age\nresult = people.reduce((acc, person) => {\n  if (acc === null || person.age > acc) return person.age;\n  return acc;\n}, null);\nconsole.log(result); //35\n\n// min age\nresult = people.reduce((acc, person) => {\n  if (acc === null || person.age < acc) return person.age;\n  return acc;\n}, null);\nconsole.log(result); //28\n\n// find by name\nresult = people.reduce((acc, person) => {\n  //首先检查累加器是否已经被赋值，如果是则直接返回累加器的值，这样就可以避免在后续的迭代中再次查找到匹配的 person 对象。\n  if (acc !== null) return acc;\n  if (person.name === \"Leigh\") return person;\n  return null;\n}, null);\nconsole.log(result); //{id: \"1\", name: \"Leigh\", age: 35}\n\n//age all over 18 (every())\nresult = people.reduce((acc, person) => {\n  //如果累加器acc的值为false（即之前已经有一个对象的年龄小于等于27岁），则直接返回false，不再继续遍历数组节省时间和资源\n  if (!acc) return false;\n  return person.age > 18;\n}, true);\n\n//result = people.every(person => person.age>28); //如果有任何元素不符合条件，every() 方法会立即停止遍历，并返回 false。如果所有元素都符合条件，则返回 true。\nconsole.log(result); // true\n\n//any over 18 (some())\nresult = people.reduce((acc, person) => {\n  if (acc) return true; //如果累加器 acc 的值为真（即非空、非零、非假），则直接返回 true，不再继续遍历数组节省时间和资源。\n  return person.age > 18;\n}, false);\nconsole.log(result); //true\n\n//result = people.some(person => person.age > 18); //用some()是更好的实现，如果有任何元素符合条件，some() 方法会立即停止遍历，并返回 true。如果所有元素都不符合条件，则返回 false。\n\n//其他===========================\nconst orders = [{ id: 1, amount: 10 }, { id: 2, amount: 12 }, { id: 3, amount: 5 }]\n\nconst totalAmount = orders.reduce((sum, order) => sum + order.amount, 0); // 27\n\n累加可以，那么 加减乘除 中其他三个的原理是一样的，这里不用多说，肯定是可以的，\n甚至加上 与 、非的计算也是可以的，比如\n\n[true, true, false, true].reduce((a, b) => a & b); // 有false，按照与逻辑，一定会是false"
        },
        {
          "label": "reduce 概念",
          "language": "javascript",
          "value": "reduce()是JavaScript中数组的一个高阶函数。它接收一个回调函数作为参数，用来处理数组中的每个元素，并将结果累积为单个值。\nreduce()方法的语法如下：\n\narr.reduce(callback[, initialValue])\n\n其中，callback是一个回调函数，它可以接收四个参数：accumulator（累加器）、currentValue（当前元素的值）、currentIndex（当前元素的索引）和array（原始数组）。initialValue是可选参数，用来指定累加器的初始值。\n\n回调函数的作用是对数组中的每个元素进行操作，并将结果累积到累加器中。回调函数的返回值会作为下一次迭代的累加器值。最后，reduce()方法返回累加器的最终值。\n\n下面是一个使用reduce()方法计算数组元素之和的示例：\n\nvar numbers = [1, 2, 3, 4, 5];\nvar sum = numbers.reduce(function(accumulator, currentValue) {\n  return accumulator + currentValue;\n}, 0);\n\nconsole.log(sum); // 输出15```\n\n在上面的示例中，初始累加器的值为0，回调函数每次将当前元素与累加器相加，并将结果作为下一次迭代的累加器值。最终得到数组元素之和为15。\nreduce()方法还可以用于其他一些场景，例如计算数组元素的乘积、查找数组中的最大值或最小值等。通过在回调函数中实现不同的逻辑，可以实现各种不同的功能。\n\n需要注意的是，reduce()方法只对非空数组有效。如果数组为空且没有提供初始值，将会抛出一个TypeError。因此，在使用reduce()方法时，最好先检查数组是否为空，或者提供一个初始值来避免错误。"
        },
        {
          "label": "一个处理header的案例",
          "language": "javascript",
          "value": "data = data.toString();\n        \nif(data.match(/Upgrade: websocket/)){ // 说明要升级成websocket协议\n  let rows = data.split('\\r\\n');// split()返回的是一个数组，而join()是将数组转换成字符串\n  // console.log(rows); //打印header報文,是一个数组, slice(1,-2)去掉第一行和最后两行\n\n  const headers = rows.slice(1, -2).reduce((memo, row) => {\n      console.log('(memo:',memo); //memo 是上一次回调函数的返回值\n      console.log('row:',row);    //row 是数组 rows 中当前正在处理的元素\n\n      let [key,value] = row.split(': ') //数组的解构赋值,将一个数组拆分成多个变量，row.split(': ') 是对字符串 row 进行拆分\n      //拆分后的结果是一个由两个元素组成的数组，第一个元素是键（key），第二个元素是值（value）\n      memo[key.toLowerCase()] = value;\n      return memo\n  }, {});\n  console.log(headers);\n  ...\n}\n\n const headers里这段代码使用了 reduce() 方法对数组 rows 进行操作，并最终返回一个对象 headers。\n首先，slice(1, -2) 对数组 rows 进行切片操作，从索引为 1 的元素开始，到倒数第二个元素结束。这样做的目的是去掉数组中的第一个和最后两个元素。\n然后，reduce() 方法接收一个回调函数和一个初始值 {}。回调函数接收两个参数：memo 和 row。memo 是上一次回调函数的返回值，初始值为一个空对象 {}。row 是数组 rows 中当前正在处理的元素。\n在每次迭代中，回调函数将会把 row 拆分成键值对，使用冒号和空格进行拆分，并将其赋值给变量 [key, value]。然后，它将会把 key 转换为小写，并将 value 添加到 memo 对象中，以 key 作为属性名。\n最后，回调函数返回更新后的 memo 对象。当所有元素都被迭代完毕后，最终的 memo 对象将作为结果存储在变量 headers 中。\n总结起来，这个过程可以理解为通过遍历数组并逐步构建对象的方式，将数组转换成对象。"
        }
      ],
      "id": "bf6LnPoL",
      "createdAt": 1677575451164,
      "updatedAt": 1691573104749
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "tocBVsRT",
        "7N_f-tUT"
      ],
      "description": null,
      "name": "forEach()和map()结合",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "forEach方法是数组的一个方法，不能直接用在对象上。对象不是可迭代的，因此无法使用forEach方法对其进行遍历。如果想要遍历对象的属性，可以使用for...in循环或Object.keys方法来实现\n核心：forEach()不会有返回值，但可以改变原数组对象，通过forEach()和map()给数组对象添加一个新属性\n// Data\nconst account1 = {\n  owner: 'Jonas Schmedtmann',\n  movements: [200, 450, -400, 3000, -650, -130, 70, 1300],\n  interestRate: 1.2, // %\n  pin: 1111,\n};\n\nconst account2 = {\n  owner: 'Jessica Davis',\n  movements: [5000, 3400, -150, -790, -3210, -1000, 8500, -30],\n  interestRate: 1.5,\n  pin: 2222,\n};\n\nconst account3 = {\n  owner: 'Steven Thomas Williams',\n  movements: [200, -200, 340, -300, -20, 50, 400, -460],\n  interestRate: 0.7,\n  pin: 3333,\n};\n\nconst account4 = {\n  owner: 'Sarah Smith',\n  movements: [430, 1000, 700, 50, 90],\n  interestRate: 1,\n  pin: 4444,\n};\n\nconst accounts = [account1, account2, account3, account4];\n\n//function\nconst createUsernames = function (accs) {\n  accs.forEach(function (acc) {\n    //利用map返回新数组的特性给原数组添加一个新属性\n    acc.username = acc.owner\n      .toLowerCase()\n      .split(' ')\n      .map(name => name[0])\n      .join('');\n  });\n};\ncreateUsernames(accounts);\n\n\n//将会输出一个包含四个对象的数组，其中包含新创建的属性'username'\nconsole.log(accounts)"
        },
        {
          "label": "通过forEach添加多个事件监听",
          "language": "javascript",
          "value": "通过forEach添加多个事件监听\n['hashchange','load'].forEach(ev => window.addEventListener(ev, showRecipe));"
        }
      ],
      "id": "Mm1kTDnU",
      "createdAt": 1677575496707,
      "updatedAt": 1691660274839
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "",
      "tagsIds": [],
      "description": null,
      "name": "",
      "content": [
        {
          "label": "Fragment 1",
          "value": "    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n",
          "language": "plain_text"
        }
      ],
      "id": "xmFO4S7x",
      "createdAt": 1677575778167,
      "updatedAt": 1677575990317
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "",
      "tagsIds": [],
      "description": null,
      "name": "",
      "content": [
        {
          "label": "Fragment 1",
          "value": "    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n",
          "language": "plain_text"
        }
      ],
      "id": "y8AxHdjJ",
      "createdAt": 1677575952165,
      "updatedAt": 1677575992937
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "",
      "tagsIds": [],
      "description": null,
      "name": "",
      "content": [
        {
          "label": "Fragment 1",
          "value": "const orders = [{ id: 1, amount: 10 }, { id: 2, amount: 12 }, { id: 3, amount: 5 }]\nconst totalAmount = orders.reduce((sum, order) => sum + order.amount, 0); // 27\n/*累加可以，那么 加减乘除 中其他三个的原理是一样的，这里不用多说，肯定是可以的，\n甚至加上 与 、非的计算也是可以的，比如*/\n[true, true, false, true].reduce((a, b) => a & b); // 有false，按照与逻辑，一定会是false",
          "language": "plain_text"
        }
      ],
      "id": "ddCyDVGE",
      "createdAt": 1677576234823,
      "updatedAt": 1690167767350
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "",
      "tagsIds": [],
      "description": null,
      "name": "",
      "content": [
        {
          "label": "Fragment 1",
          "value": "});\n",
          "language": "plain_text"
        }
      ],
      "id": "6hLU6hms",
      "createdAt": 1677576302105,
      "updatedAt": 1677576472273
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "",
      "tagsIds": [],
      "description": null,
      "name": "",
      "content": [
        {
          "label": "Fragment 1",
          "value": "document.addEventListener(\"DOMContentLoaded\", async () => {\n  const activeTab = await getActiveTabURL();\n  queryParameters = activeTab.url;\n  // const urlParameters = new URLSearchParams(queryParameters);\n});",
          "language": "plain_text"
        }
      ],
      "id": "nP0dmW7J",
      "createdAt": 1677576327516,
      "updatedAt": 1681367875602
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "lsitjQdf"
      ],
      "description": null,
      "name": "从特定数组对象中获取值的函数",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "//从特定数组对象中获取值的函数\nfunction findProductData(data, productName, property) {\n  const product = data.find(obj => obj.product === productName);\n  return product ? product[property] : null;\n}\n//You can call this function like this:\nconst data = JSON.parse(jsonString).data;\nconst product1 = findProductData(data, \"DBOne\", \"product\");\nconst btnUrl1 = findProductData(data, \"DBOne\", \"btnUrl\");\nconst product2 = findProductData(data, \"DBTwo\", \"product\");\nconst btnUrl2 = findProductData(data, \"DBTwo\", \"btnUrl\");\n\n/*n this example, `data` is the array of objects you want to search, \n`productName` is the value of the `product` property you want to find, \nand `property` is the name of the property you want to retrieve. \n\nThe `findProductData` function returns the value of the `property`\n parameter for the object that has a `product` property equal to `\n productName`. If no such object is found, the function returns `null`.*/"
        },
        {
          "label": "find()方法的返回值",
          "language": "plain_text",
          "value": "find()方法返回的值不一定是字符串，它取决于数组中符合条件的元素的数据类型。如果数组中符合条件的元素是字符串类型，则find()方法返回该字符串；如果符合条件的元素是数字类型，则find()方法返回该数字；如果符合条件的元素是对象类型，则find()方法返回该对象。如果数组中没有符合条件的元素，则find()方法返回undefined。\n\n示例代码：\n\nconst result = arr.find((item) => item > 3);\nconsole.log(typeof result); // 输出：number\n\nconst arr2 = ['apple', 'orange', 'banana'];\nconst result2 = arr2.find((item) => item === 'orange');\nconsole.log(typeof result2); // 输出：string\n\nconst arr3 = [{name: '张三', age: 20}, {name: '李四', age: 30}];\nconst result3 = arr3.find((item) => item.age > 25);\nconsole.log(typeof result3); // 输出：object"
        }
      ],
      "id": "e8l1fG6K",
      "createdAt": 1677576778290,
      "updatedAt": 1686372428924
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "oiiyhcXF",
        "CH3Sh008",
        "g7tfu6yD"
      ],
      "description": null,
      "name": "从对象提取属性的若干方式",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "const [entry] = entries; //const entry = entries[0]\n/*这句话是ES6中解构赋值语法的一种。它的作用是把数组或对象中的值解构出来并赋值给左侧的变量。\n在这里，entries是一个数组，使用解构赋值的方式把它的第一个元素（下标为0）赋值给entry变量。\n等价于下面的写法：const entry = entries[0]; \nconst[entry,en2] = entries 这句与上一句类似，不同之处在于它使用了解构赋值的扩展语法。这里\n将数组entries中的前两个元素（下标为0和1）依次解构并赋值给entry和en2两个变量，可以理解为：\nconst entry = entries[0];\nconst en2 = entries[1];*/\n\n++++++++++++++++++++++ 方式一:使用 map() 方法将提若干属性取到一个数组中，而不必返回整个对象\nconst {data} = JSON.parse(jsonString);//const data = JSON.parse(jsonString).data;\n\n//注意，如果提取的属性是惟一的就用find(),因为发现目标后会理解返回对象，不在执行遍历\nconst products = data.filter(obj => obj.product === \"DBOne\").map(obj => {\n  //注意这里return的用法\n  return {\n    product: obj.product,\n    btnUrl: obj.btnUrl\n  };\n});\n\n++++++++++++++++++++++++++++++++方式二\n优化方案：对象解构的方式比 map更优雅，不同点：map返回的是数组，对象解构的是属性\nconst { product, btnUrl } = data.find(obj => obj.product === \"DBOne\");\n/*在这个例子中，find() 方法用于查找具有 'product' 值为 'DBOne' 的对象，\n并将其存储在一个变量中。然后，对象解构用于从该对象中提取 'product' 和\n'btnUrl' 字段，并将它们存储在 product 和 btnUrl 变量中。*/\n\n+++++++++++++++++++++++++++++++ 方式三\n/*上一个方法适用于您只需要访问少量字段的情况，并且不需要修改对象。\n如果您需要修改对象，那么您可能需要返回整个对象。在这种情况下，\n您可以使用对象解构来清晰地指定要修改的字段。例如，以下代码仅修改 'product' 字段：*/\nconst obj = data.find(obj => obj.product === \"DBOne\");\nconst { product, ...rest } = obj;\n//将rest对象与修改后的product字段合并到一个新的对象modifiedObj中\nconst modifiedObj = {\n  ...rest,\n  product: \"New Product Name\"\n};\n\n++++++++++++++++++++++++++++++ 方式四 核心：obj[key]\n//将产品信息存储在一个对象中，其中键是产品名称，值是产品信息对象，如下所示：\nconst products = {\n  \"DBOne\": {\n    essentials: [\"essential1\", \"essential2\"],\n    subTitle: \"演示要点\"\n  },\n  \"DBOne Monitor\": {\n    essentials: [\"essential3\", \"essential4\"],\n    subTitle: \"演示要点\"\n  },\n  \"DBSync\": {\n    essentials: [\"essential5\", \"essential6\"],\n    subTitle: \"演示要点\"\n  },\n  //...\n};\n//然后，在代码中，您可以使用 products 对象来查找相应产品的信息，如下所示：\n//const productName = 'DBSync';\nconst productName = findProductName(queryParameters);\n//productName in products 返回布尔值\nif (productName in products) {\n  //由于products的属性是对象形式，这里productInfo会返回一个目标对象\n  const productInfo = products[productName];\n  //productInfo是对象，这里可以进行解构\n  const { essentials, subTitle } = productInfo;\n    console.log('productInfo:',productInfo)\n    console.log('essentials:',essentials)\n} else {\n  console.log(`Product not found for name '${productName}'`);\n}\n\nfunction findProductName(queryParameters) {\n  if (queryParameters.includes(\"11.0.2.10:8080\")) {\n    return \"DBOne\";\n  } else if (queryParameters.includes(\"11.0.2.14:9090\")) {\n    return \"DBOne Monitor\";\n  } else if (queryParameters.includes(\"11.0.2.17:8888\")) {\n    return \"DBSync\";\n  } else {\n    return null;\n  }\n}\nfunction findProductName(queryParameters) {\n  if (queryParameters.includes(\"11.0.2.10:8080\")) {\n    return \"DBOne\";\n  } else if (queryParameters.includes(\"11.0.2.14:9090\")) {\n    return \"DBOne Monitor\";\n  } else if (queryParameters.includes(\"11.0.2.17:8888\")) {\n    return \"DBSync\";\n  } else {\n    return null;\n  }\n}\n/*在这个版本的代码中，我们首先定义了一个名为 `products` 的对象，用于存储不同产品的信息\n。然后，我们定义了一个名为 `findProductName` 的函数，用于根据查询参数返回相应的产品名称。\n接下来，在代码中，我们首先调用 `findProductName` 函数，找到相应的产品名称。然后，我们使用\n `products` 对象来查找该产品的信息，并更新 UI 元素的内容。\n这个版本的代码更简洁、更易于维护，而且可以很容易地添加或删除产品信息，而无需修改多个 `if` 代码块。*/\n\n//其他\nconst value = document.querySelector(\"input').value;\n//可以优化为\nconst {value} = document.querySelector(\"input')"
        },
        {
          "label": "Fragment 2",
          "language": "javascript",
          "value": "let recipe = data.recipe\n//优化：\n//ap返回的是数组，对象解构的是属性\nlet {recipe} = data\n\nconst [entry] = entries; //const entry = entries[0]"
        }
      ],
      "id": "Pfb1HxdY",
      "createdAt": 1677576889200,
      "updatedAt": 1682915002242
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "nNH97xs5"
      ],
      "description": null,
      "name": "map() 方法",
      "content": [
        {
          "label": "Mapping Product Names",
          "language": "javascript",
          "value": "//对象 +字典模式\nconst productMap = {\n      \"11.0.2.10:8080\": \"DBOne\",\n      \"11.0.2.14:9090\": \"DBOne Monitor\",\n      \"11.0.2.17:8888\": \"DBSync\",\n      \"11.0.2.15:9090\": \"DBMigrate\",\n      \"11.0.2.28:9090\": \"DDMOne\",\n      \"11.0.2.50:8080\": \"StoreOne\",\n      \"11.0.0.34:8888\": \"AnalyzeOne\",\n      \"11.0.2.20:8002\": \"DataOne\",\n      \"11.0.24.121:8002\": \"DataOne\",\n      \"11.0.2.91:8888\": \"LogOne\",\n      \"11.0.1.149:9090\": \"UIOne\",\n      \"11.0.2.40:83\": \"GraphOne\",\n      \"11.0.2.41:9080\": \"KGOne\",\n      \"11.0.4.127:9080\": \"KGOne\",\n      //TODO: CanOne 业务系统\n      \"11.0.2.37:38800/\": \"CanOne\",\n      \"11.0.2.37:38900\": \"CanOne\",\n      \"11.0.0.160:8080\": \"InforOne\",\n      \"11.0.2.30:38100\": \"BinOne\",\n      \"11.0.2.30:38200\": \"BinOne\",\n      // TODO: RangeOne 管理员\n      \"11.0.1.54\": \"RangeOne\",\n      \"11.0.2.91:9090\": \"RS-Training\",\n    };\n    //注意Object.keys()的简单用法，另外find()返回的是对象，includes()返回的是布尔值\n    let includesKey = Object.keys(productMap).find((key) =>\n      queryParameters.includes(key)\n    );\n    if (includesKey) { //includesKey 是相关页面的url地址\n      const productName = productMap[includesKey];//这里就很简单了，是键值对的值，基础知识都很简单但很容易迷惑\n      updateUI(productName, formatEssentials);\n    }"
        },
        {
          "label": "对象 +字典模式",
          "language": "javascript",
          "value": "将学生的考试成绩转化为用ABCD表示的等级:60-70为D;...70-80为C...\n\n/* 最优版本 使用对象 +字典模式*/\nfunction transformScore(score) {\n  var resultMap = {\n    '6':'D',\n    '7':'C',\n    '8':'B',\n    '9':'A',\n    '10':'A'\n  }\n\treturn resultMap[Math.floor(score/10) //将 score 除以 10 再向下取整\n}\n\n/* 版本一 直译业务逻辑 --初级程序员特征：用代码翻译业务逻辑 */\nfunction transformScore(score){\n  if(score >= 60 && score < 70) return 'D';\n  if(score >= 70 && score < 80) return 'C';\n  if(score >= 80 && score < 90) return 'B';\n  if(score >= 90 && score <= 100) return 'A';\n}\n\n/*版本三 使用字符串 +字典模式*/\nfunction transformScore(score) {\n\treturn 'DCBAA'[(Math.floor(score / 10)) - 6];\n}"
        },
        {
          "label": "数组字段的值用逗号连接起来",
          "language": "javascript",
          "value": "var dataList = [{\n    id:0,\n    name:'Tony',\n    food:['apple', 'peach', 'coconut']\n},{...},{...}];\n\n//需要将所有food字段的值用逗号连接起来，拼成一个字符串后发送给后台\n\n/*版本三*/\nresult = dataList.map(item=>item.food.join(',')).join(',');\n\n\n/*版本一*/\nvar result = '';\nfor (var i = 0; i < dataList.length; i++){\n    for (var j = 0; j < dataList[i].food.length; j++){\n        result = result + dataList[i].food[j] + ',';\n    }\n}\nresult = result.slice(0,-1);\n\n/*版本二*/\nvar result = [];\nfor (var i = 0; i < dataList.length; i++){\n    for (var j = 0; j < dataList[i].food.length; j++){\n        result.push(dataList[i].food[j]);\n    }\n}\nresult = result.join(',');\n\n"
        },
        {
          "label": "map出list",
          "language": "javascript",
          "value": "<ul>\n   ${ingredients.map(ing => `<li>${ing}</li>`).join('')}\n</ul>"
        },
        {
          "label": "用map重构集合的数据结构",
          "language": "javascript",
          "value": "\n// 基于事件委托实现移除的操作\n/* upload_list.addEventListener('click', function (ev) {\n    let target = ev.target,\n        curLi = null,\n        key;\n    if (target.tagName === 'EM') {\n        curLi = target.parentNode.parentNode;\n        if (!curLi) return;\n        upload_list.removeChild(curLi);\n        key = curLi.getAttribute('key');\n        _files = _files.filter(item => item.key !== key);\n        if (_files.length === 0) {\n            upload_list.style.display = 'none';\n        }\n    }\n}); */\n\nupload_inp.addEventListener('change', async function () {\n    _files = Array.from(upload_inp.files);//将类数组转变为数组\n    if (_files.length === 0) return;\n    // 我们重构集合的数据结构「给每一项设置一个位置值，作为自定义属性存储到元素上，后期点击删除按钮的时候，我们基于这个自定义属性获取唯一值，再到集合中根据这个唯一值，删除集合中这一项」\n    _files = _files.map(file => {\n       // 返回的是一个个对象\n        return {\n            file,\n            filename: file.name,\n            key: createRandom()\n        };\n    });\n    // 绑定数据\n    let str = ``;\n    //下面展示出上传文件的列表\n    _files.forEach((item, index) => {\n        str += `<li key=\"${item.key}\">\n            <span>文件${index+1}：${item.filename}</span>\n            <span><em>移除</em></span>\n        </li>`;\n    });\n    upload_list.innerHTML = str;\n    upload_list.style.display = 'block';\n});"
        }
      ],
      "id": "Hr3Ejo-4",
      "createdAt": 1677576967090,
      "updatedAt": 1692179648488
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": "简单来说，高阶函数是以其他函数为操作对象的函数。Higher-order Function:是指可以接受其他函数作为参数，或者返回一个函数的函数\n在JavaScript中，函数被视为一等公民（First-class Citizen），意味着函数可以像任何其他值一样被赋值给变量、传递给函数，以及从函数中返回。因此，JavaScript非常适合使用高阶函数的编程风格。\n高阶数组方法：如 map、filter、reduce 等方法，它们接受其他函数作为参数，并对数组进行处理。\n高阶函数的使用可以提高代码的可读性、灵活性和重用性，让我们能够更好地组织和抽象复杂的逻辑",
      "name": "高阶函数",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "// 转换为一个字符串\nconst oneWord = function (str) {\n  //全局去除空格，并转换为小写\n  return str.replace(/ /g, '').toLowerCase();\n};\n//将字符串句子的第一个词全部转换为大写\nconst upperFirstWord = function (str) {\n  //先转换为数组，并利用扩展运算符spread将首个单词抽离成变量方便下面操作\n  const [first, ...others] = str.split(' ');\n  //转换为字符串\n  return [first.toUpperCase(), ...others].join(' ');\n};\n\n// Higher-order function 高阶函数:Functions Accepting Callback Functions\nconst transformer = function (str, fn) {\n  console.log(`Original string: ${str}`);\n  console.log(`Transformed string: ${fn(str)}`);\n  //函数也是对象所以也有name属性\n  console.log(`Transformed by: ${fn.name}`);\n};\n\ntransformer('JavaScript is the best!', upperFirstWord);\ntransformer('JavaScript is the best!', oneWord);"
        }
      ],
      "id": "-ca1xOVn",
      "createdAt": 1677578180579,
      "updatedAt": 1688094470513
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "函数参数值",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "//原始数据类型在调用栈中会生成副本，此时副本的改动与原数据无关，引用类型在堆中直接被改变\n// How Passing Arguments Works: Values vs. Reference\nconst flight = 'LH234';\nconst jonas = {\n  name: 'Jonas Schmedtmann',\n  passport: 24739479284,\n};\nconst checkIn = function (flightNum, passenger) {\n  flightNum = 'LH999';//函数内这个对原始数据类型参数值的变更是无效的，因为调用栈中已经有副本\n  passenger.name = 'Mr. ' + passenger.name; //而引用类型会改变原始对象或数组的值\n  if (passenger.passport === 24739479284) {\n    alert('Checked in');\n  } else {\n    alert('Wrong passport!');\n  }\n};\ncheckIn(flight, jonas); // Checked in\nconsole.log(flight); // LH234\nconsole.log(jonas); // {name: 'Mr. Jonas Schmedtmann', passport: 24739479284}\n\n// Is the same as doing...\n// const flightNum = flight;\n// const passenger = jonas;\n\n//注意下面传进去的是对象，函数内的更改也会变更原始对象的值\nconst newPassport = function (person) {\n  person.passport = Math.trunc(Math.random() * 100000000000);\n};\nnewPassport(jonas);\n//jonas的passport被更改了，checkIn的条件不成立了\ncheckIn(flight, jonas);//Wrong passport!"
        }
      ],
      "id": "M1LHwx0r",
      "createdAt": 1677579927015,
      "updatedAt": 1677579935350
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "3BVGYMMN",
      "tagsIds": [],
      "description": null,
      "name": "css 下划线",
      "content": [
        {
          "label": "Fragment 1",
          "language": "plain_text",
          "value": "background-image: linear-gradient(90deg,#fae54d 0,#fae54d);\nbackground-position: left bottom 20%;\nbackground-repeat: repeat-x;\nbackground-size: 1px 4px;"
        }
      ],
      "id": "gzvnkrMo",
      "createdAt": 1677579971923,
      "updatedAt": 1678189146112
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "append",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "// 格式化字符，将字符转换为驼峰形式，注意其中的dom操作，append\\createElement \n // 测试用，粘贴到textarea\n    //     underscore_case\n    //  first_name\n    // Some_Variable\n    //   calculate_AGE\n    // delayed_departure\n    document.body.append(document.createElement(\"textarea\"));\n    document.body.append(document.createElement(\"button\"));\n    let btn = document.querySelector(\"button\");\n    btn.innerText = \"Btton\";\n\n    btn.addEventListener(\"click\", function () {\n      // 获取textarea的内容\n      const text = document.querySelector(\"textarea\").value;\n      const rows = text.split(\"\\n\");\n      for (const [i, row] of rows.entries()) {\n        // split()后就是是数组，所以下面可以从数组里解构出两个变量\n        const [first, second] = row.toLowerCase().trim().split(\"_\");\n        // replace()参数第二个可以替换掉第一个\n        const output = `${first}${second.replace(\n          second[0],\n          second[0].toUpperCase()\n        )}`;\n        // 很简单根据循环次数输出-)\n        console.log(`${output.padEnd(20)}${\"-)\".repeat(i + 1)}`);\n      }\n    });"
        }
      ],
      "id": "MrNllTU0",
      "createdAt": 1677580076299,
      "updatedAt": 1677580084420
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "oKLYhCZS",
        "dzcTexb5"
      ],
      "description": "模板字符串里可以写表达式，比如模板字符串里可以写map()方法等，当然也可以直接写 html",
      "name": "String常用方法",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "//去除字符串空格\nconst trim = function(str, type) { // 去除空格， type:  1-所有空格  2-前后空格  3-前空格 4-后空格\n  type = type || 1\n  switch (type) {\n    case 1:\n      return str.replace(/\\s+/g, '')\n    case 2:\n      return str.replace(/(^\\s*)|(\\s*$)/g, '')\n    case 3:\n      return str.replace(/(^\\s*)/g, '')\n    case 4:\n      return str.replace(/(\\s*$)/g, '')\n    default:\n      return str\n  }\n}\n\n//字符串大小写转换\n\nconst changeCase = function(str, type) { // 字符串大小写转换 type:  1:首字母大写  2：首页母小写  3：大小写转换  4：全部大写  5：全部小写\n  type = type || 4\n  switch (type) {\n    case 1:\n      return str.replace(/\\b\\w+\\b/g, function(word) {\n        return word.substring(0, 1).toUpperCase() + word.substring(1).toLowerCase()\n      })\n    case 2:\n      return str.replace(/\\b\\w+\\b/g, function(word) {\n        return word.substring(0, 1).toLowerCase() + word.substring(1).toUpperCase()\n      })\n    case 3:\n      return str.split('').map(function(word) {\n        if (/[a-z]/.test(word)) {\n          return word.toUpperCase()\n        } else {\n          return word.toLowerCase()\n        }\n      }).join('')\n    case 4:\n      return str.toUpperCase()\n    case 5:\n      return str.toLowerCase()\n    default:\n      return str\n  }\n}\n\n//MSN搜索技巧  搜索：msn string repalce ,后面一个关键字是你要搜索的具体方法\n// Split and join 非常重要和常用\n//从'+'处split成数组\nconsole.log('a+very+nice+string'.split('+'));//['a', 'very', 'nice', 'string']\nconsole.log('Jonas Schmedtmann'.split(' '));\nconst [firstName, lastName] = 'Jonas Schmedtmann'.split('');//['Jonas', 'Schmedtmann']\nconst newName = ['Mr.',firstName, lastName.toUpperCase()].join();\nconsole.log(newName);\n\n//综合应用 slice() replace()  join()  for of    \nconst capitalizeName = function(name){\n    const names = name.split(' ');\n    const namesUpper = [];\n    for (const n of names){//of 后面跟的是数组\n      //namesUpper.push(n[0].toUpperCase()+ n.slice(1)) 下面和这里一样的结果\n      namesUpper.push(n.replace(n[0],n[0].toUpperCase()\n))\n    }\n      console.log(namesUpper.join(' '));\n}\n    \ncapitalizeName('jessica ann smith davis');\ncapitalizeName('jonas schmedtmann');\nVM1047:8 Jessica Ann Smith Davis\n\n// replacing\nconst priceGB ='288,97f'\nconst priceUS = priceGB.replace('f','$').replace(',','.')\nconsole.log(priceUS);\n\nconst announcement ='All passengers come to boarding door 23. Boarding door 23!'\nconsole.log(announcement.replace('door' ,'gate'));//只能匹配第一个 \nconsole.log(announcement.replaceAll('door','gate'));//全部匹配\nconsole.log(announcement.replace(/door/g,'gate'));//全部匹配\n\n//padStart()  padEnd()  slice()参数负数的应用\nconst message = 'Go to gate 23!!';\n//注意链式用法\nconsole.log(message.padStart(20,'+').padEnd(30,'+'))//+++++Go to gate 23!!++++++++++\n\n//银行卡只显示后几位数\nconst maskCreditCard = function (number) {\n   const str = number + ''; //将 number 这个变量转换为字符串类型\n   const last = str.slice(-4);\n   return last.padStart(str.length, '*');\n}\nconsole.log(maskCreditCard(64637836));//****7836\nconsole.log(maskCreditCard(43378463864647384));//*************7384\nconsole.log(maskCreditCard('334859493847755'))//***********7755 \n\n//includes() 返回布尔值\nconsole.log(announcement.includes('door')); //true\n\n//startsWith()  endswith() 都返回布尔值\nconsole.log(announcement.startsWith('All')); //true\n\n// repeat()  注意${'D'.repeat(n)}的用法,会repeat前面\nconst message2 = 'Bad waether... All DepartuesDelayed...'\nconsole.log(message2.repeat(5));\n\nconst planesInLine = function (n) {\n   console.log(`There are ${n} planes in line ${'D'.repeat(n)}`);\n}\nplanesInLine(5);\nplanesInLine(3);\nplanesInLine(12);\n\n// Practice exercise\nconst checkBaggage = function (items){\n  const baggage = items.toLowerCase(); //先全部转为小写\n    \n  if (baggage.includes('knife') || baggage.includes('gun')){\n     console.log('You are NOT allowed on board');\n  }else {\n     console.log('Welcome aboard!');\n  }\n}\ncheckBaggage('I have a laptop, some Food and a pocket Knife');\ncheckBaggage('Socks and camera');\ncheckBaggage('Got some snacks and a gun for protection');\n\n// String Methods Practice，下面格式化了一段机场信息，重点是for of 的用法，\n\nconst flights = '_Delayed_Departure;fao93766109;txl2133758440;11:25+_Arrival;bru0943384722;fao93766109;11:45+_Delayed_Arrival;hel7439299980;fao93766109;12:05+_Departure;fao93766109;lis2323639855;12:30';\n\n// 🔴 Delayed Departure from FAO to TXL (11h25)\n//              Arrival from BRU to FAO (11h45)\n//   🔴 Delayed Arrival from HEL to FAO (12h05)\n//            Departure from FAO to LIS (12h30)\n\nconst getCode = str => str.slice(0, 3).toUpperCase();\n\n//of的时候可以直接split()将字符串转为数组\nfor (const flight of flights.split('+')) {\n  //要深刻理解下面一行代码,非常重要！split()将字符串转为了数组，而左边对数组进行了解构，结构的变量名是自定义的\n  //左边解构之前的前提要了解结构的目标解构，这里的字符串是四个部分所以自定义了4个变量名\n  const [type, from, to, time] = flight.split(';');\n  //注意模板字符串里可以写表达式，并且可以直接写 html\n  const output = `${type.startsWith('_Delayed') ? '🔴' : ''}${type.replaceAll('_',' ')} \n  ${getCode(from)} ${getCode(to)} (${time.replace(':', 'h')})`.padStart(36);\n  console.log(output);\n  //直接写模板字符串,并且可以用原始html的排列解构,数据可以用${}包裹\n  const html = ` \n    <li class=\"workout workout--${workout.name}\" data-id=\"${workout.id}\">\n        <h2 class=\"workout title\">Running on April 14</h2>\n        <div class=\"workout__details\">\n          <span claps=\"workout_ icon\">${workout.distance}</span>\n          ....\n        </li>\n     `;\n}\n//模板字符串的使用,参数的传递的用法，最基础但最常用和被轻视\nconst getCountryData = function(country){\n   ...\n   request.open('GET', `https://restcountries.eu/rest/v2/name/${country}`);\n   request.send();  \n   ...\n}\ngetCountryData('japan')//参数传递给url,可见上面使用了一个函数的唯一作用就是传递了一个参数\n\n"
        },
        {
          "label": "模板字符串等的应用",
          "language": "javascript",
          "value": "\nimport icons from '../img/icon.svg'//这里的 icons只是一个路径，会拼接在下面的href的路径里\n//添加一个loading\nconst renderSpinner = function(parentEl){\n  const markup = `\n     <div class=\"spinner\">\n        <svg>\n           <-- ${icons}使用的是上面imoort进来的路径 -->\n           <use href=\"${icons}#icon-loader\"></use>\n        </svg>\n     </div>\n   `;\n   parentEl.innerHTML ='';\n   parentEl.insertAdjacentHTML('afterbegin',markup)\n}\n\n//++++++++++++++++++++++++++++ 模板字符串在路径的应用\n//获取当前 URL 中的哈希值，即 # 号后面的部分,字符串的 slice() 方法，从索引为 1 的位置开始截取字符串,去除了#\nconst id = window.location.hash.slice(1);\n//注意这个return的用法,是把所有代码包裹在if{}d代码块里的优化写法，更易读易用；\nif (!id) return;//这里可以避免找不到id的时候下面一行的loading一直没完的状态\n// 1) Loading recipe\nrenderSpinner(recipeContainer);\nconst res = await fetch(\n    `https://forkify-api.herokuapp.com/api/v2/recipes/${id}`\n     const data = await res.json();\n...."
        }
      ],
      "id": "_ICz9XMC",
      "createdAt": 1677580106476,
      "updatedAt": 1690627609462
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": "getter method is basically so that we can get a value out of an object by simply writing a property instead of writing a method；and the same for the setter method",
      "name": "Setters and Getters",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "const account = {\n   owner: 'Jonas',\n   movements: [200,530,120,300],\n   get latest() {\n       //pop()会有返回值\n      return this.movements.slice(-1).pop();\n   },\n   \n   set latest(mov) {\n      this.movements.push(mov);\n   },\n}\n//直接像属性一样调用,就会运行方法\nconsole.log(account.latest);//300\n//setters也一样像属性一样调用\naccount.latest = 50;\nconsole.log(account.movements);// [200, 530, 120, 300, 50]"
        }
      ],
      "id": "GMTtvAY_",
      "createdAt": 1677580193622,
      "updatedAt": 1680318688772
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "Set 数组去重",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "const arr1 = [1, 2, 3];\nconst arr2 = [3, 4, 5];\n\nconsole.log(new Set([...arr1, ...arr2]));"
        }
      ],
      "id": "EndzCZeg",
      "createdAt": 1677580693182,
      "updatedAt": 1677580699798
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "sCWt0xKF"
      ],
      "description": null,
      "name": "localStorage",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "\nlocalStorage is a very simple APl.主要了解存入时对象要转成字符串，获取时字符串要转为对象,\n另外注意：objects coming from local storage，will not inherit all the methods that they did before,原因是中间有个格式转换\n\nJSON.stringify() //to convert any object in JavaScript to a string\n//下面存储的对象是这样的：Key:workouts; Value:[\"date\":\"2020-08-22T07:16:54.493Z\"\"id\":\"8080614493\"\"clicks\":0..\nJSON.parse() //将对象转换为字符串\n\n_setLocalStorage() {\n   //第二个参数是把对象转换为字符串存入localStorage\n  localstorage.setItem('workouts', JSON,stringify(this.#workouts));\n}\n\n_getLocalStorage() {\n  //第二个参数是把字符串转换为对象然后获取\n  const data = JSON.parse(localStorage.getItem('workouts'));\n  //console.log(data);\n  if(!data) return\n  this.#workouts = data\n  this.#workouts.forEach(work => {\n    this._renderWorkout(work);\n  })\n}\n\nreset(){\n   localStorage.removeItem('workouts');\n   location.reload();\n}\n\n\n// +++++++++++++++++++++++++++++++++++++++++++++++++++\n<textarea id=\"note\" cols=\"30\" rows=\"10\"></textarea><br>\n<input type=\"button\" id=\"save\" value=\"Save\">\n\nconst elmNote = document.getElementById(\"note\");\nconst elmSave = document.getElementById(\"save\");\n\nlet note = localStorage[\"note\"];\nif (note == null) {\n  note = \"\";\n}\nelmNote.value = note;\n\nelmSave.onclick = () => {\n  localStorage[\"note\"] = elmNote.value;\n};\n\n================================== 引跑项目\n//获取localStorage 还可以是document.localStorage.uid (document的方式更适合iframe)或localStorage.getItem(\"uid\");\n\n user_id: window.localStorage.uid\n\n methods: {\n    getLogData() {\n      getLog({\n        'namespace': `can6-user-${this.user_id}`,\n        'containerName': 'ok'\n      }).then(res => {\n        this.tableLog = res.data.list\n      })\n}\n"
        },
        {
          "label": "init(); //进入页面就获取localStorage",
          "language": "javascript",
          "value": "//存储localStorage\nconst persistBookmarks = function (){\n\tlocalStorage.setItem('bookmarks', JSON.stringify(statebookmarks));\n}\npersistBookmarks()\n\n//获取localStorage\nconst init = function(){\n\tconst storage = localStorage.getItem('bookmarks');\n  if (storage) state.bookmarks = JSON.parse(storage);//将localStorage存入某个对象变量\n};\ninit(); //进入页面就获取localStorage\nconsole.log(state.bookmarks)"
        },
        {
          "label": "将座位的index数组存入localStorage",
          "language": "javascript",
          "value": "const selectedSeats = document.querySelectorAll('.row ,seat.selected')\n\nconst seatsIndex = [...selectedSeats].map(seat => [...seats].index0f(seat)); //这里是重点\nlocalStorage.setItem('selectedSeats', JSON.stringify(seatsIndex));"
        },
        {
          "label": "获取localStorage",
          "language": "javascript",
          "value": "1) getItem()方法:\n\n如果你在localStorage中存储了一个名为\"username\"的键值对，你可以通过以下代码获取它的值：\nvar username = localStorage.getItem(\"username\");\nconsole.log(username);\n它是浏览器提供的 Web API，用于在客户端存储和访问数据，如果你想要获取所有存储在localStorage中的键值对，可以使用localStorage对象的length属性来获取存储的数量，然后通过循环遍历来获取每个键值对的值。localStorage 不是一个数组或类似数组的对象，而是一个类似字典或哈希表的对象。所以不能使用数组的方法如forEach、map等方法\n\nfor (var i = 0; i < localStorage.length; i++) {\n  var key = localStorage.key(i);\n  var value = localStorage.getItem(key);\n  console.log(key + \": \" + value);\n}\n这将会遍历localStorage中的每个键值对，并在控制台输出它们的键和值。\n\n2) 直接使用 localStorage 变量\n\nlocalStorage 是一个全局变量，可以直接通过它来访问本地存储对象。例如：\n\nvar uid = localStorage.uid;\n\nlocalStorage 对象也可以通过 document.localStorage 来访问。这种方式在某些情况下可能会更适合，特别是当你需要在 iframe 中访问父窗口的 localStorage 时。例如：\nvar uid = document.localStorage.uid;\n还可以使用 \nvar uid = window.localStorage.uid"
        }
      ],
      "id": "fihKW6fb",
      "createdAt": 1677581638818,
      "updatedAt": 1688348212389
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "用后台数据动态修改页面内容",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "document.querySelector(\".title-span\").innerHTML = \nstore.data.map((item, index) =>\n  `<li> ${index + 1} ${item.username} :---${item.password}</li>`)\n  .join(\"\");"
        }
      ],
      "id": "5zH7qNvD",
      "createdAt": 1677581715555,
      "updatedAt": 1677581767601
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "S3kIS3AR",
        "uyS3jGYa",
        "UOlf7phy"
      ],
      "description": null,
      "name": "fetch",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "let store = [];\nasync function fetchData() {\n  try {\n    const options = {\n      method: \"GET\",\n      // timeout: 5000,\n      headers: {\n        // 'X-Custom-Header': 'Custom Value'\n      },\n    };\n    //await的magic在于其返回值，就是promise的resolve\n    const res = await fetch(\n      // \"http://11.0.23.161/api/manage/entrance\",\n      \"https://www.fastmock.site/mock/a2de472a0f195923aab5cc1c7682ce28/api/chrome_ex\",\n      options\n    );\n    if (res.status == 200) {\n      store = await res.json();\n      console.log(\"store\", store);\n      // 动态修改页面内容\n      // document.querySelector(\".title-span\").innerHTML = store.data\n      //   .map(\n      //     (item, index) =>\n      //       `<li> ${index + 1} ${item.username} :---${item.password}</li>`\n      //   )\n      //   .join(\"\");\n    }\n  } catch (err) {\n    console.log(err);\n  }\n}\nfetchData()\n\n\n//fetch请求的封装\nconst fetch = function(url, setting) { // fetch请求的封装\n  let opts = { // 设置参数的初始值\n    method: (setting.method || 'GET').toUpperCase(), // 请求方式\n    headers: setting.headers || {}, // 请求头设置\n    credentials: setting.credentials || true, // 设置cookie是否一起发送\n    body: setting.body || {},\n    mode: setting.mode || 'no-cors', // 可以设置 cors, no-cors, same-origin\n    redirect: setting.redirect || 'follow', // follow, error, manual\n    cache: setting.cache || 'default' // 设置 cache 模式 (default, reload, no-cache)\n  }\n  let dataType = setting.dataType || 'json' // 解析方式\n  let data = setting.data || '' // 参数\n  let paramsFormat = function(obj) { // 参数格式\n    var str = ''\n    for (var i in obj) {\n      str += `${i}=${obj[i]}&`\n    }\n    return str.split('').slice(0, -1).join('')\n  }\n\n  if (opts.method === 'GET') {\n    url = url + (data ? `?${paramsFormat(data)}` : '')\n  } else {\n    setting.body = data || {}\n  }\n  return new Promise((resolve, reject) => {\n    fetch(url, opts).then(async res => {\n      let data = dataType === 'text' ? await res.text() : dataType === 'blob' ? await res.blob() : await res.json()\n      resolve(data)\n    }).catch(e => {\n      reject(e)\n    })\n  })\n}"
        },
        {
          "label": " 一个 getJSON 方法",
          "language": "javascript",
          "value": "const getJSON = function (url, errorMsg = 'Something went wrong') {\n  return fetch(url).then(response => {\n    if (!response.ok) throw new Error(`${errorMsg} (${response.status})`);\n    return response.json();\n  });\n};\n\n//使用getJSON\nconst getCountryData = function (country) {\n  // Country 1\n  getJSON(\n    `https://restcountries.eu/rest/v2/name/${country}`,\n    'Country not found'\n  )\n    .then(data => {\n      renderCountry(data[0]);\n      const neighbour = data[0].borders[0];\n\n      if (!neighbour) throw new Error('No neighbour found!');\n\n      // Country 2\n      return getJSON(\n        `https://restcountries.eu/rest/v2/alpha/${neighbour}`,\n        'Country not found'\n      );\n    })\n\n    .then(data => renderCountry(data, 'neighbour'))\n    .catch(err => {\n      console.error(`${err} 💥💥💥`);\n      renderError(`Something went wrong 💥💥 ${err.message}. Try again!`);\n    })\n    .finally(() => {\n      countriesContainer.style.opacity = 1;\n    });\n};\n\nbtn.addEventListener('click', function () {\n  getCountryData('portugal');\n});\n\ngetCountryData('australia');"
        },
        {
          "label": "用fetch()获取本地 json",
          "language": "javascript",
          "value": "function caclulate() {\n  fetch('items.json')\n    .then( res => res.json()) //这里是重点\n    .then(data => console.log(data)); //打印出json文件，data可以用其他名称，如res\n    //.then(data => (document.body.innerHTML = data[0].text)) //将获取到的json文件信息显示在页面\n}\n\ncaclulate();"
        },
        {
          "label": "fetch map",
          "language": "javascript",
          "value": "const whereAmI = function (lat,lng) {\n    fetch(`https://geocode.xyz/${lat},${lng}?geoit=json`)\n      .then(res => res.json())\n      .then(data => {\n      console.log(data);\n     });\n}\nwhereAmI(12.508,13.381); //这里可以打印出一个地图信息相关的对象"
        }
      ],
      "id": "zQnI5Oah",
      "createdAt": 1677581820829,
      "updatedAt": 1690771512090
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": "flatMap()是flat()和map()方法的结合，但只能flat一层的数组解构，要flat嵌套更深的数组还是需要用flat('里面放数字')",
      "name": "flatMap()",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "//data\nconst account1 = {\n  owner: 'Jonas Schmedtmann',\n  movements: [200, 450, -400, 3000, -650, -130, 70, 1300],\n  interestRate: 1.2, // %\n  pin: 1111,\n};\n\nconst account2 = {\n  owner: 'Jessica Davis',\n  movements: [5000, 3400, -150, -790, -3210, -1000, 8500, -30],\n  interestRate: 1.5,\n  pin: 2222,\n};\n\nconst account3 = {\n  owner: 'Steven Thomas Williams',\n  movements: [200, -200, 340, -300, -20, 50, 400, -460],\n  interestRate: 0.7,\n  pin: 3333,\n};\n\nconst account4 = {\n  owner: 'Sarah Smith',\n  movements: [430, 1000, 700, 50, 90],\n  interestRate: 1,\n  pin: 4444,\n};\n//注意这个用法，将一组数据再合并到一个数组\nconst accounts = [account1, account2, account3, account4];\n\n// 1) 仅使用flatMap()\naccounts.flatMap(acc => acc.movements)\n//输出：[200, 450, -400, 3000, -650, -130, 70, 1300, 5000, 3400, -150, -790, -3210, -1000, 8500, -30, 200, -200, 340, -300, -20, 50, 400, -460, 430, 1000, 700, 50, 90]\n\n// 2) 下面结合reduce(),内含多种重要概念，sums[cur > 0 ? 'deposits' : 'withdrawals']用法、解构赋值\nconst { deposits, withdrawals } = accounts\n  .flatMap(acc => acc.movements)\n  .reduce(\n    (sums, cur) => {\n      // cur > 0 ? (sums.deposits += cur) : (sums.withdrawals += cur);\n      sums[cur > 0 ? 'deposits' : 'withdrawals'] += cur;\n      return sums;\n    },\n    { deposits: 0, withdrawals: 0 } //reduce的这个参数可以是一个对象\n  );\n\nconsole.log(deposits, withdrawals);\n"
        }
      ],
      "id": "eLuyhVRm",
      "createdAt": 1677637059208,
      "updatedAt": 1677642402927
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": "监听页面滚动事件，分析clientHeight、scrollTop、scrollHeight三者的属性关系。",
      "name": "页面滚动相关",
      "content": [
        {
          "label": "页面滚动位置",
          "language": "javascript",
          "value": "1.滚动到页面顶部：使用 window.scrollTo() 平滑滚动到页面顶部。\n\nconst scrollToTop = () => {\n  window.scrollTo({ top: 0, left: 0, behavior: \"smooth\" });\n};\n\n2.滚动到页面底部：当然，如果知道文档的高度，也可以平滑滚动到页面底部。\n\nconst scrollToBottom = () => {\n  window.scrollTo({\n    top: document.documentElement.offsetHeight,\n    left: 0,\n    behavior: \"smooth\",\n  });\n};\n3.将元素滚动到可见区域：使用 scrollIntoView 就足够了。\n\nconst smoothScroll = (element) => {\n  element.scrollIntoView({\n    behavior: \"smooth\",\n  });\n};"
        },
        {
          "label": "滚动加载",
          "language": "javascript",
          "value": "window.addEventListener('scroll', function() {\n  const clientHeight = document.documentElement.clientHeight;\n  const scrollTop = document.documentElement.scrollTop;\n  const scrollHeight = document.documentElement.scrollHeight;\n  if (clientHeight + scrollTop >= scrollHeight) {\n    // 检测到滚动至页面底部，进行后续操作\n    // ...\n  }\n}, false);"
        },
        {
          "label": "获得滚动条的滚动距离",
          "language": "javascript",
          "value": "function getScrollOffset() {\n    if (window.pageXOffset) {\n        return {\n            x: window.pageXOffset,\n            y: window.pageYOffset\n        }\n    } else {\n        return {\n            x: document.body.scrollLeft + document.documentElement.scrollLeft,\n            y: document.body.scrollTop + document.documentElement.scrollTop\n        }\n    }\n}"
        },
        {
          "label": "showLoading",
          "language": "javascript",
          "value": "window.addEventListener('scroll', () => {\n  //从document.documentElement里获取三个属性\n  const { scrollTop, scrollHeight, clientHeight } = document.documentElement;\n\n  if (scrollTop + clientHeight >= scrollHeight - 5) {\n    showLoading();\n  }\n});\n\n// Show loader & fetch more posts\nfunction showLoading() {\n  loading.classList.add('show');\n\n  setTimeout(() => {\n    loading.classList.remove('show');\n\n    setTimeout(() => {\n      //page变量由于在函数外定义过，所以这里可以重定义这个变量\n      page++;\n      showPosts();\n    }, 300);\n  }, 1000);\n}"
        }
      ],
      "id": "i5D2-kdu",
      "createdAt": 1677638493940,
      "updatedAt": 1691374211803
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "6-jXY9xe"
      ],
      "description": "渲染大数据时，合理使用createDocumentFragment和requestAnimationFrame，将操作切分为一小段一小段执行。",
      "name": "渲染大数据",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "setTimeout(() => {\n  // 插入十万条数据\n  const total = 100000;\n  // 一次插入的数据\n  const once = 20;\n  // 插入数据需要的次数\n  const loopCount = Math.ceil(total / once);\n  let countOfRender = 0;\n  const ul = document.querySelector('ul');\n  // 添加数据的方法\n  function add() {\n    const fragment = document.createDocumentFragment();\n    for(let i = 0; i < once; i++) {\n      const li = document.createElement('li');\n      li.innerText = Math.floor(Math.random() * total);\n      fragment.appendChild(li);\n    }\n    ul.appendChild(fragment);\n    countOfRender += 1;\n    loop();\n  }\n  function loop() {\n    if(countOfRender < loopCount) {\n      window.requestAnimationFrame(add);\n    }\n  }\n  loop();\n}, 0)"
        }
      ],
      "id": "oJTm2crt",
      "createdAt": 1677638742750,
      "updatedAt": 1677639354561
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "输入一个值，返回其数据类型",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "function type(para) {\n    return Object.prototype.toString.call(para)\n}"
        }
      ],
      "id": "AZuMV9_7",
      "createdAt": 1677639354655,
      "updatedAt": 1677639361599
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "数组去重",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "function unique1(arr) {\n    return [...new Set(arr)]\n}"
        }
      ],
      "id": "ASQlRoXd",
      "createdAt": 1677639391624,
      "updatedAt": 1677639397482
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "获得滚动条的滚动距离",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "function getScrollOffset() {\n    if (window.pageXOffset) {\n        return {\n            x: window.pageXOffset,\n            y: window.pageYOffset\n        }\n    } else {\n        return {\n            x: document.body.scrollLeft + document.documentElement.scrollLeft,\n            y: document.body.scrollTop + document.documentElement.scrollTop\n        }\n    }\n}"
        }
      ],
      "id": "xhgrp8OR",
      "createdAt": 1677639634299,
      "updatedAt": 1691374053630
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "获取url上的参数",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "function getUrlParam(sUrl, sKey) {\n    var result = {};\n    sUrl.replace(/(\\w+)=(\\w+)(?=[&|#])/g, function (ele, key, val) {\n        if (!result[key]) {\n            result[key] = val;\n        } else {\n            var temp = result[key];\n            result[key] = [].concat(temp, val);\n        }\n    })\n    if (!sKey) {\n        return result;\n    } else {\n        return result[sKey] || '';\n    }\n}\n\n//获取url参数（3）\nconst getUrlParam = function(name) { // 获取url参数\n  let reg = new RegExp('(^|&?)' + name + '=([^&]*)(&|$)', 'i')\n  let r = window.location.href.substr(1).match(reg)\n  if (r != null) {\n    return decodeURI(r[2])\n  }\n  return undefined\n}"
        }
      ],
      "id": "xWVC1bM7",
      "createdAt": 1677639830653,
      "updatedAt": 1677639913873
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "验证邮箱的正则表达式",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "function isAvailableEmail(sEmail) {\n    var reg = /^([\\w+.])+@\\w+([.]\\w+)+$/\n    return reg.test(sEmail)\n}"
        }
      ],
      "id": "7paq4zbw",
      "createdAt": 1677639860986,
      "updatedAt": 1677639866485
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "本地存储",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "const store = { // 本地存储\n  set: function(name, value, day) { // 设置\n    let d = new Date()\n    let time = 0\n    day = (typeof(day) === 'undefined' || !day) ? 1 : day // 时间,默认存储1天\n    time = d.setHours(d.getHours() + (24 * day)) // 毫秒\n    localStorage.setItem(name, JSON.stringify({\n      data: value,\n      time: time\n    }))\n  },\n  get: function(name) { // 获取\n    let data = localStorage.getItem(name)\n    if (!data) {\n      return null\n    }\n    let obj = JSON.parse(data)\n    if (new Date().getTime() > obj.time) { // 过期\n      localStorage.removeItem(name)\n      return null\n    } else {\n      return obj.data\n    }\n  },\n  clear: function(name) { // 清空\n    if (name) { // 删除键为name的缓存\n      localStorage.removeItem(name)\n    } else { // 清空全部\n      localStorage.clear()\n    }\n  }\n}"
        }
      ],
      "id": "etnZKUnz",
      "createdAt": 1677639959428,
      "updatedAt": 1677639964799
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "cookie操作【set，get，del】",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "const cookie = { // cookie操作【set，get，del】\n  set: function(name, value, day) {\n    let oDate = new Date()\n    oDate.setDate(oDate.getDate() + (day || 30))\n    document.cookie = name + '=' + value + ';expires=' + oDate + \"; path=/;\"\n  },\n  get: function(name) {\n    let str = document.cookie\n    let arr = str.split('; ')\n    for (let i = 0; i < arr.length; i++) {\n      let newArr = arr[i].split('=')\n      if (newArr[0] === name) {\n        return newArr[1]\n      }\n    }\n  },\n  del: function(name) {\n    this.set(name, '', -1)\n  }\n}"
        }
      ],
      "id": "1X6F3giD",
      "createdAt": 1677639985188,
      "updatedAt": 1677639990608
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "Js获取元素样式【支持内联】",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "const getRealStyle = function(obj, styleName) { // Js获取元素样式【支持内联】\n  var realStyle = null\n  if (obj.currentStyle) {\n    realStyle = obj.currentStyle[styleName]\n  } else if (window.getComputedStyle) {\n    realStyle = window.getComputedStyle(obj, null)[styleName]\n  }\n  return realStyle\n}"
        }
      ],
      "id": "KO08jltQ",
      "createdAt": 1677640048458,
      "updatedAt": 1677640054853
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "判断是否是一个数组",
      "content": [
        {
          "label": "Fragment 1",
          "language": "plain_text",
          "value": "const isArray = function(arr) { // 判断是否是一个数组\n  return Object.prototype.toString.call(arr) === '[object Array]'\n}"
        }
      ],
      "id": "jYr35fvG",
      "createdAt": 1677640256411,
      "updatedAt": 1687919692212
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "常用正则验证",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "const checkStr = function(str, type) { // 常用正则验证，注意type大小写\n  switch (type) {\n    case 'phone': // 手机号码\n      return /^1[3|4|5|6|7|8|9][0-9]{9}$/.test(str)\n    case 'tel': // 座机\n      return /^(0\\d{2,3}-\\d{7,8})(-\\d{1,4})?$/.test(str)\n    case 'card': // 身份证\n      return /(^\\d{15}$)|(^\\d{18}$)|(^\\d{17}(\\d|X|x)$)/.test(str)\n    case 'pwd': // 密码以字母开头，长度在6~18之间，只能包含字母、数字和下划线\n      return /^[a-zA-Z]\\w{5,17}$/.test(str)\n    case 'postal': // 邮政编码\n      return /[1-9]\\d{5}(?!\\d)/.test(str)\n    case 'QQ': // QQ号\n      return /^[1-9][0-9]{4,9}$/.test(str)\n    case 'email': // 邮箱\n      return /^[\\w-]+(.[\\w-]+)*@[\\w-]+(.[\\w-]+)+$/.test(str)\n    case 'money': // 金额(小数点2位)\n      return /^\\d*(?:.\\d{0,2})?$/.test(str)\n    case 'URL': // 网址\n      return /(http|ftp|https)://[\\w-_]+(.[\\w-_]+)+([\\w-.,@?^=%&:/~+#]*[\\w-@?^=%&/~+#])?/.test(str)\n    case 'IP': // IP\n      return /((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))/.test(str)\n    case 'date': // 日期时间\n      return /^(\\d{4})-(\\d{2})-(\\d{2}) (\\d{2})(?::\\d{2}|:(\\d{2}):(\\d{2}))$/.test(str) ||\n        /^(\\d{4})-(\\d{2})-(\\d{2})$/.test(str)\n    case 'number': // 数字\n      return /^[0-9]$/.test(str)\n    case 'english': // 英文\n      return /^[a-zA-Z]+$/.test(str)\n    case 'chinese': // 中文\n      return /^[\\u4E00-\\u9FA5]+$/.test(str)\n    case 'lower': // 小写\n      return /^[a-z]+$/.test(str)\n    case 'upper': // 大写\n      return /^[A-Z]+$/.test(str)\n    case 'HTML': // HTML标记\n      return /<(\"[^\"]*\"|'[^']*'|[^'\">])*>/.test(str)\n    default:\n      return true\n  }\n}"
        }
      ],
      "id": "mvp1TuQ7",
      "createdAt": 1677640321006,
      "updatedAt": 1677640327409
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "原生dom操作",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "const dom = {\n  $: function(selector) {\n    let type = selector.substring(0, 1)\n    if (type === '#') {\n      if (document.querySelecotor) return document.querySelector(selector)\n      return document.getElementById(selector.substring(1))\n    } else if (type === '.') {\n      if (document.querySelecotorAll) return document.querySelectorAll(selector)\n      return document.getElementsByClassName(selector.substring(1))\n    } else {\n      return document['querySelectorAll' ? 'querySelectorAll' : 'getElementsByTagName'](selector)\n    }\n  },\n  hasClass: function(ele, name) { /* 检测类名 */\n    return ele.className.match(new RegExp('(\\s|^)' + name + '(\\s|$)'))\n  },\n  addClass: function(ele, name) { /* 添加类名 */\n    if (!this.hasClass(ele, name)) ele.className += ' ' + name\n  },\n  removeClass: function(ele, name) { /* 删除类名 */\n    if (this.hasClass(ele, name)) {\n      let reg = new RegExp('(\\s|^)' + name + '(\\s|$)')\n      ele.className = ele.className.replace(reg, '')\n    }\n  },\n  replaceClass: function(ele, newName, oldName) { /* 替换类名 */\n    this.removeClass(ele, oldName)\n    this.addClass(ele, newName)\n  },\n  siblings: function(ele) { /* 获取兄弟节点 */\n    console.log(ele.parentNode)\n    let chid = ele.parentNode.children,\n      eleMatch = []\n    for (let i = 0, len = chid.length; i < len; i++) {\n      if (chid[i] !== ele) {\n        eleMatch.push(chid[i])\n      }\n    }\n    return eleMatch\n  },\n  getByStyle: function(obj, name) { /* 获取行间样式属性 */\n    if (obj.currentStyle) {\n      return obj.currentStyle[name]\n    } else {\n      return getComputedStyle(obj, false)[name]\n    }\n  },\n  domToStirng: function(htmlDOM) { /* DOM转字符串 */\n    var div = document.createElement('div')\n    div.appendChild(htmlDOM)\n    return div.innerHTML\n  },\n  stringToDom: function(htmlString) { /* 字符串转DOM */\n    var div = document.createElement('div')\n    div.innerHTML = htmlString\n    return div.children[0]\n  }\n}"
        }
      ],
      "id": "fNlZ00al",
      "createdAt": 1677640717075,
      "updatedAt": 1677640722417
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": "JSON.stringify()     语法：JSON.stringify(value[, replacer [, space]]) ；第二个参数 replacer：过滤属性或者处理值；\n如果该参数是一个数组：则只有包含在这个数组中的属性名才会被序列化到最终的JSON字符串中\n如果该参数是一个函数︰则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理\n如果该参数为 null 或者未提供:，则对象所有的属性都会被序列化\n第三个参数space：美化输出格式",
      "name": "深入 JSON 更多参数和细节",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "const obj = {\n  name: \"云牧\",\n  age: 18,\n};\n\n// 数组和函数进行过滤属性\nconsole.log(JSON.stringify(obj, [\"name\"])); // {\"name\":\"云牧\"}\nconsole.log(\n  JSON.stringify(obj, (key, value) => {\n    if (typeof value === \"string\") {\n      return undefined;\n    }\n    return value;\n  })\n); // {\"age\":18}\n// space 美化格式\nconsole.log(JSON.stringify(obj, null, \"\\t\"));"
        }
      ],
      "id": "f4UIxRp8",
      "createdAt": 1677641381502,
      "updatedAt": 1677641758833
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": "它不会改变原数组，而是返回一个新数组；slice() 方法是 JavaScript 数组的一个方法，用于从数组中提取一个子数组，包含从起始索引到结束索引之间的元素（包括起始索引但不包括结束索引）\n。如果 start 参数是负数，表示从数组的末尾开始计算，例如 -2 表示从数组的倒数第二个元素开始提取",
      "name": "slice()方法",
      "content": [
        {
          "label": "Fragment 1",
          "language": "plain_text",
          "value": "const arr = [1, 2, 3, 4, 5];\nconst subArr = arr.slice(1, 4);\nconsole.log(subArr); // [2, 3, 4]\nconsole.log(arr); // [1, 2, 3, 4, 5]\n\n//slice() 方法还可以用于将类数组对象转换为真正的数组。例如，将一个 arguments 对象转换为数组：\nfunction foo() {\n  const args = Array.prototype.slice.call(arguments);\n  console.log(args);\n}\n\nfoo(1, 2, 3); // [1, 2, 3]\n\n//这里使用了 call() 方法，将 Array.prototype.slice 方法绑定到 arguments 对象上，并传入一个空的 this 对象，以调用 slice() 方法。这样得到的 args 数组就是 arguments 对象的副本，可以对它进行数组操作。\n"
        }
      ],
      "id": "w_83eRNH",
      "createdAt": 1677643258698,
      "updatedAt": 1677643622257
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "判断是否是一个数组",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "const isArray = function(arr) { // 判断是否是一个数组\n  return Object.prototype.toString.call(arr) === '[object Array]'\n}"
        }
      ],
      "id": "8xz6yNcN",
      "createdAt": 1677643575437,
      "updatedAt": 1677643587521
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": "它不会改变原数组，而是返回一个新数组；slice() 方法是 JavaScript 数组的一个方法，用于从数组中提取一个子数组，包含从起始索引到结束索引之间的元素（包括起始索引但不包括结束索引）\n。如果 start 参数是负数，表示从数组的末尾开始计算，例如 -2 表示从数组的倒数第二个元素开始提取",
      "name": "slice()方法",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "const arr = [1, 2, 3, 4, 5];\nconst subArr = arr.slice(1, 4);\nconsole.log(subArr); // [2, 3, 4]\nconsole.log(arr); // [1, 2, 3, 4, 5]\n\n//slice() 方法还可以用于将类数组对象转换为真正的数组。例如，将一个 arguments 对象转换为数组：\nfunction foo() {\n  const args = Array.prototype.slice.call(arguments);\n  console.log(args);\n}\n\nfoo(1, 2, 3); // [1, 2, 3]\n\n//这里使用了 call() 方法，将 Array.prototype.slice 方法绑定到 arguments 对象上，并传入一个空的 this 对象，以调用 slice() 方法。这样得到的 args 数组就是 arguments 对象的副本，可以对它进行数组操作。"
        }
      ],
      "id": "xK_DFo5S",
      "createdAt": 1677643597022,
      "updatedAt": 1677643619865
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "8EChA0GN",
        "VMVF-8hD"
      ],
      "description": "注意在[ ]里直接使用...spread扩展符的用法，document.querySelectorAll('.movements__row')的返回值就是类数组，所以在前面用 ‘...’ 很自然",
      "name": "将类数组转换为数组",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "[...document.querySelectorAll('.movements__row')].forEach(function (row, i) {\n    // 0, 2, 4, 6\n    if (i % 2 === 0) row.style.backgroundColor = 'orangered';\n    // 0, 3, 6, 9\n    if (i % 3 === 0) row.style.backgroundColor = 'blue';\n});"
        },
        {
          "label": "Fragment 2",
          "language": "javascript",
          "value": ""
        }
      ],
      "id": "WO4NKXh_",
      "createdAt": 1677665594014,
      "updatedAt": 1677911605112
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "Element Contains",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "const elementContains = (parent, child) =>\n  parent !== child && parent.contains(child)\n  \n  //Example\n  const head = document.querySelector('head')\nconst body = document.querySelector('body')\n\nelementContains(head, body) // true"
        }
      ],
      "id": "RXx-J-WS",
      "createdAt": 1677925363218,
      "updatedAt": 1677941776049
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [],
      "description": null,
      "name": "动态更换背景图的组件",
      "content": [
        {
          "label": "Fragment 1",
          "language": "plain_text",
          "value": "<template>\n    <div>\n        <div class=\"bg-image\" :style=\"{ backgroundImage: 'url(' + imageUrl + ')' }\">\n            <div class=\"l_1\">\n                <slot>默认值</slot>\n            </div>\n        </div>\n    </div>\n</template>\n\n<script>\nexport default {\n    name: 'DynamicBgImage',\n    props: {\n        imageUrl: {\n            type: String,\n            required: true,\n            // 动态图片需要使用require()引入，这个是默认的一张图，其他页面可以自定义其他图\n            default: require('../../../assets/images/winbg.png')\n        }\n    }\n}\n</script>\n\n<style lang=\"less\" scoped>\n.l_1 {\n    position: relative;\n    width: 100%;\n    height: auto;\n    padding: 1vw 1.3vw;\n    padding-bottom: -6vw;\n    margin-bottom: 1vw;\n    background: url('../../../assets/images/titleBG_5.svg') center top no-repeat;\n    background-size: contain;\n    border: 1px solid;\n    border-image: linear-gradient(180deg, rgba(0, 255, 255, 0.5) 0%, #00bbf2 20%, rgba(0, 255, 255, 0.1) 100%)2 2 2 2;\n}\n\n.bg-image {\n    width: 100%;\n    height: 100%;\n    background-size: cover;\n}\n</style>"
        }
      ],
      "id": "jBtfVxSi",
      "createdAt": 1678105375885,
      "updatedAt": 1678105641291
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [],
      "description": null,
      "name": "动态更换背景图的组件",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "<template>\n    <div>\n        <div class=\"bg-image\" :style=\"{ background: `url(${imageUrl}) no-repeat bottom / contain` }\">\n            <div class=\"l_1\">\n                <slot>默认值</slot>\n            </div>\n        </div>\n    </div>\n</template>\n\n<script>\nexport default {\n    name: 'DynamicBgImage',\n    props: {\n        imageUrl: {\n            type: String,\n            required: true,\n            // 动态图片需要使用require()引入\n            default: require('../../../assets/images/winbg.png')\n        }\n    }\n}\n</script>\n\n<style lang=\"less\" scoped>\n.l_1 {\n    position: relative;\n    width: 100%;\n    height: auto;\n    padding: 1vw 1.3vw;\n    padding-bottom: -6vw;\n    margin-bottom: 1vw;\n    background: url('../../../assets/images/titleBG_5.svg') center top no-repeat;\n    background-size: contain;\n    border: 1px solid;\n    border-image: linear-gradient(180deg, rgba(0, 255, 255, 0.5) 0%, #00bbf2 20%, rgba(0, 255, 255, 0.1) 100%)2 2 2 2;\n}\n\n.bg-image {\n    width: 100%;\n    height: 100%;\n}\n</style>\n\n//父组件这样使用：\n<winSub :imageUrl=\"imageUrl\">\n\ndata() {\n        return {\n            imageUrl: require('../../../assets/images/otherbg.png')\n        };\n    },"
        },
        {
          "label": "Fragment 2",
          "language": "plain_text",
          "value": "父组件这样使用：\n<winSub :imageUrl=\"imageUrl\"><winSub>"
        }
      ],
      "id": "VHTMKWuu",
      "createdAt": 1678105521667,
      "updatedAt": 1678170415523
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [],
      "description": null,
      "name": "Untitled snippet",
      "content": [
        {
          "label": "Fragment 1",
          "language": "plain_text",
          "value": "<template>\n    <div>\n        <div class=\"bg-image\" :style=\"{ backgroundImage: 'url(' + imageUrl + ')' }\">\n            <div class=\"l_1\">\n                <slot>默认值</slot>\n            </div>\n        </div>\n    </div>\n</template>\n\n<script>\nexport default {\n    name: 'DynamicBgImage',\n    props: {\n        imageUrl: {\n            type: String,\n            required: true,\n            // 动态图片需要使用require()引入，这个是默认的一张图，其他页面可以自定义其他图\n            default: require('../../../assets/images/winbg.png')\n        }\n    }\n}\n</script>\n\n<style lang=\"less\" scoped>\n.l_1 {\n    position: relative;\n    width: 100%;\n    height: auto;\n    padding: 1vw 1.3vw;\n    padding-bottom: -6vw;\n    margin-bottom: 1vw;\n    background: url('../../../assets/images/titleBG_5.svg') center top no-repeat;\n    background-size: contain;\n    border: 1px solid;\n    border-image: linear-gradient(180deg, rgba(0, 255, 255, 0.5) 0%, #00bbf2 20%, rgba(0, 255, 255, 0.1) 100%)2 2 2 2;\n}\n\n.bg-image {\n    width: 100%;\n    height: 100%;\n    background-size: cover;\n}\n</style>"
        }
      ],
      "id": "A0d0Z27C",
      "createdAt": 1678105616625,
      "updatedAt": 1678105623646
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "gtzXOkAc",
        "VeWisvfJ",
        "nSNzxlE3",
        "sDMjHD6T",
        "CZ0PBSsq"
      ],
      "description": "Everything related to the DOM is not realy part of js,but of the web API",
      "name": "dom 操作",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "Everything related to the DOM is not realy part of js,but of the web API,these asynchronous tasks will all run in the web API environment of the browser.And that's why loading images in JavaScript is asynchronous.So it does not happen in the call stack. So,not in the main thread of execution,but really in the web APIs environment\n\n++++++++++++++++++++++++++++++++++++++++++++insertAdjacentHTML()\ninsertAdjacentHTML() is a JavaScript method that allows you to insert HTML code into a specific position relative to an element in the DOM (Document Object Model). It can be used to add new content to a web page without overwriting the existing content.\n\nThe method takes two arguments:\n\n1) A string that specifies the position where you want to insert the HTML code. The possible values are:\n'beforebegin': inserts the HTML code before the element itself.\n'afterbegin': inserts the HTML code as the first child of the element.\n'beforeend': inserts the HTML code as the last child of the element.\n'afterend': inserts the HTML code after the element itself.\n2) A string that contains the HTML code you want to insert.\nHere is an example of how to use insertAdjacentHTML() to insert a new paragraph after an existing one:\n\nconst existingParagraph = document.querySelector('p');\nexistingParagraph.insertAdjacentHTML('afterend', '<p>This is a new paragraph</p>');//第二个参数可以写一个变量，变量里可以用``写任何html\nThis code will add a new paragraph after the existing one.\n\n\n +++++++++++++++++++++++++++++++++++++++++++++用 children 获取所有sibling element\n[...h1.parentElement.children] 将类数组转为数组；注意children可以获取所有子元素，思路是先到parentElement\n\n[...h1.parentElement.children].forEach(function (el){\n    if (el !== h1) el.style.transform = 'scale(0.5)';\n})\n\n++++++++++++++++++++++++++++++++++++++++++++++++++ Tabbed component Tab 页切换 +++++++++++++++++++++++\n实现核心就是添加或去除class样式，下面案例重点：\n1) 代理的应用，就是通过父元素给下面所有子元素添加了事件监听\n2) dom元素dataset的使用：使用dataset元素可以方便地访问和修改HTML元素的自定义属性。它也可以为JavaScript应用程序提供一种简单的方法来存储额外的信息。要使用dataset元素，您需要在HTML元素上添加属性，并将其前缀“data-”。例如，要添加一个名为“color”的属性，您可以使用data-color属性，如下所示：<div data-color=\"blue\">。然后，您可以使用JavaScript来访问这个属性，如下所示：var color = element.dataset.color;\n3) if (!clicked) return; 条件不成立立即结束执行，不执行下面程序，否则报错\n4) 通过closest()操作定位dom,配合事件代理的完成\n5)使用 forEach()方法对高亮元素的操作\n\n\ntabsContainer.addEventListener('click', function (e) {\n  const clicked = e.target.closest('.operations__tab');\n\n  // Guard clause\n  if (!clicked) return;\n\n  // Remove active classes\n  tabs.forEach(t => t.classList.remove('operations__tab--active'));\n  tabsContent.forEach(c => c.classList.remove('operations__content--active'));\n\n  // Activate tab\n  clicked.classList.add('operations__tab--active');\n\n  // Activate content area\n  document\n    .querySelector(`.operations__content--${clicked.dataset.tab}`)\n    .classList.add('operations__content--active');\n});"
        },
        {
          "label": "classList",
          "language": "javascript",
          "value": "JavaScript 中的 classList 是 DOM 元素对象的一个属性，它提供了一组方法来操作元素的类名。通过 classList，可以方便地添加、删除、切换和检查元素的类名；classList 提供了以下几个常用的方法：add() remove() toggle() contains()\n\n //==============例1\n //这段代码的作用是选取一个图片元素，将其来源更改为 \"dog.jpg\"，然后当图片加载完成时为其添加淡入动画效果。\nel = document.querySelector('img'); //选取dom元素\nel.src='dog.jpg'; //给src属性赋值\n\nel.addEventListener('load',() => {//监听load\n  el.classList.add(el.src ? 'fadeIn' : 'fadeOut') //这里只是为了展示参数里可以写表达式\n});\n//============== 例2 包含toggle() contains()\ncontainer.addEventListener('click'){\n\tif (\n     e.target.classList.contains('seat') && !e.target.classList.contains('occupied')\n  ){\n\t\te.target.classList.toggle('selected');\n\t\tupdateSelectedCount()\n    }\n})\n//==================例3\n//change事件,以下是jonas的mapty地图应用的change监听,注意closest()和classList.toggle()的使用\ninputType.addEventListener('change'，function (){\n   inputElevation.closest('.form__row').classList.toggle('form__row--hidden')\n   inputCadence.closest('.form _row').classList.toggle('formrow--hidden')\n})"
        },
        {
          "label": "给一个li元素上添加一个文本框显示一个动态的数据",
          "language": "javascript",
          "value": "// 获取要添加文本框的li元素\nconst liElement = document.querySelector('li');\n\n// 创建文本框元素\nconst inputElement = document.createElement('input');\n\n// 设置文本框属性和样式\ninputElement.setAttribute('type', 'text');\ninputElement.setAttribute('class', 'input-text');\n\n// 将文本框添加到li元素中\nliElement.appendChild(inputElement);\n\n// 动态地显示数据\ninputElement.value = '动态数据';\n\n可以使用JavaScript创建一个文本框元素，然后将其添加到指定的li元素中。具体实现步骤如下：\n获取要添加文本框的li元素，可以使用document.querySelector或document.getElementById方法获取。\n创建一个文本框元素，可以使用document.createElement方法创建。\n设置文本框元素的属性和样式，例如type属性为text、class属性为input-text等。\n将文本框元素添加到li元素中，可以使用appendChild方法将其添加为li元素的子元素。\n如果需要动态地显示数据，可以在需要的时候使用value属性给文本框元素赋值。\n\n在上面的代码中，我们首先使用document.querySelector方法获取了一个li元素，然后使用document.createElement方法创建了一个input元素。接着，我们设置了文本框的属性和样式，并使用appendChild方法将其添加到了li元素中。最后，我们使用value属性给文本框元素赋值，以动态地显示数据。\n\n需要注意的是，上面的示例代码只是给一个li元素添加了一个文本框，如果需要给多个li元素添加文本框，可以使用document.querySelectorAll方法获取多个元素，然后遍历每个元素，依次添加文本框。\n"
        },
        {
          "label": "closest()",
          "language": "javascript",
          "value": "closest() 是 JavaScript 中 DOM 元素的方法：\n是搭配事件代理常用的dom方法，比如可以实现你点击一个区域的任何地方，确保获取的是父元素，而不是你点击的子元素\n用于查找离当前元素最近的祖先元素（包括当前元素本身）中匹配指定 CSS 选择器的元素； 语法：element.closest(selector) \n\nconst myElement = document.querySelector('#my-element');\nconst closestDiv = myElement.closest('div');\n\n上面的代码将查找 ID 为 my-element 的元素的最近祖先 div 元素，如果找到则将其赋值给变量 closestDiv。\n如果没有找到，则 closestDiv 的值为 null。closest 方法可以方便地在DOM树中查找元素的祖先元素，\n特别是在需要找到指定元素的父级或更高层次的祖先元素时，它会非常有用。\n请注意，closest() 方法不仅可以用于查找祖先元素，还可以用于查找自身或后代元素中与指定选择器匹配的元素。例如，如果我们要查找当前元素自身是否具有 .inner 类，可以使用以下代码：\nconst element = document.querySelector('.inner');\nconst self = element.closest('.inner');\nconsole.log(self); // 输出 <div class=\"inner\">...</div>\n\n通过e对象获取：\nmoveToPopup(e){\n  const workoutEl = e.target.closest('.workout');\n  //console.log(workoutEl);\n  const workout = this.#workouts.find(work => work.id === workoutEl.dataset.id);//从html的data属性获取id值\n  //console.log(workout);\n}"
        },
        {
          "label": "js动态添加dom的4中方法",
          "language": "javascript",
          "value": "1）createElement()和appendChild()：//使用document.createElement()方法创建新的元素节点，然后使用parentElement.appendChild()将其添加到指定的父元素节点中。\n\nvar parentElement = document.getElementById(\"parent\");\nvar newElement = document.createElement(\"div\");\nnewElement.textContent = \"新的DOM元素\";\nparentElement.appendChild(newElement);\n\n2）innerHTML：//使用innerHTML属性设置父元素的HTML内容，可以包含新的DOM元素。\n\nvar parentElement = document.getElementById(\"parent\");\nparentElement.innerHTML += \"<div>新的DOM元素</div>\";\n\n3）insertAdjacentHTML()：//使用insertAdjacentHTML()方法在指定位置插入HTML内容。\nvar parentElement = document.getElementById(\"parent\");\nparentElement.insertAdjacentHTML(\"beforeend\", \"<div>新的DOM元素</div>\");\n\n insertAdjacentHTML()方法有四个参数，用于指定插入位置和插入的HTML内容。\n\n    position（位置）：指定要插入的位置，可以是以下四个值之一：\n\n    \"beforebegin\"：在当前元素之前插入HTML内容。\n    \"afterbegin\"：在当前元素内部的起始位置插入HTML内容。\n    \"beforeend\"：在当前元素内部的结束位置插入HTML内容。\n    \"afterend\"：在当前元素之后插入HTML内容。\n    html（HTML内容）：要插入的HTML内容，可以是任何有效的HTML字符串。\n\n    element.insertAdjacentHTML(position, html);\n\n4）insertBefore()：//使用parentElement.insertBefore()方法在指定节点之前插入新的DOM元素。\n\nvar parentElement = document.getElementById(\"parent\");\nvar referenceNode = document.getElementById(\"reference\");\nvar newElement = document.createElement(\"div\");\nnewElement.textContent = \"新的DOM元素\";\nparentElement.insertBefore(newElement, referenceNode);\n//将newElement插入到referenceNode之前。意味着在DOM结构中，newElement将成为referenceNode的前一个兄弟节点。\n\n//这些方法都可以根据需要选择适合的方式来动态添加DOM元素。"
        }
      ],
      "id": "XEhy6_vs",
      "createdAt": 1678188833239,
      "updatedAt": 1690775168209
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3BVGYMMN",
      "tagsIds": [],
      "description": null,
      "name": "渐变外边框",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "    border: 1px solid;\n    border-image: linear-gradient(180deg, rgba(0, 255, 255, 0.5) 0%, #00bbf2 20%, rgba(0, 255, 255, 0.1) 100%)2 2 2 2;"
        }
      ],
      "id": "nhDqQdnw",
      "createdAt": 1678189084177,
      "updatedAt": 1678189113611
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3BVGYMMN",
      "tagsIds": [],
      "description": null,
      "name": "css下划线",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "background-image: linear-gradient(90deg,#fae54d 0,#fae54d);\nbackground-position: left bottom 20%;\nbackground-repeat: repeat-x;\nbackground-size: 1px 4px;"
        }
      ],
      "id": "-n8mNroq",
      "createdAt": 1678189122456,
      "updatedAt": 1678189150375
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [],
      "description": null,
      "name": "Untitled snippet",
      "content": [
        {
          "label": "Fragment 1",
          "language": "plain_text",
          "value": "<template>\n  <div class=\"main-well\">\n    <div class=\"line\"></div>\n    <slot></slot>\n    <span class=\"left-top\"></span>\n    <span class=\"right-top\"></span>\n    <span class=\"left-bottom\"></span>\n    <span class=\"right-bottom\"></span>\n    <div class=\"line_bottom\"></div>\n  </div>\n</template>\n\n<style lang=\"less\" scoped>\n.line,\n.line_bottom {\n  background-image: linear-gradient(90deg, rgba(237, 240, 244, 0.00) 11%, #EEF1F5 35%, #EEF1F5 64%, rgba(238, 241, 243, 0.00) 86%);\n  width: 90%;\n  height: 1px;\n  position: absolute;\n  top: -1px;\n  left: 10%;\n}\n\n.line_bottom {\n  top: unset;\n  bottom: -1px;\n}\n\n.main-well {\n  position: relative;\n  padding: 20px;\n  padding-top: 15px;\n\n  background: url('../assets/images/line.png'),\n    linear-gradient(to bottom,\n      rgba(0, 13, 74, .7) 0,\n      rgba(0, 13, 74, .7) 20%,\n      rgba(19, 36, 98, .7) 40%,\n      rgba(19, 36, 98, .7) 80%,\n      rgba(19, 36, 98, .7) 100%);\n\n  // box-sizing: border-box;\n  // background-size: 100% auto;\n  width: 100%;\n  border: 1px solid rgb(21, 47, 119);\n\n  .left-top,\n  .right-top,\n  .left-bottom,\n  .right-bottom {\n    position: absolute;\n    width: 8px;\n    height: 8px;\n  }\n\n  .left-top {\n    left: 0;\n    top: 0;\n    border-left: solid 2px #02a6b5;\n    border-top: solid 2px #02a6b5;\n  }\n\n  .right-top {\n    right: 0;\n    top: 0;\n    border-right: solid 2px #02a6b5;\n    border-top: solid 2px #02a6b5;\n  }\n\n  .left-bottom {\n    left: 0;\n    bottom: 0;\n    border-left: solid 2px #02a6b5;\n    border-bottom: solid 2px #02a6b5;\n  }\n\n  .right-bottom {\n    right: 0;\n    bottom: 0;\n    border-right: solid 2px #02a6b5;\n    border-bottom: solid 2px #02a6b5;\n  }\n}\n</style>"
        }
      ],
      "id": "2POU4Tjx",
      "createdAt": 1678258120365,
      "updatedAt": 1678258191535
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [],
      "description": "上下两边带闪光线条，四个角带包边的窗口组件，引跑多个项目有使用",
      "name": "窗口组件",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "<template>\n  <div class=\"main-well\">\n    <div class=\"line\"></div>\n    <slot></slot>\n    <span class=\"left-top\"></span>\n    <span class=\"right-top\"></span>\n    <span class=\"left-bottom\"></span>\n    <span class=\"right-bottom\"></span>\n    <div class=\"line_bottom\"></div>\n  </div>\n</template>\n\n<style lang=\"less\" scoped>\n.line,\n.line_bottom {\n  background-image: linear-gradient(90deg, rgba(237, 240, 244, 0.00) 11%, #EEF1F5 35%, #EEF1F5 64%, rgba(238, 241, 243, 0.00) 86%);\n  width: 90%;\n  height: 1px;\n  position: absolute;\n  top: -1px;\n  left: 10%;\n}\n\n.line_bottom {\n  top: unset;\n  bottom: -1px;\n}\n\n.main-well {\n  position: relative;\n  padding: 20px;\n  padding-top: 15px;\n\n  background: url('../assets/images/line.png'),\n    linear-gradient(to bottom,\n      rgba(0, 13, 74, .7) 0,\n      rgba(0, 13, 74, .7) 20%,\n      rgba(19, 36, 98, .7) 40%,\n      rgba(19, 36, 98, .7) 80%,\n      rgba(19, 36, 98, .7) 100%);\n\n  // box-sizing: border-box;\n  // background-size: 100% auto;\n  width: 100%;\n  border: 1px solid rgb(21, 47, 119);\n\n  .left-top,\n  .right-top,\n  .left-bottom,\n  .right-bottom {\n    position: absolute;\n    width: 8px;\n    height: 8px;\n  }\n\n  .left-top {\n    left: 0;\n    top: 0;\n    border-left: solid 2px #02a6b5;\n    border-top: solid 2px #02a6b5;\n  }\n\n  .right-top {\n    right: 0;\n    top: 0;\n    border-right: solid 2px #02a6b5;\n    border-top: solid 2px #02a6b5;\n  }\n\n  .left-bottom {\n    left: 0;\n    bottom: 0;\n    border-left: solid 2px #02a6b5;\n    border-bottom: solid 2px #02a6b5;\n  }\n\n  .right-bottom {\n    right: 0;\n    bottom: 0;\n    border-right: solid 2px #02a6b5;\n    border-bottom: solid 2px #02a6b5;\n  }\n}\n</style>"
        }
      ],
      "id": "yKVDWGcB",
      "createdAt": 1678258135677,
      "updatedAt": 1678975223527
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3BVGYMMN",
      "tagsIds": [],
      "description": "这个可以应用在窗口的上下两边",
      "name": "发光线条",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "//应用 <div class='line'>\n\n.line,\n.line_bottom {\n  background-image: linear-gradient(90deg, rgba(237, 240, 244, 0.00) 11%, #EEF1F5 35%, #EEF1F5 64%, rgba(238, 241, 243, 0.00) 86%);\n  width: 90%;\n  height: 1px;\n  position: absolute;\n  top: -1px;\n  left: 10%;\n}\n\n.line_bottom {\n  top: unset;\n  bottom: -1px;\n}"
        }
      ],
      "id": "Qh9k1XS5",
      "createdAt": 1678258252252,
      "updatedAt": 1678258600130
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "Untitled snippet",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": ""
        }
      ],
      "id": "Qr3iIz4m",
      "createdAt": 1678337087185,
      "updatedAt": 1678337087185
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "Intersection Observer API",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "/*\nIntersection Observer API是一种在网页中监听元素是否进入或离开视口的JavaScript API。它允许我们异步地观察单个或多个DOM元素，以了解它们的交叉状态。\n使用Intersection Observer API可以实现许多有用的功能，例如：\n延迟加载图像和视频。\n无限滚动和分页。\n监听广告的显示和隐藏。\n视觉上显示元素的动画效果。\n该API通过IntersectionObserver类和IntersectionObserverEntry类实现。IntersectionObserver类用于创建一个观察器实例，该实例可以通过observe()方法观察指定的元素。IntersectionObserverEntry用于记录元素的交叉状态，包括交叉比例和交叉矩形等。\n以下是一个简单的例子，用于观察一个元素是否进入视口：*/\n// 创建一个IntersectionObserver实例\nconst observer = new IntersectionObserver((entries) => {\n  entries.forEach((entry) => {\n    if (entry.isIntersecting) {\n      console.log('Element is visible in the viewport');\n    } else {\n      console.log('Element is hidden in the viewport');\n    }\n  });\n});\n\n// 观察指定的DOM元素\nobserver.observe(document.querySelector('#target-element'));\n//在这个例子中，我们创建了一个IntersectionObserver实例，使用observe()方法观察一个元素，当元素进入或离开视口时，触发回调函数并打印相应的消息。"
        }
      ],
      "id": "PkpyJalX",
      "createdAt": 1678340645588,
      "updatedAt": 1678340765582
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3BVGYMMN",
      "tagsIds": [],
      "description": null,
      "name": "Untitled snippet",
      "content": [
        {
          "label": "Fragment 1",
          "language": "plain_text",
          "value": "[data-src]')\nconst imgTargets = document.querySelectorAll('img"
        }
      ],
      "id": "Wjh3Yjlm",
      "createdAt": 1678359540750,
      "updatedAt": 1678359543134
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3BVGYMMN",
      "tagsIds": [],
      "description": null,
      "name": "属性选择器",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "\nconst imgTargets = document.querySelectorAll('img[data-src]')\n\ninput[type=\"text\"]{\n//input[type=\"submit\"]\n  margin: 10px ;\n  display: block;\n}\n这种用法是CSS中的属性选择器，它可以根据元素的属性值来选择元素并设置样式。\n除了[type=\"text\"]外，还有一些其他常见的属性选择器，例如：\n\n[href]：选择具有 href 属性的元素\n[target=\"_blank\"]：选择 target 属性为 \"_blank\" 的链接元素\n[class^=\"box\"]：选择 class 属性以 \"box\" 开头的元素，如 class=\"box1\" 或 class=\"box2\"\n[data-color~=\"red\"]：选择 data-color 属性值包含 \"red\" 的元素\n这些选择器可以在CSS中灵活地应用于不同的场景。"
        }
      ],
      "id": "eLvZiojw",
      "createdAt": 1678359553335,
      "updatedAt": 1690535494358
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "CommonJs",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "//在 Nodejs 环境中，默认就支持模块系统，该模块系统遵循 CommonJS 规范\n//在 Nodejs 中一个 js 文件就是一个模块\n\n// index.js\nfunction add(a, b) {\n  return a + b;\n}\n\nfunction minus(a, b) {\n  return a - b;\n}\n\n// 导出单个\nmodule.exports = add;\n// 在别的文件引入\nconst add = require(\"index.js\");\n\n// 导出多个\nmodule.exports = {\n  add,\n  minus\n};\n// 在别的文件引入\nconst { add, minus } = require(\"index.js\");\n\n// 直接引入npm包\nconst _ = require(\"lodash\");"
        }
      ],
      "id": "1xLS6cwD",
      "createdAt": 1678364181946,
      "updatedAt": 1678364238735
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "kYeA3Yuv",
      "tagsIds": [],
      "description": null,
      "name": "Untitled snippet",
      "content": [
        {
          "label": "Fragment 1",
          "language": "plain_text",
          "value": "<template>\n<el-carousel ref=\"carousel\" :interval=\"4000\" type=\"card\" height=\"16vw\" width=\"20vw\" :autoplay=\"true\" :loop=\"true\" arrow=\"always\">\n<el-carousel-item v-for=\"(item, index) in headline\" :key=\"item.id\" :title=\"item.title\">\n<el-image class=\"main-image\" :src=\"item.file\" fit=\"fill\" @mouseenter=\"setActiveDebounced(index)\" @mouseleave=\"setActive(activeIndex)\"></el-image>\n<h3 class=\"bottom\" style=\"color:white\">{{ item.title }}</h3>\n</el-carousel-item>\n</el-carousel>\n</template>\n\n<script>\nexport default {\ndata() {\nreturn {\nactiveIndex: 0\n}\n},\nmethods: {\nsetActive(index) {\nthis.activeIndex = index;\nthis.$refs.carousel.setActiveItem(this.activeIndex);\n},\nsetActiveDebounced(fn, delay) {\nlet timerId;\nreturn function (...args) {\nif (timerId) {\nclearTimeout(timerId);\n}\ntimerId = setTimeout(() => {\nfn.apply(this, args);\ntimerId = null;\n}, delay);\n};\n},\nsetActiveDebounced: function(index) {\nthis.setActiveDebounced(this.setActive, 1000)(index);\n}\n}\n}\n</script>"
        }
      ],
      "id": "YtQR_lzz",
      "createdAt": 1678621296242,
      "updatedAt": 1679132289379
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": "这个鼠标事件是chatgpt给的方案，可用！",
      "name": "轮播图加鼠标切换事件",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "/*\n这段代码是一个基于Element UI的轮播组件，展示了一个滑动的图片列表。代码中的 el-carousel 组件是整个轮播的容器，通过设置不同的属性来控制轮播的效果。其中，interval 属性指定了轮播的间隔时间，type 属性指定了轮播的类型（这里是卡片式的轮播），height 和 width 属性指定了轮播容器的高度和宽度，autoplay 属性指定了是否自动播放，loop 属性指定了是否循环播放。\n\n在 el-carousel 组件中，每个轮播项使用 el-carousel-item 组件来表示，通过 v-for 指令循环渲染出图片列表中的每一项，并通过 @click.native 事件监听用户的点击操作。每个轮播项中包含了一张图片和一个标题，图片使用 el-image 组件来展示，通过设置 :src 属性来指定图片的路径，标题则使用 h3 标签进行展示。\n\n在 script 标签中，代码定义了一个名为 setActive 的方法，用于设置当前活动项的索引。在 data 中定义了一个名为 activeIndex 的变量，用于保存当前活动项的索引。当用户鼠标悬停在某个轮播项上时，会触发 @mouseenter 事件，调用 setActive 方法并传入该项的索引值，从而实现高亮该项。当鼠标移开时，会触发 @mouseleave 事件，调用 setActive 方法并传入当前活动项的索引值，从而取消高亮该项。\n\n在 setActive 方法中，代码使用 setTimeout 函数来实现延迟执行，当用户在400毫秒内多次悬停在不同的轮播项上时，只有最后一次悬停的项会被高亮显示。同时，代码通过 $refs 属性获取了 el-carousel 组件的引用，并调用其 setActiveItem 方法来设置当前活动项的索引值，从而实现滑动到对应的轮播项。\n\n总体来说，这段代码通过使用Element UI提供的轮播组件和事件监听机制，实现了一个简单的图片轮播效果，并且还实现了一些用户体验优化，例如延迟高亮和滑动到对应项等功能。*/\n<template>\n    <el-carousel ref=\"carousel\" :interval=\"2500\" type=\"card\" height=\"16vw\" width=\"20vw\" :autoplay=\"true\" :loop=\"true\">\n        <el-carousel-item v-for=\"(item, index) in headline\" :key=\"item.id\" :title=\"item.title\"\n            @click.native=\"clickCarousel(item)\">\n            <el-image class=\"main-image\" :src=\"item.file\" fit=\"fill\" @mouseenter=\"setActive(index)\"\n                @mouseleave=\"setActive(activeIndex)\"></el-image>\n            <h3 class=\"bottom\" style=\"color:white\">{{ item.title }}</h3>\n        </el-carousel-item>\n    </el-carousel>\n</template>\n    \n<script>\nexport default {\n    data() {\n        return {\n            activeIndex: 0\n        }\n    },\n    methods: {\n        setActive(index) {\n            clearTimeout(this.timer);\n            this.timer = setTimeout(() => {\n                this.activeIndex = index;\n                this.$refs.carousel.setActiveItem(this.activeIndex);\n            }, 400);\n        }\n    }\n}\n</script>\n<style lang=\"less\">\n/deep/.el-carousel {\n    .el-carousel__item {\n        h3 {\n            position: absolute;\n            bottom: .5vw;\n            // right: 2vw;\n            left: 50%;\n            transform: translateX(-50%);\n            color: #fff;\n            font-size: 1vw;\n            line-height: 1.2vw;\n            margin: 0;\n            padding: .2vw;\n            background-color: rgba(0, 0, 0, 0.2);\n            border-radius: 4px;\n        }\n    }\n\n    .el-carousel__arrow {\n        background-color: rgba(31, 45, 61, .4);\n        font-size: 1.5vw;\n    }\n\n    .el-carousel__indicators--outside button {\n        margin-top: .7vw;\n        background-color: yellow;\n        height: .2vw;\n        width: 3.6vw;\n        border-radius: 3px;\n\n    }\n}\n</style>"
        }
      ],
      "id": "Gb1GwSta",
      "createdAt": 1678621301490,
      "updatedAt": 1678709390338
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "kYeA3Yuv",
      "tagsIds": [
        "fyros3t1",
        "tqUZ3fHJ",
        "fDPIALBe",
        "cH71p1QA",
        "y6nX0FDZ"
      ],
      "description": "这个轮播图是对el-carousel的改造，添加了鼠标在两侧的mouseenter后的交互效果",
      "name": "el-carousel",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "<template>\n    <el-carousel ref=\"carousel\" :interval=\"2500\" type=\"card\" height=\"16vw\" width=\"20vw\" :autoplay=\"true\" :loop=\"true\">\n        <el-carousel-item v-for=\"(item, index) in headline\" :key=\"item.id\" :title=\"item.title\"\n            @click.native=\"clickCarousel(item)\">\n            <el-image style=\"width:100%; height:100%\" :src=\"item.file\" fit=\"fill\" @mouseenter=\"setActive(index)\"\n                @mouseleave=\"setActive(activeIndex)\"></el-image>\n            <h3 class=\"bottom\" style=\"color:white\">{{ item.title }}</h3>\n        </el-carousel-item>\n    </el-carousel>\n</template>\n    \n<script>\nexport default {\n    data() {\n        return {\n            activeIndex: 0\n        }\n    },\n    methods: {\n        setActive(index) {\n            clearTimeout(this.timer); //注意这里的用法，先清除再set\n            this.timer = setTimeout(() => {\n                this.activeIndex = index;\n                this.$refs.carousel.setActiveItem(this.activeIndex);\n            }, 400);\n        }\n    }\n}\n</script>\n<style lang=\"less\">\n/deep/.el-carousel {\n    .el-carousel__item {\n        h3 {\n            position: absolute;\n            bottom: .5vw;\n            // right: 2vw;\n            left: 50%;\n            transform: translateX(-50%);\n            color: #fff;\n            font-size: 1vw;\n            line-height: 1.2vw;\n            margin: 0;\n            padding: .2vw;\n            background-color: rgba(0, 0, 0, 0.2);\n            border-radius: 4px;\n        }\n    }\n\n    .el-carousel__arrow {\n        background-color: rgba(31, 45, 61, .4);\n        font-size: 1.5vw;\n    }\n\n    .el-carousel__indicators--outside button {\n        margin-top: .7vw;\n        background-color: yellow;\n        height: .2vw;\n        width: 3.6vw;\n        border-radius: 3px;\n\n    }\n}\n</style>"
        }
      ],
      "id": "dt-NnWPp",
      "createdAt": 1678709326248,
      "updatedAt": 1678975072282
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "vJCQ8FoN"
      ],
      "description": null,
      "name": "Object.prototype",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "here we can add any new method to this prototype and all the arrays will then inherit it.\nwe want to create a method which returns all the unique elements of an array，so we can then call\nthat method on any array that we want,but in practice you probably not do it  \n\nconst arr = [3，6， 5.6，9，3]; // 这种创建数组的方式实际就是： new Array === [] \nArray.prototype.unique = function () {return [...new Set(this)];\nconsole.log(arr.unique());\n\n// what's the point is that this 'from method' here is really a method that is attached to \nArray.from(document.querySelectorAll('h1'))"
        }
      ],
      "id": "p0bXd3RW",
      "createdAt": 1678843214690,
      "updatedAt": 1679061380488
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [
        "1aEWbIVG",
        "HJZBStiS"
      ],
      "description": null,
      "name": "通过 :style 动态样式实现颜色变换",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "<template>\n  <div :style=\"{ color: textColor }\">\n    {{ text }}\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      text: 'Hello, world!',\n      //如果只是在不同页面变化不同颜色只要设置这里即可，不用 mounted()那一步\n      textColor: 'red'\n    };\n  },\n  mounted() {\n    // 在mounted钩子函数中，修改textColor的值，触发样式的更新\n    setInterval(() => {\n      this.textColor = this.textColor === 'red' ? 'blue' : 'red';\n    }, 1000);\n  }\n};\n</script>"
        }
      ],
      "id": "Dxnd96bQ",
      "createdAt": 1678954152248,
      "updatedAt": 1679278212612
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "Untitled snippet",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": ""
        }
      ],
      "id": "j4HTUJgQ",
      "createdAt": 1679060835539,
      "updatedAt": 1679132256288
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "0BWL9dRi",
        "Ti7JWPw0"
      ],
      "description": null,
      "name": "JS Class",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "JS classes are really just a layer of obstruction over constructor functions\n\n    在构造函数里需要 PersonCl.call()，而class里只需要super()\n    super is basically the constructor function of the parent class\n    We don't need to specify the name of the parent class again,而 PersonCl.call()里需要\n    in super() pass in the arguments for the constructor of the parent class.\n\nkeyword extends link to PersonCl prototypes behind the scenes\n\nclass StudentCl extends PersonCl {\n//constructor is where we have all the code that is executed right when the application loads\n  constructor(fullName, birthYear, course){  \n    // Always needs to happen first! then be able to access the 'this' keyword\n    super(fullName, birthYear){\n      this.course =course; //this is not necessary\n    }\n    \n    calcAge(){\n      //子对象和父对象的同名方法会覆盖父对象的方法，因为原型链先到达子对象，这个就是对象4大支柱之一的‘多态’\n    }\n}\n\nconst martha = new StudentCl( 'Martha Jones'，2012,'computer science');\n\nconst martha = new StudentCl( 'Martha Jones'，2012);\n//如果像上面一行child里没有新的属性，和父对象一样的属性，那么class里不用写 constructor(),只要extends即可"
        },
        {
          "label": "构造函数和类的比较",
          "language": "javascript",
          "value": "过去，函数有着两种调用方式:\nfunction A(){}  //构造函数首字母大写只是管理，对程序并没有实际影响\n\nA();  // 直接调用\nnew A(); // 作为构造函数调用\n\n// 旧的写法 ===================================\nfunction User(firstName, lastName){\n  this.firstName = firstName;\n  this.lastName = lastName;\n  this.fullName = `${firstName} ${lastName}`\n}\n// 静态方法：方法附着的位置是在函数本身上的\nUser.isUser = function(u){\n\treturn !!u && !!u.fullName\n}\n//调用静态方法：通过构造函数本身调用\nUser.isUser(xxxx)\n\n//原型方法也就实例方法\nUser.prototype.sayHello = function(){\n\tconsole.log(Hello, my name is `&{this.fullName}`);\n}\nconst u = new User() // u是User的一个实例\nconst u2 = new User()\nu.sayHello() // 必须通过实例去调用的方法就是实例方法或原型方法，和静态方法是不同的\n\n新的等效写法：用class关键字的类写法,和java、C#相同的写法\nclass User{\n   constructor(firstName, lastName){ //构造器\n      this.firstName = firstName;\n      this.lastName = lastName;\n      this.fullName = `${firstName} ${lastName}`\n    }\n    \n    //静态方法\n    static isUser = function(u){ \n      return !!u && !!u.fullName\n    }\n    \n    //直接写名称就是实例方(原型方法)\n    sayHello(){\n      console.log(Hello, my name is `&{this.fullName}`);\n    }\n}\n\n\n\n另外一个实例 ==================================================================\n下面这样声明一个Book 类的方式。\n//这个是构造函数\nfunction Book(title, pages, isbn) { // {1} \n  this.title = title; \n  this.pages = pages; \n  this.isbn = isbn; \n}\n\nBook.prototype.printTitle = function() {\n\tconsole.log(this.title); \n};\n\n//我们可以用 ES2015 把语法简化，如下所示。\nclass Book { // {2} \n  constructor(title, pages, isbn) { \n    this.title = title;\n    this.pages = pages;\n    this.isbn = isbn; \n\t} \n\tprintIsbn() { \n\t\tconsole.log(this.isbn); \n  } \n}\n只需要使用class关键字，声明一个有constructor函数和诸如 printIsbn 等其他函数的类。ES2015的类是基于原型语法的语法糖。行{1}声明Book类的代码与行{2}声明的代码具有相同的效果和输出。\n\nlet book = new Book('title', 'pag', 'isbn'); \nconsole.log(book.title); // 输出图书标题 \nbook.title ='new title'; // 更新图书标题 \nconsole.log(book.title); // 输出图书标题"
        },
        {
          "label": "Untitled fragment",
          "language": "javascript",
          "value": "obstruction"
        }
      ],
      "id": "OPVIGMkU",
      "createdAt": 1679132391010,
      "updatedAt": 1690436562751
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "z_vLdu5R",
        "sUpoZMyz",
        "BRz1KFJ-",
        "AruGwEwj",
        "RfO7-oVw",
        "4DWwUyl3",
        "AI8yBMyD"
      ],
      "description": null,
      "name": "JS OOP",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "///////////////////////////////////////\n// Constructor Functions and the new Operator\nconst Person = function (firstName, birthYear) {\n  // Instance properties\n  this.firstName = firstName;\n  this.birthYear = birthYear;\n  // Never to this!\n  // this.calcAge = function () {\n  //   console.log(2037 - this.birthYear);\n  // };\n};\nconst jonas = new Person('Jonas', 1991);\nconsole.log(jonas);\n\n// 1. New {} is created\n// 2. function is called, this = {}\n// 3. {} linked to prototype\n// 4. function automatically return {}\n\nconsole.log(jonas instanceof Person);  //true\n\n\n///////////////////////////////////////\n// Prototypes\nconsole.log(Person.prototype);\n\nPerson.prototype.calcAge = function () {\n  console.log(2037 - this.birthYear);\n};\njonas.calcAge();\nmatilda.calcAge();\n\nconsole.log(jonas.__proto__);\nconsole.log(jonas.__proto__ === Person.prototype); //true\n\nconsole.log(Person.prototype.isPrototypeOf(jonas));//true\nconsole.log(Person.prototype.isPrototypeOf(matilda));//true\n\nconsole.log(Person.prototype.isPrototypeOf(Person));//false\n// Person.prototype.isPrototypeOf(matilda)是false, 这里的.prototype 更确切的说是.prototyeOfLinkedObjects\n\nPerson.prototype.species = 'Homo Sapiens';\nconsole.log(jonas.species, matilda.species);//Homo Sapiens Homo Sapiens\n\nconsole.log(jonas.hasOwnProperty('firstName'));//true\nconsole.log(jonas.hasOwnProperty('species'));//false\n\n///////////////////////////////////////\n// Use a constructor function to implement a Car\nconst Car = function (make, speed) {\n  this.make = make;\n  this.speed = speed;\n};\nCar.prototype.accelerate = function () {\n  this.speed += 10;\n  console.log(`${this.make} is going at ${this.speed} km/h`);\n};\nCar.prototype.brake = function () {\n  this.speed -= 5;\n  console.log(`${this.make} is going at ${this.speed} km/h`);\n};\nconst bmw = new Car('BMW', 120);\nconst mercedes = new Car('Mercedes', 95);\n\nbmw.accelerate();\nbmw.accelerate();\nbmw.brake();\nbmw.accelerate();\n\n///////////////////////////////////////\n// ES6 Classes\n// Class expression\n// const PersonCl = class {}\n\n// Class declaration\nclass PersonCl {\n  constructor(fullName, birthYear) {\n    this.fullName = fullName;\n    this.birthYear = birthYear;\n  }\n  // Instance methods\n  // Methods will be added to .prototype property,这里是包装过的，不用像在构造函数那样显示的写出.prototype\n  calcAge() {\n    console.log(2037 - this.birthYear);\n  }\n  greet() {\n    console.log(`Hey ${this.fullName}`);\n  }\n  get age() { //get和set可以像访问属性一样使用，是对现有属性的再加工\n    return 2037 - this.birthYear;\n  }\n  // Set a property that already exists\n  set fullName(name) {\n    if (name.includes(' ')) this._fullName = name; //_fullName 是避免同名的惯例写法\n    else alert(`${name} is not a full name!`);\n  }\n  get fullName() {\n    return this._fullName;\n  }\n  // Static method\n  static hey() {\n    console.log('Hey there 👋');\n    console.log(this);\n  }\n}\n\nconst jessica = new PersonCl('Jessica Davis', 1996);\nconsole.log(jessica);\njessica.calcAge(); //41\nconsole.log(jessica.age); //41\nconsole.log(jessica.__proto__ === PersonCl.prototype); //true\n\n//构造函数要这样写比较麻烦，所以ES6的class写法很多人会使用，虽然是伪代码\n// PersonCl.prototype.greet = function () {\n//   console.log(`Hey ${this.firstName}`);\n// };\njessica.greet();\n\n// 1. Classes are NOT hoisted\n// 2. Classes are first-class citizens\n// 3. Classes are executed in strict mode\n\n///////////////////////////////////////\n// Setters and Getters\nconst account = {\n  owner: 'Jonas',\n  movements: [200, 530, 120, 300],\n  get latest() {\n    //slice(-1)返回最后一个子数组不会改变原数组，而pop从数组中删除并返回最后一个元素\n    return this.movements.slice(-1).pop();\n  },\n  set latest(mov) {\n    this.movements.push(mov);\n  },\n};\nconsole.log(account.latest);\naccount.latest = 50;\nconsole.log(account.movements);\n\n///////////////////////////////////////\n// Object.create\nconst PersonProto = {\n  calcAge() {\n    console.log(2037 - this.birthYear);\n  },\n  init(firstName, birthYear) {\n    this.firstName = firstName;\n    this.birthYear = birthYear;\n  },\n};\n\nconst steven = Object.create(PersonProto);\nconsole.log(steven); //输出一个有calcAg方法和init属性的空对象\nsteven.name = 'Steven';\nsteven.birthYear = 2002;\nsteven.calcAge();\nconsole.log(steven.__proto__ === PersonProto);//true\nconst sarah = Object.create(PersonProto);\nsarah.init('Sarah', 1979);\nsarah.calcAge();\n\n///////////////////////////////////////\n// Coding Challenge #2\n//Re-create challenge 1, but this time using an ES6 class\nclass CarCl {\n  constructor(make, speed) {\n    this.make = make;\n    this.speed = speed;\n  }\n  accelerate() {\n    this.speed += 10;\n    console.log(`${this.make} is going at ${this.speed} km/h`);\n  }\n  brake() {\n    this.speed -= 5;\n    console.log(`${this.make} is going at ${this.speed} km/h`);\n  }\n  get speedUS() {\n    return this.speed / 1.6;\n  }\n  set speedUS(speed) {\n    this.speed = speed * 1.6;\n  }\n}\nconst ford = new CarCl('Ford', 120);\nconsole.log(ford.speedUS);\nford.accelerate();\nford.accelerate();\nford.brake();\nford.speedUS = 50;\nconsole.log(ford);\n\n///////////////////////////////////////\n// Inheritance Between \"Classes\": Constructor Functions\nconst Person = function (firstName, birthYear) {\n  this.firstName = firstName;\n  this.birthYear = birthYear;\n};\n//对象的方法不能写入构造函数，要写入原型\nPerson.prototype.calcAge = function () {\n  console.log(2037 - this.birthYear);\n};\n/*注意call方法的使用,在函数体内，我们调用了Person构造函数,并将this关键字作为第一个\n参数传递给它。这样做的目的是将Person的属性和方法添加到Student对象中,call()方法的第一个参数是this，它指定了要在其中调用Person函数的对象。这个对象是Student构造函数中的this，也就是正在创建的新学生对象。接下来的参数，即firstName和birthYear，是Person构造函数的参数。这种方式称为构造函数继承，它允许我们从一个类继承属性和方法，并在子类中添加新的属性和方法。在这个例子中，我们从Person类继承了firstName和birthYear属性，同时添加了一个新的course属性。*/\nconst Student = function (firstName, birthYear, course) {\n  Person.call(this, firstName, birthYear); //构造函数继承\n  this.course = course;\n};\n// Linking prototypes\n//在JavaScript中，每个对象都有一个原型，它是指向另一个对象的引用。原型对象上的属性和方法可以被继承到该对象上。当我们调用Object.create()方法时，我们可以将一个对象作为参数传递给它，这个对象将成为新创建对象的原型。因此，新创建的对象将继承原型对象上的属性和方法。\nStudent.prototype = Object.create(Person.prototype);\nStudent.prototype.introduce = function () {\n  console.log(`My name is ${this.firstName} and I study ${this.course}`);\n};\nconst mike = new Student('Mike', 2020, 'Computer Science');\nmike.introduce();\nmike.calcAge();\nconsole.log(mike.__proto__);\nconsole.log(mike.__proto__.__proto__);\nconsole.log(mike instanceof Student);\nconsole.log(mike instanceof Person);\nconsole.log(mike instanceof Object);\n\n//将Student的构造函数绑定到Student,因为Object.create()方法创建的对象没有constructor属性\nStudent.prototype.constructor = Student;\nconsole.dir(Student.prototype.constructor);\n\n///////////////////////////////////////\n// Coding Challenge #3\n//Use a constructor function to implement an Electric Car (called EV) as a CHILD \"class\" of Car\n\nconst Car = function (make, speed) {\n  this.make = make;\n  this.speed = speed;\n};\nCar.prototype.accelerate = function () {\n  this.speed += 10;\n  console.log(`${this.make} is going at ${this.speed} km/h`);\n};\nCar.prototype.brake = function () {\n  this.speed -= 5;\n  console.log(`${this.make} is going at ${this.speed} km/h`);\n};\nconst EV = function (make, speed, charge) {\n  Car.call(this, make, speed);\n  this.charge = charge;\n};\n// Link the prototypes\nEV.prototype = Object.create(Car.prototype);\nEV.prototype.chargeBattery = function (chargeTo) {\n  this.charge = chargeTo;\n};\nEV.prototype.accelerate = function () {\n  this.speed += 20;\n  this.charge--;\n  console.log(\n    `${this.make} is going at ${this.speed} km/h, with a charge of ${this.charge}`\n  );\n};\nconst tesla = new EV('Tesla', 120, 23);\ntesla.chargeBattery(90);\nconsole.log(tesla);\ntesla.brake();\ntesla.accelerate();\n\n///////////////////////////////////////\n// Inheritance Between \"Classes\": ES6 Classes\nclass PersonCl {\n  constructor(fullName, birthYear) {\n    this.fullName = fullName;\n    this.birthYear = birthYear;\n  }\n  // Instance methods\n  calcAge() {\n    console.log(2037 - this.birthYear);\n  }\n  greet() {\n    console.log(`Hey ${this.fullName}`);\n  }\n  get age() {\n    return 2037 - this.birthYear;\n  }\n  set fullName(name) {\n    if (name.includes(' ')) this._fullName = name;\n    else alert(`${name} is not a full name!`);\n  }\n  get fullName() {\n    return this._fullName;\n  }\n  // Static method\n  static hey() {\n    console.log('Hey there 👋');\n  }\n}\nclass StudentCl extends PersonCl {\n  constructor(fullName, birthYear, course) {\n    // Always needs to happen first! \n    super(fullName, birthYear);//这里相当于上面构造函数继承 parent.call(this，.., ..)\n    this.course = course;\n  }\n  introduce() {\n    console.log(`My name is ${this.fullName} and I study ${this.course}`);\n  }\n  calcAge() {\n    console.log(\n      `I'm ${\n        2037 - this.birthYear\n      } years old, but as a student I feel more like ${\n        2037 - this.birthYear + 10\n      }`\n    );\n  }\n}\n//下面new的对象如果和父对象参数一致，上面可以不用写constructor(),只用extends即可\nconst martha = new StudentCl('Martha Jones', 2012, 'Computer Science');\nmartha.introduce();\nmartha.calcAge();\n\n///////////////////////////////////////\n// Inheritance Between \"Classes\": Object.create\nconst PersonProto = {\n  calcAge() {\n    console.log(2037 - this.birthYear);\n  },\n  init(firstName, birthYear) {\n    this.firstName = firstName;\n    this.birthYear = birthYear;\n  },\n};\nconst steven = Object.create(PersonProto);\nconst StudentProto = Object.create(PersonProto);\nStudentProto.init = function (firstName, birthYear, course) {\n  PersonProto.init.call(this, firstName, birthYear);\n  this.course = course;\n};\nStudentProto.introduce = function () {\n  console.log(`My name is ${this.firstName} and I study ${this.course}`);\n};\nconst jay = Object.create(StudentProto);\njay.init('Jay', 2010, 'Computer Science');\njay.introduce();\njay.calcAge();"
        }
      ],
      "id": "1TLTWdlL",
      "createdAt": 1679146641540,
      "updatedAt": 1679232133244
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "MKyhwiT8"
      ],
      "description": null,
      "name": "dispatchEvent",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "// Assuming the button has an ID attribute, you can use the following code to click the button programmatically\ndocument.getElementById(\"buttonId\").click();\n// If you want to simulate a click event using code, you can use the following code snippet\n\nvar event = new MouseEvent(\"click\", {\n  bubbles: true,\n  cancelable: true,\n  view: window //which specifies the window object that the event is associated with.\n});\n\ndocument.getElementById(\"buttonId\").dispatchEvent(event);"
        }
      ],
      "id": "qYx4Mj6l",
      "createdAt": 1679401501574,
      "updatedAt": 1679401890092
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [],
      "description": null,
      "name": "",
      "content": [
        {
          "label": "Fragment 1",
          "language": "vue",
          "value": "/*管理后台不同于前台项目，会经常用到一些第三方插件，但有些插件是不得不依赖 jquery 的，如市面很多富文本基都是依赖 jquery 的，所以干脆就直接引入到项目中省事(gzip之后只有34kb，而且常年from cache,不要考虑那些吹毛求疵的大小问题，这几kb和提高的开发效率根本不能比)。但是如果第三方库的代码中出现则会直接报错。要达到类似的效果，则需要使用 webpack 内置的 ProvidePlugin 插件，配置很简单，只需要*/\n\nnew webpack.ProvidePlugin({\n  $: 'jquery' ,\n  'jQuery': 'jquery'\n})"
        }
      ],
      "id": "vknEg3DC",
      "createdAt": 1679457075706,
      "updatedAt": 1679457226713
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [],
      "description": null,
      "name": "jquery 依赖问题",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "/*管理后台不同于前台项目，会经常用到一些第三方插件，但有些插件是不得不依赖 jquery 的，如市面很多富文本基都是依赖 jquery 的，所以干脆就直接引入到项目中省事(gzip之后只有34kb，而且常年from cache,不要考虑那些吹毛求疵的大小问题，这几kb和提高的开发效率根本不能比)。但是如果第三方库的代码中出现则会直接报错。要达到类似的效果，则需要使用 webpack 内置的 ProvidePlugin 插件，配置很简单，只需要*/\n\nnew webpack.ProvidePlugin({\n  $: 'jquery' ,\n  'jQuery': 'jquery'\n})\n//这样当 webpack 碰到 require 的第三方库中出现全局的$、jQeury和window.jQuery 时，就会使用 node_module 下 jquery 包 export 出来的东西了。"
        }
      ],
      "id": "ZAmbhUBv",
      "createdAt": 1679457209734,
      "updatedAt": 1679457264785
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [],
      "description": null,
      "name": "VSCode 个人首选项配置",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "{\n  \"breadcrumbs.enabled\": true,\n  \"editor.tabSize\": 2,\n  \"editor.renderWhitespace\": \"boundary\",\n  \"editor.cursorBlinking\": \"smooth\",\n  \"editor.minimap.renderCharacters\": false,\n  \"editor.fontFamily\": \"'Fira Code', 'Droid Sans Mono', 'Courier New', monospace, 'Droid Sans Fallback'\",\n  \"editor.fontLigatures\": true,\n  \"explorer.confirmDragAndDrop\": false,\n  \"extensions.autoUpdate\": false,\n  \"files.insertFinalNewline\": true,\n  \"git.autofetch\": true,\n  \"git.path\": \"F:\\\\Program Files\\\\Git\\\\cmd\\\\git.exe\",\n  \"search.exclude\": {\n    \"**/node_modules\": true,\n    \"**/dist\": true\n  },\n  \"typescript.locale\": \"en\",\n  \"window.titleBarStyle\": \"custom\",\n  \"window.title\": \"${dirty}${activeEditorMedium}${separator}${rootName}\",\n  \"window.zoomLevel\": 1,\n  \"workbench.activityBar.visible\": true,\n  \"workbench.colorTheme\": \"Plastic - deprioritised punctuation\",\n  \"workbench.iconTheme\": \"vscode-great-icons\",\n  \"workbench.startupEditor\": \"newUntitledFile\",\n  \"eslint.autoFixOnSave\": true,\n  \"eslint.validate\": [\"javascript\", \"javascriptreact\", \"vue\"],\n  \"vsicons.projectDetection.autoReload\": true,\n  \"vsicons.dontShowNewVersionMessage\": true,\n  \"tslint.autoFixOnSave\": true,\n  \"debugwrapper.wrappers\": {\n    \"default\": \"console.log('$eSEL', $SEL)\"\n  },\n  \"prettier.tslintIntegration\": true,\n  \"cSpell.userWords\": [\n    \"Unmount\"\n  ],\n  \"jest.autoEnable\": false,\n}"
        }
      ],
      "id": "xjoUkmep",
      "createdAt": 1679457478453,
      "updatedAt": 1679457498268
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [
        "KdczzSfg",
        "3_8WBEfH",
        "0nws0COZ",
        "qfgXWMDf",
        "hvD6qjEL",
        "0DVV1_vt",
        "FIO6bwCb",
        "bMuiTH_t",
        "m0SDyNJf",
        "yETmPQp5"
      ],
      "description": "You can console.log(this.$route) to see everythingthat's in this built-in object!\n注意：this.$route 和 this.$router 是不同的",
      "name": "router 路由相关-1",
      "content": [
        {
          "label": "router-view",
          "language": "javascript",
          "value": "different router the same component vue。真实的业务场景中，这种情况很多。\n我创建和编辑的页面使用的是同一个component,默认情况下当这两个页面切换时并不会触发vue的created或者mounted钩子，\n官方说你可以通过watch $route的变化来做处理，但其实说真的还是蛮麻烦的。后来发现其实可以简单的在 router-view上加上一个唯一的key，\n来保证路由切换时都会重新渲染触发钩子了。这样简单的多了。\n\n<router-view :key=\"key\"></router-view>\n\ncomputed: {\n    key() {\n        return this.$route.name !== undefined? this.$route.name + +new Date(): this.$route + +new Date()\n    }\n }"
        },
        {
          "label": "路由高亮",
          "language": "javascript",
          "value": "Vue Router内置的链接高亮CSS类是router-link-active。当一个<router-link>被点击并且匹配到当前路由时，它会自动添加这个类。可以通过设置linkActiveClass选项来自定义这个类名。\n但是，请注意 linkActiveClass 仅适用于 <router-link>，编程式导航和命名路由不支持该选项\nconst router = createRouter({\n    history: createwebHistory(),\n    routes: [\n      {path: '/teams', component: TeamsList },\n      { path: '/users',component: UsersList },\n    ],\n    linkActiveClass:'active'  //active这个名称是自定义的你的css类,注意可能只是在<router-link>上用\n  })\n  app.use(router)\n  \n对于编程式导航和命名路由，您需要手动控制高亮。你可以设置 data 或者计算属性来记录当前活动的路由，然后在模板中根据这个属性设置 CSS 类名。例如，你可以在父组件中使用 $route.name（当前路由名称）和 $route.path（当前路由路径）来判断哪个导航项处于激活状态，并为其添加类名。\n以下是一个简单的例子：\n<!-- 使用 linkActiveClass 的 router-link -->\n<router-link to=\"/page1\" linkActiveClass=\"active\">Page1</router-link>\n<router-link to=\"/page2\" linkActiveClass=\"active\">Page2</router-link>\n\n<!-- 使用编程式导航和命名路由, 自动判断路由激活状态 -->\n<ul>\n  <li :class=\"{'active': isActiveRoute('page1')}\">\n    <a @click=\"goToRoute('page1')\">Page1</a>\n  </li>\n  <li :class=\"{'active': isActiveRoute('page2')}\">\n    <a @click=\"goToRoute('page2')\">Page2</a>\n  </li>\n</ul>\nimport { Router } from 'vue-router';\n\nexport default {\n  methods: {\n    goToRoute(routeName) {\n      this.$router.push({ name: routeName });\n    },\n    isActiveRoute(routeName) {\n      return this.$route.name === routeName;\n    },\n  },\n};\n在这个例子中，我们使用 isActiveRoute 方法来判断当前路由是否是激活状态，并根据此为其添加 active 类。同时，我们使用 goToRoute 方法实现编程式导航。\n"
        },
        {
          "label": "Vue Router的多种跳转页面的方法",
          "language": "javascript",
          "value": "Vue Router 提供了多种跳转页面的方法，以下是一些常用的方法：\n\n1. `<router-link>` 标签\n最常用的导航方式是使用 `<router-link>` 标签，这个标签会自动根据你的路由配置生成一个可导航的链接。\n\n<router-link to=\"/about\">关于我们</router-link>\n\n2. 编程式导航\n除了使用 `<router-link>` 标签之外，还可以通过编程式的方式实现页面跳转。Vue Router 提供了以下方法：\n- `this.$router.push(location)`: 类似于 `<router-link>`，导航到指定的 `location`。\n`location` 可以是一个字符串或者一个描述目标位置的对象。当导航成功时，浏览器的 URL 会变为对应的记录。\n\n  this.$router.push('/about');\n  // 或者\n  this.$router.push({ path: '/about' });\n  // 带有查询参数\n  this.$router.push({ path: '/about', query: { id: 1 } });\n- `this.$router.replace(location)`: 类似于 `push`，但是不会向历史记录添加新记录，而是替换掉当前的记录。\n  this.$router.replace('/about');\n  // 或者\n  this.$router.replace({ path: '/about' });\n- `this.$router.go(n)`: 可以前进或返回（通过传递一个负值）指定的步数。它调用的是浏览器的 `history.go(n)` 方法。例如：\n  this.$router.go(-1); // 后退\n  this.$router.go(1); // 前进\n\n3. 命名路由\n在配置路由时，可以给路由添加 `name` 属性，这样可以通过名称来进行页面跳转。(使用命名路由的好处是path改变的话，不用去其他地方修改命名路的name，因为这个不是经常变换的)\n\nconst routes = [\n  { path: '/about', component: About, name: 'about' },\n  { path: '/user/:id', component: User, name: 'user' },\n];\n\n//使用命名路由进行跳转：\nthis.$router.push({ name: 'about' });\n// 或者带有参数\nthis.$router.push({ name: 'user', params: { id: 1 } });\nthis.$router.push({ name: 'user', params: { teamId: this.id } });\n\n这些方法可以帮助你在 Vue 应用中实现灵活的页面跳转。"
        },
        {
          "label": "不同数据对象查询显示数据",
          "language": "javascript",
          "value": "/*通过一个数组对象teams的数据如id,找出另一个数组里users的数据对象内容数据\n注意以下各个部分并不在一个vue文件里 */\n//------------------------------------- 动态路由：\nroutes:[\n  //浏览器输入/teams/t1 或 /teams/t2 会加载不同的数据\n  //配置props:true可以将动态值teamId传递给组件TeamMembers\n  //alias 相当于 redirect重定向,但 redirect时url是变化的，而alias不会变化url\n  //注意component可以是复数多个components:{default:TeamMembers,footer:teamsFooter} ,注意实现的是不同页面加载不同的footer\n\t{\n     path: '/teams/:teamId',\n     meta:{needsAuth:true}, //meta里可以自定义属性，然后在守卫里可以通过 to.meta.你自定义的属性;做判断依据\n     component: TeamMembers,\n     footer:Footer, alias:'/',\n     props:true\n     //或\n     //props: (route) => ({ id: route.params.id })\n  },\n  {path:'/:notFound(.*)', component: NotFound } //将匹配任何其他不是路径的字符\n  \n]\n//-------------------------------------数据部分\ndata() {\n  return {\n    teams:[\n      { id: 't1', name:'Frontend Engineers', members: ['ul' ,'2'] },\n      { id: 't2', name:'Backend Engineers',  members: ['u1' ,'u2','u3']}, \n      { id: 't3', name: 'Client Consulting', members: ['u4','u5'] },\n    users: [\n      { id: 'ul', fulIName: 'Max Schwarz', role: 'Engineer' },\n      { id: 'u2', fulIName:'Praveen Kumar', role: 'Engineer' },\n      { id: 'u3', fulName: 'Julie Jones', role: 'Engineer' },\n      { id: 'u4', fuliName: 'Alex Blackfield', role: 'Consultant' },\n      { id: 'u5', fulName: 'Marie Smith', role: 'Consultant' },\n      ]\n  }\n}\n//--------------------------------页面数据展示\n<template>\n  <section>\n    <h2>{{ teamName }}</h2>\n    <ul>\n      <user-item\n        v-for=''member in members\"\n        :key=\"member.id\"\n        :id=\"team.id\"\n        :name='member.fulIName'\n        :role='member.role'\n      ></user-item>\n    </ul>\n  </section>\n</template>\n\n<script>\n import ...\n export default{\n   inject:['users', 'teams'],\n   props:['teamId'],  //这里是重点，这个teamId值是通过在路由设置一个 props:true 使得这个动态值可以传递过来\n   data(){\n     teamName:'',\n     members:[]\n   },\n   methods:{\n     loadTeamMembers(teamId) {\n       // this.$route.path  // /teams/t1\n      //const teamId = this.$route.params.teamId; //从url获取Id值\n      //find()方法找到符合条件的元素后，会立即停止遍历并返回该元素\n      //find()方法遍历数组teams,对每个元素执行回调函数 `team => team.id === teamId`\n      const selectedTeam = this.teams.find(team => team.id === teamId);\n      const members = selectedTeam.members;// members 是一个数组\n      const selectedMembers = [];\n      for (const member of members) {\n        //find()方法只找一个符合条件的数据\n        const selectedUser = this.users.find(user => user.id === member);\n        selectedMembers.push(selectedUser);\n      }\n      this.members = selectedMembers;\n      this.teamName = selectedTeam.name;\n     }\n   },\n   created(){ \n      this.loadTeamMembers(this.teamId) //teamId是props传过来的，加this因为和用data()里的数据一样用法\n   },\n   //通过beforeRouteUpdate()这种路由的方式也可以实现下面watch()的作用，但watch()的好一点，因为不依赖路由\n   beforeRouteUpdate(to,from,next){\n      console.log('TeamMembers Cmp beforeRouteUpdate');\n      console.log(to, from);\n      this.loadTeamMembers(to.params.teamId);\n      next();\n   },\n   watch(){\n     //这里的作用是避免组件不更新,很简单就是对teamId进行watch\n     teamId(newId){\n       this.loadTeamMembers(newId)      \n     }\n   }\n }\n\n</script>\n"
        },
        {
          "label": "Vue Router提供的props的属性",
          "language": "javascript",
          "value": "Vue Router提供了一个名为`props`的属性，允许将路由参数作为组件的props传递。这意味着我们可以在路由定义中声明一个props对象，其中包含我们想要传递给组件的属性。\n在使用`props`时，我们需要在路由定义中使用`props: true`来启用props传递。这将告诉Vue Router将路由参数作为props传递给组件。\n例如，我们可以定义一个路由如下：\n{\n  path: '/user/:id',\n  component: User,//props将通过这个 User组件传递，而不再是通过router传递\n  props: true\n}\n\n这将告诉Vue Router将路由参数中的`id`值作为`User`组件的一个props传递。在组件中，我们可以通过声明一个名为`props`的属性来接收这些props。例如：\nexport default {\n  props: ['id'],\n  // ...\n}\n\n这样，我们就可以在组件中使用`this.id`来访问路由参数中的`id`值。\n除了使用`props: true`，我们还可以使用一个函数来动态地为每个路由设置props。例如：\n\n{\n  path: '/user/:id',\n  component: User,\n  props: (route) => ({ id: route.params.id })\n}\n这将告诉Vue Router将路由参数中的`id`值作为`User`组件的一个props传递，并将其命名为`id`。\n相比之下，使用函数动态地设置props可以更加灵活。我们可以根据需要选择传递哪些props，甚至可以在函数中进行一些计算和转换，以便更好地适应我们的业务需求。此外，使用函数设置props还可以将非路由参数的props传递给组件。"
        },
        {
          "label": "动态footer",
          "language": "javascript",
          "value": "一个路由定义多个组件，根据name选择加载的组件\n<footer>\n\t<router-view name=\"footer\"></router-view>\n</footer>\n\n\nroutes:[\n  {path:'/redirect: '/teams' },\n  {\n    name: 'teams',\n    path:'/teams',\n    //注意一般单个组件不是复数：component:,\n    components: { default: TeamsList, footer: TeamsFooter },\n  ...\n  }\n]"
        },
        {
          "label": "路由对滚动位置控制",
          "language": "javascript",
          "value": "//可以做到的效果：跳转页面后返回，还在之前的位置；点击后跳转到指定位置，如top\n//三个参数是重点，可以打印出来看看\nscrollBehavior(to, from, savedPosition) {\n  console.log(to, from, savedPosition);\n  if (savedPosition) {\n  //如果有之前位置的信息(不是null)，回到之前位置\n  \treturn savedPosition;\n  }\n  //跳到相关位置\n   return {left: 0, top: 0 };\n }\n \n //另一个实例\n const router = new Router({\n  mode: 'history',\n  base: process.env.BASE_URL,\n  scrollBehavior: () => ({ y: 0 }), //这里省略了return\n  routes: constantRouterMap\n})"
        },
        {
          "label": "路由守卫",
          "language": "javascript",
          "value": " beforeEach(); beforeRouteEnter();  beforeRouteUpdate(); beforeRouteLeave() ....\n\nrouter.beforeEach(function(to,from,next){}); //beforeEach的参数是一个函数,这个函数里有三个参数\n//next()里面可以灵活传参\nnext({ name: 'team-members', params: { teamId: 't2' } });\n \n 注意以下三种守卫的执行有顺序：全局>路由局部>组件里\n//-----------------------------------------引跑158项目实例\n//beforeEach() 钩子函数会在每次路由跳转前被调用\nrouter.beforeEach((to, from, next) => {\n  let url = window.location.href\n  let urls = url.split(':')\n  //这里的 urls[0] + ':' + urls[1] 代码是为了获取当前访问站点的协议和主机地址，组成一个字符串\n  let realurl = urls[0] + ':' + urls[1]\n\n  if (to.meta.title === '接口管理' && to.meta.needsAuth) { //needsAuth是meta里自定义的属性\n    let api_url = realurl + ':9230/account/login'\n    window.open(api_url, '_blank')\n    next(false) //留在当前页\n    router.push(from.path)\n  } else {\n    next()\n  }\n})\n//-------------------------上面的守卫会在所有路由触发,也可以像下面定义，特定单个路由的守卫\n{\n  path:'/user',\n  components: {default: UsersList, footer: UsersFooter},\n  //这里 beforeEnter只针对当前路由\n  beforeEnter(to, from, next) {\n    console.log('users beforeEnter');\n    console.log(to,from);\n  \tnext();\n  }\n},\n//------------------------------将守卫定义在组件里\nexport default{\n  data(){\n    return{\n    }\n  },\n  beforeRouteEnter(to, from，next) {\n    console.log('UsersList Cmp beforeRouteEnter');\n    console.log(to, from);\n    next();\n  },\n  beforeRouteLeave(to, from, next){\n    console.log('UsersList Cmp beforeRouteLeave');\n    console.log(to, from);\n    if (this.changesSaved) {\n      next();\n    } else {\n   \t\tconst userWantsToLeave = confirm('Are you sure? You got unsaved changes!');\n      next(userWantsToLeave);\n\t} \n}\n"
        }
      ],
      "id": "GQiXghAh",
      "createdAt": 1679467460483,
      "updatedAt": 1690034028272
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "tocBVsRT"
      ],
      "description": " 重点理解${person[key]，很基础很常用，另外注意模板字符串里是可以用表达式的\n using bracket notation to access the value of each key in the object.",
      "name": "Object.keys",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "const person = {\n  name: 'John',\n  age: 30,\n  city: 'New York'\n};\n\nObject.keys(person).forEach(function(key,index) { //forEach第二个参数是索引，数组方法的许多参数都是同样的思路，很简单！\n  console.log(` ${index +1} ${key}: ${person[key]}`);\n});\n// 1 name: John\n// 2 age: 30\n// 3 city: New York\n\nconsole.log(Object.keys(person))\n//['name', 'age', 'city'] 这个没有啥复杂的很直白，获取对象person的keys，返回的是数组\nconsole.log(...Object.keys(person))\n// name age city  解构后就获取字符串了，很简单！\n\n"
        }
      ],
      "id": "2_p6_pgI",
      "createdAt": 1679472627150,
      "updatedAt": 1679474170259
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [
        "3SlmB-P_",
        "_QsE2qvC"
      ],
      "description": null,
      "name": "返回首页按钮",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "<el-button type=\"text\" icon=\"el-icon-back\" @click=\"goIndex\">返回首页</el-button>\n   \ngoIndex() {this.$router.push('/index'),"
        }
      ],
      "id": "oXiEwFY6",
      "createdAt": 1679712751310,
      "updatedAt": 1679712825854
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "ejtoZnYa",
      "tagsIds": [
        "ppd2KRtj"
      ],
      "description": "第一个fragment是electron的主程序文件index.js，第二个fragment是package.json文件，第三个是index.html文件，程序主要是在主程序和子程序之间的交互\nhttps://github.com/zunyang/stephen-grider_electron-for-desktop-apps",
      "name": "获取文件信息实例 videoinfo",
      "content": [
        {
          "label": "index.js",
          "language": "javascript",
          "value": "const electron = require('electron');\nconst ffmpeg = require('fluent-ffmpeg');\n\nconst { app, BrowserWindow, ipcMain } = electron;\n\nlet mainWindow;\n\napp.on('ready', () => {\n  mainWindow = new BrowserWindow({});\n  mainWindow.loadURL(`file://${__dirname}/index.html`);\n});\n\nipcMain.on('video:submit', (event, path) => {\n  ffmpeg.ffprobe(path, (err, metadata) => {\n    mainWindow.webContents.send(\n      'video:metadata',\n      metadata.format.duration\n    );\n  });\n});"
        },
        {
          "label": "package.json",
          "language": "javascript",
          "value": "{\n  \"name\": \"videoinfo\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"electron\": \"electron .\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"electron\": \"^1.6.6\",\n    \"fluent-ffmpeg\": \"^2.1.2\"\n  }\n}"
        },
        {
          "label": "index.html",
          "language": "javascript",
          "value": "<head>\n</head>\n<body>\n  <h1>Video Info</h1>\n  <form>\n    <div>\n      <label>Select a video</label>\n      <input type=\"file\" accept=\"video/*\" />\n    </div>\n    <button type=\"submit\">Get Info</button>\n  </form>\n\n  <h1 id=\"result\"></h1>\n\n  <script>\n    const electron = require('electron');\n    const { ipcRenderer } = electron;\n\n    document.querySelector('form').addEventListener('submit', (event) => {\n      event.preventDefault();\n      const { path } = document.querySelector('input').files[0];\n\n      ipcRenderer.send('video:submit', path);\n    });\n\n    ipcRenderer.on('video:metadata', (event, duration) => {\n      document.querySelector('#result').innerHTML = `Video is ${duration} seconds`;\n    });\n  </script>\n</body>"
        }
      ],
      "id": "A1xiclUu",
      "createdAt": 1679982797906,
      "updatedAt": 1682243278496
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "ejtoZnYa",
      "tagsIds": [
        "WSSamMkz"
      ],
      "description": null,
      "name": "true or false",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "process.env.NODE_ENV = 'development'\nconst isDev = process.env.NODE_ENV !== 'production' ? true : false\nconst isMac = process.platform ==='darwin' ? true : false\n\nlet mainWindow\n\nfunction createMainWindow() {\n   mainWindow = new BrowserWindow({\n   title: 'ImageShrink',\n   width: 500,\n   height: 600,\n   icon: './assets/icons/Icon _256x256.png',\n   //注意这里的的应用\n   resizable: isDev ? true : false,\n })\n//loadURL也可用\nmainWindow.loadFile('./app/index.html')\n}\n//事件驱动\napp.on('ready',()=>{\n   createMainWindow()\n   //垃圾回收\n   mainWindow.on('ready',()=>{ mainWindow = null)\n})\n\napp.on('window-all-closed', () => {\n   if (!isMac) {\n       app.quit()\n   }\n})\n\napp.allowRendererProcessReuse = true"
        }
      ],
      "id": "WF1UTwZS",
      "createdAt": 1680259534545,
      "updatedAt": 1680261726543
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [],
      "description": null,
      "name": "在特定项目中禁用 VSCode 的代码格式化",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "\n在 VSCode 中打开该项目。\n在“资源管理器”面板中，单击右键选择“新建文件”创建一个名为“.vscode”的文件夹。\n在“.vscode”文件夹中创建一个名为“settings.json”的文件。\n在“settings.json”文件中添加以下内容：\n\n{\n  \"eslint.format.enable\": false,\n  \"editor.formatOnSave\": false\n}\n\n保存并关闭“settings.json”文件。\n\n现在，VSCode 不会在保存文件时格式化您的代码。请注意，这将只影响当前项目。如果您要在其他项目中启用格式化，请在那些项目的“settings.json”文件中将“editor.formatOnSave”设置为 true。\n"
        }
      ],
      "id": "3eEEIYb3",
      "createdAt": 1680398998715,
      "updatedAt": 1680399086439
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "MsM_-3a9",
        "oahZqjuX",
        "sDMjHD6T",
        "A4xczVrR"
      ],
      "description": "事件监听是非常重要的概念，很多应用就是基于事件监听建立的，比如electron，不过这些应用的事件监听包装成了关键字.on如，app.on(...)",
      "name": "addEventListener",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "目标：了解各种事件监听在什么情况下使用\n在JavaScript中，我们可以使用事件监听器来监听DOM元素或者Node.js中的事件。以下是一些常见的事件监听器,但还有很多其他的事件监听器，你可以根据需要自行查找。同时，需要注意的是，不同的浏览器可能有不同的实现，需要进行兼容性处理。\n结构：第二个参数是被addEventListener调用的函数，第一个很简单就是事件名称而已！\n注意：事件处理的回调函数this是element，比如\nform.addEventListener('submit',this._newWorkout)//这里的this不会指向form之外的对象，而是form,所以需要下面这样处理\nform.addEventListener('submit',this._newWorkout.bind(this))//在一个class或对象里的都要这样处理，bind()还是会返回函数\n\n1. click：当用户点击某个元素时触发，如鼠标点击或触摸屏幕上的某个元素。\n2. mouseover：当鼠标移动到某个元素上时触发。\n3. mouseout：当鼠标移出某个元素时触发。\n4. keydown：当用户按下键盘上的某个键时触发。\n5. keyup：当用户释放键盘上的某个键时触发。\n6. submit：当用户提交表单时触发。\n7. load：当页面或图片加载完成时触发。\n8. unload：当页面卸载时触发。\n9. resize：当窗口大小发生改变时触发。\n10. scroll：当用户滚动页面时触发。\n11. focus：当元素获得焦点时触发。\n12. blur：当元素失去焦点时触发。\n13. change：当元素的值发生改变时触发，适用于表单元素（如input、select等）。\n14. input：当元素的值发生改变时触发，适用于文本输入框（input[type=\"text\"]、textarea等）。\n15. clickoutside：当用户点击页面中除了指定元素以外的任何区域时触发。\n16. contextmenu：当用户右击页面时触发。\n17. dblclick：当用户双击某个元素时触发。\n18. touchstart：当用户触摸屏幕时触发。\n19. touchmove：当用户在屏幕上滑动时触发。\n20. touchend：当用户结束触摸时触发。\n21. animationstart：当CSS动画开始播放时触发。\n22. animationiteration：当CSS动画重复播放时触发。\n23. animationend：当CSS动画结束播放时触发。\n24. transitionstart：当CSS过渡开始时触发。\n25. transitionend：当CSS过渡结束时触发。\n26. transitioncancel：当CSS过渡被取消时触发。\n27. dragstart：当用户开始拖动一个元素时触发。\n28. drag：当用户正在拖动一个元素时触发。\n29. dragend：当用户停止拖动一个元素时触发。\n30. dragenter：当拖动元素进入某个区域时触发。\n31. dragover：当拖动元素在某个区域内移动时触发。\n32. dragleave：当拖动元素离开某个区域时触发。\n33. drop：当拖动元素被放置在某个区域时触发。\n\n//change事件,以下是jonas的mapty地图应用的change监听,注意closest()和classList.toggle()的使用\ninputType.addEventListener('change'，function (){\n   inputElevation.closest('.form__row').classList.toggle('form__row--hidden')\n   inputCadence.closest('.form _row').classList.toggle('formrow--hidden')\n})\n// 从下拉选择不同的影片，页面同时显示不同的价格\nmovieSelect.addEventListener('change', e =>{ //注意箭头函数的简洁写法\n\tticketPrice = +e.target.value; //这里的类型转换 + 是个重点\n  updateSelectedCount();\n});\n\n//submit事件, e.preventDefault()可以避免默认的一个页面刷新\nform.addEventListener('submit', function (e) {\n   e.preventDefault();\n   // Display marker\n   console.log(mapEvent);\n   const { lat, lng }= mapEvent.lating;\n   L.marker([lat, Ingl addTo(map\n})\n\n//Example: Asynchronous image loading with event and callback\n//all this code is non-blocking\nimg.src = 'dog.jpg';\nimg.addEventListener('load'，function(){\n   img.classList.add('fadeIn');\n})\np.style.width = '300px'"
        }
      ],
      "id": "mdSzKMII",
      "createdAt": 1680487739529,
      "updatedAt": 1688093512896
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "fHYC1zqy",
        "vqdOKcoe",
        "wvdogT73"
      ],
      "description": null,
      "name": "unique id ",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "date = new Date();\nid = (Date.now() + '' ).slice(-10);//根据时间的这个id实用性很有限\n\n\n//唯一值的id应用在下面的类里\nclass Workout {\n  date = new Date();\n  id = (Date.now() + '').sice(-10);\n  \n  constructor(coords, distance, duration) {\n    // this.date = ... 规范后的ES应该是这样的\n    // this.id =.\n    this.coords = coords\n    this.distance = distance; // in km\n    this.duration = duration; // in min\n    }\n}\n\n//临时不完美的用法\nid: new Date().toIsoString()\n\n// 其他不完美写法 Generate random ID\nfunction generateID() {\n\treturn Math.floor(Math.random() * 100000000);\n}\n//使用：\nid:generateID()"
        },
        {
          "label": "随机数+时间戳+转字符串的唯一值",
          "language": "javascript",
          "value": "// 获取唯一值，这个是目前最实用的唯一值\nconst createRandom = () => {\n    let ran = Math.random() * new Date();\n    return ran.toString(16).replace('.', '');//toString(16)表示是16位\n};\n\n//使用\n key: createRandom() //createRandom()函数每次执行都产生一个唯一值"
        }
      ],
      "id": "C75l_SnB",
      "createdAt": 1680577679066,
      "updatedAt": 1692178072081
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "numkSBqD",
        "cJzn_M8B",
        "3r63DuXm",
        "BqxVekgI"
      ],
      "description": null,
      "name": "判断是否为数字",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "//1)定义两个函数; 参数(...inputs)这样写会返回数组。it takesin an arbitrary amount of inputs\n//是否为数组\nconst validInputs = (...inputs) => \n  inputs.every(inp => Number.isFinite(inp));\n//是否为正数 \nconst allPositive = (...inputs) => \n  inputs.every(inp => inp > 0);\n  \n//2)使用函数validInputs，注意在if()参数里使用函数的用法！\nif(!validInput(distance,duration,cadence)) || !allPositive(distance,duration,cadence))\n   return alert('Input have to be positive value')\n  \n\n//every()的概念：\n//理解了some()就等于理解了every(),指的是符合所有条件，如：\n//所以元素小于0才可以返回ture,否则false\nmovements.every(mov⇒mov<0)"
        }
      ],
      "id": "soG0geYv",
      "createdAt": 1680659682315,
      "updatedAt": 1680661645282
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "GxtphJep",
        "o0h0GUTt",
        "p-I-pDGx"
      ],
      "description": null,
      "name": "取消格式化",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "用注释如prettier-ignore可以取消全局格式化下对某一行的作用\n/*前面的_表示私有，在 JavaScript 中，通常使用下划线作为变量名前缀来表示该变量是私有的，也就是说它不应该被直接访问或修改。这种命名约定是一种代码风格，并不是 JavaScript 语言的强制规定。在实际开发中，程序员可以根据自己的需要和代码规范来决定是否使用下划线作为变量名前缀。\n请注意，虽然在 JavaScript 中使用下划线前缀可以向其他开发人员表明变量的私有性，但它并不会使该变量真正变为私有。在 JavaScript 中，所有变量都可以被访问和修改，因此开发人员必须自行采取措施来确保变量的安全性。*/\n\n_setDescription() {\n    //prettier-ignore\n    const months = ['January','FebruaryMarch', 'April','May','June','July','AugustSeptember','October','NovemberDecember'];\n}"
        }
      ],
      "id": "4OJbr2qi",
      "createdAt": 1680701896961,
      "updatedAt": 1680703910864
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "在js里 _ 和 # 标识符的区别",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "下划线（_）通常被用作变量名的前缀或者占位符，表示该变量是一个私有变量或者临时变量，不希望被外部访问或者修改。这种约定是一种编码风格，并不是 JavaScript 语言本身的要求。在 ECMAScript 5 之前，JavaScript 并没有对私有变量提供直接的支持，因此开发者们采用这种命名约定来模拟实现私有变量的功能。\n\n例如，以下代码中的变量 _privateVar 和 _privateMethod 都是私有变量和方法，不希望被外部访问：\n\nfunction MyClass() {\n  var _privateVar = 0;\n\n  function _privateMethod() {\n    console.log(\"Private method called\");\n  }\n\n  this.publicMethod = function() {\n    _privateVar++;\n    _privateMethod();\n    console.log(\"Public method called, private var is now: \" + _privateVar);\n  };\n}\n\nvar myObj = new MyClass();\nmyObj.publicMethod(); // 输出 \"Private method called\" 和 \"Public method called, private var is now: 1\"\n\n井号（#）是 ES2015（也称为 ES6）中引入的一种新的语法，用于表示类的私有字段。私有字段是指只能在类的内部使用的字段，无法被外部访问或者修改。在类中定义私有字段时，可以使用井号作为前缀，例如：\n\nclass MyClass {\n  #privateField = 0;\n\n  #privateMethod() {\n    console.log(\"Private method called\");\n  }\n\n  publicMethod() {\n    this.#privateField++;\n    this.#privateMethod();\n    console.log(\"Public method called, private field is now: \" + this.#privateField);\n  }\n}\n\nconst myObj = new MyClass();\nmyObj.publicMethod(); // 输出 \"Private method called\" 和 \"Public method called, private field is now: 1\"\n\n在这个示例中，#privateField 和 #privateMethod 都是私有的，只能在类的内部使用，无法从外部访问。通过在类中使用井号定义私有字段和方法，我们可以避免意外修改或访问这些字段和方法，从而提高代码的可维护性和安全性。\n"
        }
      ],
      "id": "GynzDzWJ",
      "createdAt": 1680750659330,
      "updatedAt": 1680750845602
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "YItK6iVG",
        "6dorcrmo",
        "YCMjJLAa"
      ],
      "description": null,
      "name": "同步和异步",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "Asynchronous code is executed after a task that runs in the “background\" finishes;\nAsynchronous code is non-blocking;\nExecution doesn't wait for an asynchronous task to finish its work;\nCallback functions alone do NOT make code asynchronous! 比如：[1，2，3].map(v = v *2) 这里的回调函数并不是异步的\n\nconst p = document.querySelector('.p')\nsetTimeout(function(){ //asynchronous\n   p.textContent = 'My name is Jonas'\n}, 5000);\np.style.color = 'red' \n\n//Example: Asynchronous image loading with event and callback\n//all this code is non-blocking\nconst img = document.querySelector('.dog')\nimg.src = 'dog.jpg';\n//addEventListener does NOT automatically make code asynchronous!,只是在load执行后再执行，这个和click监听一个道理\nimg.addEventListener('load'，function(){\n   img.classList.add('fadeIn');\n})\np.style.width = '300px'\n\nAJAX:Asynchronous JavaScript And XML: \nAllows us to communicate with remote web servers in an asynchronous way. With AJAX calls, we can request data from web servers dynamically.\nall happens asynchronously in the background\n"
        }
      ],
      "id": "aM0803E1",
      "createdAt": 1680752269863,
      "updatedAt": 1680774220422
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "kYeA3Yuv",
      "tagsIds": [],
      "description": null,
      "name": "el-dialog 作为组件",
      "content": [
        {
          "label": "Fragment 1",
          "language": "plain_text",
          "value": "子组件"
        }
      ],
      "id": "ZftzQyEl",
      "createdAt": 1680870152091,
      "updatedAt": 1680870254486
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "kYeA3Yuv",
      "tagsIds": [
        "QbBV4zvx",
        "jFhcfcBn"
      ],
      "description": null,
      "name": "el-dialog 作为组件",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "//子组件：\n<template>\n    <el-dialog title=\"下载智信客户端\" :visible.sync=\"dialogVisible\" width=\"30%\" :before-close=\"handleClose\">\n            ...\n    </el-dialog>\n</template>\n\n<script>\nexport default {\n    props: {\n        dialogVisible: {\n            type: Boolean,\n            default: false\n        }\n    },\n    methods: {\n        handleClose() {\n            // 触发update:dialogVisible事件，将dialogVisible属性设置为false\n            this.$emit('update:dialogVisible', false);\n        }\n    }\n}\n</script>\n\n//父组件:\n<a @click=\"dialogVisible = true\">智信客户端</a>\n<imDownload :dialog-visible=\"dialogVisible\" @update:dialogVisible=\"dialogVisible = $event\"></imDownload>\n\n<script> \n  import imDownload from './imDownload.vue';\n  export default { \n    components: { imDownload }, \n    data() { \n       return { dialogVisible: false } } \n    } \n</script>\n\n\n\n"
        }
      ],
      "id": "iRKaMtj_",
      "createdAt": 1680870283472,
      "updatedAt": 1680870955233
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "ZaUf5iYC",
        "AHLUsvel",
        "uyS3jGYa",
        "UOlf7phy"
      ],
      "description": "geocode.xyz 这里有地图相关API可以用",
      "name": "fetch map",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "const whereAmI = function (lat,lng) {\n    fetch(`https://geocode.xyz/${lat},${lng}?geoit=json`)\n      .then(res => res.json())\n      .then(data => {\n      console.log(data);\n     });\n}\nwhereAmI(12.508,13.381); //这里可以打印出一个地图信息相关的对象"
        }
      ],
      "id": "NDr5giL8",
      "createdAt": 1681033671697,
      "updatedAt": 1690771603614
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "Untitled snippet",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "div::-webkit-scrollbar {\n    width: 10px;\n    height: 10px;\n    background: #fdfdfd;\n    padding-right: 2px;\n}\n\ndiv::-webkit-scrollbar-thumb {\n    background: #70959f;\n    border-radius: 10px;\n}"
        }
      ],
      "id": "9r_A9oNo",
      "createdAt": 1681269972458,
      "updatedAt": 1681356146703
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3BVGYMMN",
      "tagsIds": [],
      "description": null,
      "name": "自定义滚动条",
      "content": [
        {
          "label": "Fragment 1",
          "language": "css",
          "value": "普通：\n/*设置宽度,轨道颜色*/\ndiv::-webkit-scrollbar {\n    width: 10px;\n    height: 10px;\n    background: #fdfdfd;\n    padding-right: 2px;\n}\n/*滚动条*/\ndiv::-webkit-scrollbar-thumb {\n    background: #70959f;\n    border-radius: 10px;\n}\n\n\n理发店招牌底纹效果：引跑218项目用过\n/*设置宽度,轨道颜色*/\ndiv::-webkit-scrollbar {\n    width: 10px;\n    height: 10px;\n    background: #0e0c0c;\n    padding-right: 2px;\n}\n\n/*滚动条*/\ndiv::-webkit-scrollbar-thumb {\n    background: #0b6b89;\n  /*理发店招牌底纹效果*/\n    background-image: -webkit-linear-gradient(45deg, hsla(0, 0%, 100%, .2) 10%, transparent 0, transparent 20%, hsla(0, 0%, 100%, .2) 0, hsla(0, 0%, 100%, .2) 30%, transparent 0, transparent 40%, hsla(0, 0%, 100%, .2) 0, hsla(0, 0%, 100%, .2) 50%, transparent 0, transparent 60%, hsla(0, 0%, 100%, .2) 0, hsla(0, 0%, 100%, .2) 70%, transparent 0, transparent 80%, hsla(0, 0%, 100%, .2) 0, hsla(0, 0%, 100%, .2) 90%, transparent 0, transparent 100%);\n    border-radius: 10px;\n}\n\n\n/*+++++++++++++++++++++++++++++++++自定义野火im 滚动条 */\n/* 滚动条样式 */\n::-webkit-scrollbar {\n  width: 8px;\n  height: 8px;\n}\n\n/* 滚动条轨道样式 */\n::-webkit-scrollbar-track {\n  background-color: #f5f5f5;\n}\n\n/* 滚动条-thumb（滑块）样式 */\n::-webkit-scrollbar-thumb {\n  background-color: #c1c1c1;\n  border-radius: 999px;\n}"
        }
      ],
      "id": "gIL5zXlW",
      "createdAt": 1681269992432,
      "updatedAt": 1698977740904
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "CIqaS_Yh",
      "tagsIds": [
        "ScC0ASaK"
      ],
      "description": "在示例中，我们首先定义了一个 commonSubTextStyle 变量，用于设置公共的 subtextStyle 样式。然后，在每个 option 中都分别设置了特定的 subtext 和样式，并通过 subtextStyle 属性统一使用了公共的样式。最后，通过调用 setOption 方法分别渲染了两个图表。",
      "name": "给多个option设置subtext的样式",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "//可以通过在 subtextStyle 中设置公共的样式，然后在每个 option 中分别设置其特定的 subtext\n\n// 设置公共的 subtext 样式\nvar commonSubTextStyle = {\n  color: '#999',\n  fontFamily: 'Arial',\n  fontWeight: 'bold',\n  fontSize: 12\n};\n\n// option1\nvar option1 = {\n  title: {\n    text: 'Option1'\n  },\n  series: [{\n    name: 'Series1',\n    type: 'pie',\n    data: [...],\n    // 设置特定的 subtext 和样式\n    label: {\n      show: true,\n      formatter: 'Total: {c}',\n      position: 'center',\n      color: '#333',\n      fontFamily: 'Verdana',\n      fontWeight: 'normal',\n      fontSize: 16\n    },\n    emphasis: {\n      label: {\n        show: true,\n        formatter: '{d}%'\n      }\n    }\n  }],\n  // 统一使用公共的 subtext 样式\n  subtext: 'This is option1 subtext',\n  subtextStyle: commonSubTextStyle\n};\n\n// option2\nvar option2 = {\n  title: {\n    text: 'Option2'\n  },\n  series: [{\n    name: 'Series1',\n    type: 'bar',\n    data: [...],\n    // 设置特定的 subtext 和样式\n    label: {\n      show: false\n    }\n  }],\n  // 统一使用公共的 subtext 样式\n  subtext: 'This is option2 subtext',\n  subtextStyle: commonSubTextStyle\n};\n\n// 初始化 echarts 实例并渲染图表\nvar myChart = echarts.init(document.getElementById('myChart'));\n\nmyChart.setOption(option1);\nmyChart.setOption(option2);"
        }
      ],
      "id": "_oXk4vxs",
      "createdAt": 1681288632500,
      "updatedAt": 1681288694069
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "AH4o3Lye",
        "63ZIwxSn",
        "ExGKPu6S",
        "3bRgTsPX",
        "cH71p1QA",
        "DxKZ2j1c",
        "lJch_6Ci",
        "h6VovRUY",
        "oXNsTNra",
        "tocBVsRT"
      ],
      "description": "async函数是一个返回Promise对象的函数。而await操作符会暂停当前函数的执行，等待Promise对象的状态变为resolved后，将Promise对象的解析值作为await表达式的返回值。如果Promise对象的状态变为rejected，await操作符会抛出一个异常。\n可以使用await关键字来等待一个Promise对象的解析结果，然后将其作为返回值。在async函数中，可以使用try/catch语句来捕获Promise对象的reject。\nasync/await的优点在于，它让异步代码更容易理解和维护。它通过将异步操作转换为类似于同步操作的代码，使得代码更具可读性和可维护性。",
      "name": "Promise",
      "content": [
        {
          "label": "Building a Simple Promise",
          "language": "javascript",
          "value": "// Building a Simple Promise\nconst lotteryPromise = new Promise(function (resolve, reject) {\n  console.log('Lotter draw is happening 🔮');\n  setTimeout(function () {\n    if (Math.random() >= 0.5) {\n      resolve('You WIN 💰');\n    } else {\n    //注意new Error()即可创建一个错误实例很简单！new Error比直接输入的提示文本有更详细的信息，比如是哪里出错\n      reject(new Error('You lost your money 💩'));\n    }\n  }, 2000);\n});\n\n//consume promise\nlotteryPromise.then(res => console.log(res)).catch(err => console.error(err));\n\n// ++++++++++++++++++++++++++++++++++++ Promisifying setTimeout 一个排队函数\nconst wait = function (seconds) {\n  return new Promise(function (resolve) {\n    setTimeout(resolve, seconds * 1000); //因为是毫秒所以要乘以1000\n  });\n};\n\nwait(1)\n  .then(() => {\n    console.log('1 second passed');\n    return wait(1);\n  })\n  .then(() => {\n    console.log('2 second passed');\n    return wait(1);\n  })\n  .then(() => {\n    console.log('3 second passed');\n    return wait(1);\n  })\n  .then(() => console.log('4 second passed'));\n\n//上面的Promisifying setTimeout优化了下面的回调地狱问题\n// setTimeout(() => {\n//   console.log('1 second passed');\n//   setTimeout(() => {\n//     console.log('2 seconds passed');\n//     setTimeout(() => {\n//       console.log('3 second passed');\n//       setTimeout(() => {\n//         console.log('4 second passed');\n//       }, 1000);\n//     }, 1000);\n//   }, 1000);\n// }, 1000);\n//++++++++++++++++++++++++++++++++++++++++++++++++下面是一个简单的例子，展示了如何使用async/await来处理异步代码：\nasync function getUser(id) {\n  try {\n    const response = await fetch(`https://jsonplaceholder.typicode.com/users/${id}`);\n    const user = await response.json();\n    console.log(user.name);\n  } catch (err) {\n    console.log(err);\n  }\n}\n\ngetUser(1); // 输出 \"Leanne Graham\"\n\n在这个例子中，我们定义了一个async函数getUser，它接受一个id参数。我们使用await关键字来等待fetch函数返回的Promise对象，然后使用await关键字来等待response.json()方法返回的Promise对象，并将其解析为user对象。如果任何一个Promise对象被rejected，我们就会通过try/catch语句来捕获异常。\n"
        },
        {
          "label": "Promisifying the Geolocation API",
          "language": "javascript",
          "value": "// Promisifying the Geolocation API\nconst getPosition = function () {\n  return new Promise(function (resolve, reject) {\n    // navigator.geolocation.getCurrentPosition(\n    //   position => resolve(position),\n    //   err => reject(err)\n    // );\n    //下面这一行相当于上面的几行\n    navigator.geolocation.getCurrentPosition(resolve, reject);\n  });\n};\n// getPosition().then(pos => console.log(pos));  这里可以打印出下面代码需要的对象属性信息信息。如里面有latitude、 longitude\n\nconst whereAmI = function () {\n  getPosition()\n    .then(pos => {\n      //解构之后更改名称\n      const { latitude: lat, longitude: lng } = pos.coords;\n\n      return fetch(`https://geocode.xyz/${lat},${lng}?geoit=json`);\n    })\n    .then(res => {\n      if (!res.ok) throw new Error(`Problem with geocoding ${res.status}`);\n      return res.json();\n    })\n    .then(data => {\n      console.log(data);\n      console.log(`You are in ${data.city}, ${data.country}`);\n\n      return fetch(`https://restcountries.eu/rest/v2/name/${data.country}`);\n    })\n    .then(res => {\n      if (!res.ok) throw new Error(`Country not found (${res.status})`);\n\n      return res.json();\n    })\n    .then(data => renderCountry(data[0]))\n    .catch(err => console.error(`${err.message} 💥`));\n};\n\nbtn.addEventListener('click', whereAmI);"
        },
        {
          "label": "一个页面插入Image()的实例",
          "language": "javascript",
          "value": "//一个页面插入Image()的实例\nconst imgAddress = \"https://images.dog.ceo/breeds/papillon/n02086910_2359.jpg\";\n// https://images.dog.ceo/breeds/cattledog-australian/IMG_4379.jpg\n//promify\nconst imgPromise = (url) => {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.src = url;\n    //注意onload和addEventListener('load'，() =>{})的区别。onload适用于在整个页面或资源加载完毕后执行一些操作，而addEventListener('load'，() =>{})则更加灵活，可以在任何时候添加并处理特定的事件类型。\n    //用addEventListener()更好些\n    img.onload = () => {\n      resolve(img);\n    };\n    img.onerror = () => {\n      reject(newError(\"图片有误\"));\n    };\n  });\n};\n//consume promise\nimgPromise(imgAddress).then((img) => {\n  document.body.appendChild(img).catch((err) => {\n    document.body.innerHTML = err;\n  });\n});"
        },
        {
          "label": "创建图像并排队展示",
          "language": "javascript",
          "value": "const wait = function (seconds) {\n  return new Promise(function (resolve) {\n    setTimeout(resolve, seconds * 1000);\n  });\n};\n\nconst imgContainer = document.querySelector('.images');\n\nconst createImage = function (imgPath) {\n  return new Promise(function (resolve, reject) {\n    const img = document.createElement('img');\n    img.src = imgPath;\n\n    img.addEventListener('load', function () {\n      imgContainer.append(img);\n      // resolve the promise\n      resolve(img);\n    });\n\n    img.addEventListener('error', function () {\n      reject(new Error('Image not found'));\n    });\n  });\n};\n\nlet currentImg;\n\ncreateImage('img/img-1.jpg')\n//Comsume the promise using .then\n  .then(img => {\n    currentImg = img;\n    console.log('Image 1 loaded');\n    return wait(2);\n  })\n  .then(() => {\n    currentImg.style.display = 'none';\n    return createImage('img/img-2.jpg');\n  })\n  .then(img => {\n    currentImg = img;\n    console.log('Image 2 loaded');\n    return wait(2);\n  })\n  .then(() => {\n    currentImg.style.display = 'none';\n  })\n  .catch(err => console.error(err));"
        },
        {
          "label": "创建图像并排队展示Async/Await",
          "language": "javascript",
          "value": "const wait = function (seconds) {\n  return new Promise(function (resolve) {\n    setTimeout(resolve, seconds * 1000);\n  });\n};\n\nconst imgContainer = document.querySelector('.images');\n\nconst createImage = function (imgPath) {\n  return new Promise(function (resolve, reject) {\n    const img = document.createElement('img');\n    img.src = imgPath;\n\n    img.addEventListener('load', function () {\n      imgContainer.append(img);\n      resolve(img);\n    });\n\n    img.addEventListener('error', function () {\n      reject(new Error('Image not found'));\n    });\n  });\n};\n\nlet currentImg;\n\n// createImage('img/img-1.jpg')\n//   .then(img => {\n//     currentImg = img;\n//     console.log('Image 1 loaded');\n//     return wait(2);\n//   })\n//   .then(() => {\n//     currentImg.style.display = 'none';\n//     return createImage('img/img-2.jpg');\n//   })\n//   .then(img => {\n//     currentImg = img;\n//     console.log('Image 2 loaded');\n//     return wait(2);\n//   })\n//   .then(() => {\n//     currentImg.style.display = 'none';\n//   })\n//   .catch(err => console.error(err));\n\n// PART 1\nconst loadNPause = async function () {\n  try {\n    // Load image 1\n    let img = await createImage('img/img-1.jpg');\n    console.log('Image 1 loaded');\n    await wait(2);\n    img.style.display = 'none';\n\n    // Load image 1\n    img = await createImage('img/img-2.jpg');\n    console.log('Image 2 loaded');\n    await wait(2);\n    img.style.display = 'none';\n  } catch (err) {\n    console.error(err);\n  }\n};\n// loadNPause();\n\n// PART 2\n//an async function will always return a promise,not just a value\nconst loadAll = async function (imgArr) {\n  try {\n  //箭头函数后面省略了return关键字，因为箭头函数只有一行代码，所以可以省略return关键字\n    const imgs = imgArr.map(async img => await createImage(img));\n    //map后面都要用Promise.all\n    const imgsEl = await Promise.all(imgs);\n    console.log(imgsEl);\n    //这里不用返回数组所以用forEach最合适\n    imgsEl.forEach(img => img.classList.add('parallel'));\n  } catch (err) {\n    console.error(err);\n  }\n};\nloadAll(['img/img-1.jpg', 'img/img-2.jpg', 'img/img-3.jpg']);"
        },
        {
          "label": "timeout 函数",
          "language": "javascript",
          "value": "const timeout = function (s) {\n  return new Promise(function (_, reject) {\n    setTimeout(function () {\n      reject(new Error(`Request took too long! Timeout after ${s} second`));\n    }, s * 1000);\n  });\n};\n该函数通常用于配合其他异步操作，例如网络请求或者数据库查询等，以确保应用程序不会因为某个异步操作卡死而无法响应用户输入。\n这段代码中定义了一个 timeout 函数，它返回一个 Promise 对象。该函数的作用是在指定时间内（以秒为单位）检查异步操作是否已经完成，如果超时则抛出一个错误。\n\n具体来说，该函数接受一个参数 s，表示超时时间（单位为秒）。它创建一个新的 Promise 对象，并使用 setTimeout 函数在指定的时间后调用 reject 方法，从而抛出一个 Error 对象，提示异步操作超时。需要注意的是，在 setTimeout 中使用模板字符串，可以将超时时间插入到错误消息中，以便更好地提示用户。"
        }
      ],
      "id": "Oh_SFa72",
      "createdAt": 1681355064997,
      "updatedAt": 1684153133997
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "",
      "tagsIds": [],
      "description": null,
      "name": "Untitled snippet",
      "content": [
        {
          "label": "Fragment 1",
          "language": "plain_text",
          "value": "///////////////////////////////////////\n// Promisifying the Geolocation API\nconst getPosition = function () {\n  return new Promise(function (resolve, reject) {\n    // navigator.geolocation.getCurrentPosition(\n    //   position => resolve(position),\n    //   err => reject(err)\n    // );\n    navigator.geolocation.getCurrentPosition(resolve, reject);\n  });\n};\n// getPosition().then(pos => console.log(pos));\n\nconst whereAmI = function () {\n  getPosition()\n    .then(pos => {\n      const { latitude: lat, longitude: lng } = pos.coords;\n\n      return fetch(`https://geocode.xyz/${lat},${lng}?geoit=json`);\n    })\n    .then(res => {\n      if (!res.ok) throw new Error(`Problem with geocoding ${res.status}`);\n      return res.json();\n    })\n    .then(data => {\n      console.log(data);\n      console.log(`You are in ${data.city}, ${data.country}`);\n\n      return fetch(`https://restcountries.eu/rest/v2/name/${data.country}`);\n    })\n    .then(res => {\n      if (!res.ok) throw new Error(`Country not found (${res.status})`);\n\n      return res.json();\n    })\n    .then(data => renderCountry(data[0]))\n    .catch(err => console.error(`${err.message} 💥`));\n};\n\nbtn.addEventListener('click', whereAmI);"
        }
      ],
      "id": "ldtTIB8l",
      "createdAt": 1681363081382,
      "updatedAt": 1689141367142
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "Untitled snippet",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "// Promisifying the Geolocation API\nconst getPosition = function () {\n  return new Promise(function (resolve, reject) {\n    // navigator.geolocation.getCurrentPosition(\n    //   position => resolve(position),\n    //   err => reject(err)\n    // );\n    navigator.geolocation.getCurrentPosition(resolve, reject);\n  });\n};\n// getPosition().then(pos => console.log(pos));\n\nconst whereAmI = function () {\n  getPosition()\n    .then(pos => {\n      const { latitude: lat, longitude: lng } = pos.coords;\n\n      return fetch(`https://geocode.xyz/${lat},${lng}?geoit=json`);\n    })\n    .then(res => {\n      if (!res.ok) throw new Error(`Problem with geocoding ${res.status}`);\n      return res.json();\n    })\n    .then(data => {\n      console.log(data);\n      console.log(`You are in ${data.city}, ${data.country}`);\n\n      return fetch(`https://restcountries.eu/rest/v2/name/${data.country}`);\n    })\n    .then(res => {\n      if (!res.ok) throw new Error(`Country not found (${res.status})`);\n\n      return res.json();\n    })\n    .then(data => renderCountry(data[0]))\n    .catch(err => console.error(`${err.message} 💥`));\n};\n\nbtn.addEventListener('click', whereAmI);"
        }
      ],
      "id": "KpuOIxpH",
      "createdAt": 1681363098661,
      "updatedAt": 1681363396100
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "0mgkAi-B"
      ],
      "description": "Whenever possible, run promises in parallel(Promise.all) 如果不是互相依赖的关系，用Promise.all 可以加快速度\nConsume promises with async/await for best readability",
      "name": "Async/Await",
      "content": [
        {
          "label": "Consuming Promises with Async/Await",
          "language": "javascript",
          "value": "// Consuming Promises with Async/Await,注意aysnc返回的是promise的pending状态，并不是具体的数据值\n// Error Handling With try...catch\n\nconst getPosition = function () {\n  return new Promise(function (resolve, reject) {\n    navigator.geolocation.getCurrentPosition(resolve, reject);\n  });\n};\n\n// fetch(`https://restcountries.eu/rest/v2/name/${country}`).then(res => console.log(res))\n// 注意下面await的magic在于其返回值就是resove,和上面一行的作用是一样的\n// const res = await fetch(`https://restcountries.eu/rest/v2/name/${dataGeo.country}`); \n\nconst whereAmI = async function () {\n  try {\n    // Geolocation\n    const pos = await getPosition();\n    const { latitude: lat, longitude: lng } = pos.coords;\n\n    // Reverse geocoding\n    const resGeo = await fetch(`https://geocode.xyz/${lat},${lng}?geoit=json`);\n    if (!resGeo.ok) throw new Error('Problem getting location data');\n\n    const dataGeo = await resGeo.json();\n    console.log(dataGeo);\n\n    // Country data\n    const res = await fetch(\n      `https://restcountries.eu/rest/v2/name/${dataGeo.country}`\n    );\n\n    if (!res.ok) throw new Error('Problem getting country');\n\n    const data = await res.json();\n    console.log(data);\n    renderCountry(data[0]);\n  } catch (err) {\n    console.error(`${err} 💥`);\n    renderError(`💥 ${err.message}`);\n  }\n};\nwhereAmI();\nwhereAmI();\nwhereAmI();\nconsole.log('FIRST');"
        },
        {
          "label": "Returning Values from Async Functions",
          "language": "javascript",
          "value": "// Returning Values from Async Functions\nconst getPosition = function () {\n  return new Promise(function (resolve, reject) {\n    navigator.geolocation.getCurrentPosition(resolve, reject);\n  });\n};\n\nconst whereAmI = async function () {\n  try {\n    // Geolocation\n    const pos = await getPosition();\n    const { latitude: lat, longitude: lng } = pos.coords;\n\n    // Reverse geocoding\n    const resGeo = await fetch(`https://geocode.xyz/${lat},${lng}?geoit=json`);\n    if (!resGeo.ok) throw new Error('Problem getting location data');\n    const dataGeo = await resGeo.json();\n\n    // Country data\n    const res = await fetch(\n      `https://restcountries.eu/rest/v2/name/${dataGeo.country}`\n    );\n    if (!resGeo.ok) throw new Error('Problem getting country');\n    const data = await res.json();\n    renderCountry(data[0]);\n\n    return `You are in ${dataGeo.city}, ${dataGeo.country}`;\n  } catch (err) {\n    console.error(`${err} 💥`);\n    renderError(`💥 ${err.message}`);\n\n    // Reject promise returned from async function\n    throw err;\n  }\n};\n\nconsole.log('1: Will get location');\n// const city = whereAmI();\n// console.log(city);\n\n// whereAmI()\n//   .then(city => console.log(`2: ${city}`))\n//   .catch(err => console.error(`2: ${err.message} 💥`))\n//   .finally(() => console.log('3: Finished getting location'));\n\n\n//下面是用Async/Await的方式代替上面.then()的混合方式，都是可行的，根据个人习惯\n(async function () {\n  try {\n    const city = await whereAmI();\n    console.log(`2: ${city}`);\n  } catch (err) {\n    console.error(`2: ${err.message} 💥`);\n  }\n  console.log('3: Finished getting location');\n})();"
        },
        {
          "label": "Running Promises in Parallel",
          "language": "javascript",
          "value": "const get3Countries = async function (c1, c2, c3) {\n  try {\n    //下面是排队状态的(串行)而Promise.all可以并行的\n    // const [data1] = await getJSON(\n    //   `https://restcountries.eu/rest/v2/name/${c1}`\n    // );\n    // const [data2] = await getJSON(\n    //   `https://restcountries.eu/rest/v2/name/${c2}`\n    // );\n    // const [data3] = await getJSON(\n    //   `https://restcountries.eu/rest/v2/name/${c3}`\n    // );\n    // console.log([data1.capital, data2.capital, data3.capital]);\n\n    //注意在Promise前面加await的写法，Promise.all需要全部都resolce，有reject返回就会报错，而Promise.any允许有reject返回\n    const data = await Promise.all([\n      getJSON(`https://restcountries.eu/rest/v2/name/${c1}`),\n      getJSON(`https://restcountries.eu/rest/v2/name/${c2}`),\n      getJSON(`https://restcountries.eu/rest/v2/name/${c3}`),\n    ]);\n    //Promise.all返回了数组所以这里用map方法遍历\n    console.log(data.map(d => d[0].capital));\n  } catch (err) {\n    console.error(err);\n  }\n};\nget3Countries('portugal', 'canada', 'tanzania');"
        },
        {
          "label": "Promise.race, allSettled and any",
          "language": "javascript",
          "value": "// Other Promise Combinators: race, allSettled and any\n// Promise.racerace, allSettled and any\n(async function () {\n  const res = await Promise.race([\n    getJSON(`https://restcountries.eu/rest/v2/name/italy`),\n    getJSON(`https://restcountries.eu/rest/v2/name/egypt`),\n    getJSON(`https://restcountries.eu/rest/v2/name/mexico`),\n  ]);\n  console.log(res[0]);\n})();\n\nconst timeout = function (sec) {\n  return new Promise(function (_, reject) {\n    setTimeout(function () {\n      reject(new Error('Request took too long!'));\n    }, sec * 1000);\n  });\n};\n//Promise.race的一个实际应用案例-超时报错\nPromise.race([\n  getJSON(`https://restcountries.eu/rest/v2/name/tanzania`),\n  //如果time(5)先race在前面，也就是超出5秒就报出错误信息\n  timeout(5),\n])\n  .then(res => console.log(res[0]))\n  .catch(err => console.error(err));\n\n// Promise.allSettled\nPromise.allSettled([\n  Promise.resolve('Success'),\n  Promise.reject('ERROR'),\n  Promise.resolve('Another success'),\n]).then(res => console.log(res));\n\nPromise.all([ //这里会报错因为有reject\n  Promise.resolve('Success'),\n  Promise.reject('ERROR'),\n  Promise.resolve('Another success'),\n])\n  .then(res => console.log(res))\n  .catch(err => console.error(err));\n\n// Promise.any [ES2021]\nPromise.any([ //有reject不会报错\n  Promise.resolve('Success'),\n  Promise.reject('ERROR'),\n  Promise.resolve('Another success'),\n])\n  .then(res => console.log(res))\n  .catch(err => console.error(err));"
        },
        {
          "label": "实例",
          "language": "javascript",
          "value": "<script>\n  const isA = true;\n  const isB = true;\n  const isC = true;\n\n  function A() {\n    // 1.创建 Promise 实例\n    return new Promise((resolve, reject) => {\n    // 2. 当前处于[待定 (pending)] 状态下\n      console.log(\"执行 A 接口的逻辑\");\n      setTimeout(() => {\n        if (isA) {\n        // 3.进入 [已兑现 (fulfilled) ] 状态下\n          resolve(\"A 接口执行成功\");\n        } else {\n        // 4.进入 [已拒绝 (rejected) ] 状态下\n          reject(\"A 接口执行失败\");\n        }\n      }, 500);\n    });\n  }\n\n  function B() {\n    // 1.创建 Promise 实例\n    return new Promise((resolve, reject) => {\n      console.log(\"执行 B 接口的逻辑\");\n      setTimeout(() => {\n        if (isB) {\n          resolve(\"B 接口执行成功\");\n        } else {\n          reject(\"B 接口执行失败\");\n        }\n      }, 500);\n    });\n  }\n  function C() {\n    return new Promise((resolve, reject) => {\n      console.log(\"执行 C 接口的逻辑\");\n      setTimeout(() => {\n        if (isC) {\n          resolve(\"C 接口执行成功\");\n        } else {\n          reject(\"C 接口执行失败\");\n        }\n      }, 500);\n    });\n  }\n  //  then() 实现方案：顺序打印 A()、B()、C()------------\n  A()\n  .then((res) => { //这个then 返回的是一个Promise对象(是B的结果)，所以下面可以继续调用then\n    console.log(res);\n    return B();\n  }).\n  then((res) => { //这个then 返回的是一个Promise对象(是C的结果)，然后回调执行完毕，仍然可以在内部继续异步并发\n    console.log(res);\n    return C();\n  }).\n  then((res) => {\n    console.log(res);\n  })\n\n// 用最简单的async await 实现----------\n// async函数是使用async 关键字声明的函数，其中允许使用 await 关键字。\n// await操作符用于等待一个Promise兑现(就是说必须和Promise配合使用)并获取它兑现之后的值它只能在异步函数或者模块顶层中使用\n// async 和 await 关键字可以让我们以更简洁的方式写出基于Promise的异步行为，而无需刻意地链式调用Promise \nasync function test() {\n    const res = await A();//A()因为返回的是Promise对象，所以await会等待它执行完毕，然后返回结果\n    console.log(res);\n    const str = await B();\n    console.log(str);\n    const result = await C();\n    console.log(result);\n}\ntest()\n\n\n</script>\n"
        }
      ],
      "id": "hafqkq6-",
      "createdAt": 1681460910573,
      "updatedAt": 1703597549516
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "AOZ115q_",
        "ctJ0RMD1",
        "RoFzKEEw",
        "3GrbAyQg",
        "rsoj0LnD"
      ],
      "description": null,
      "name": "json data",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "[\n  {\n        \"name\": \"Germany\",\n        \"topLevelDomain\": [\n            \".de\"\n        ],\n        \"alpha2Code\": \"DE\",\n        \"alpha3Code\": \"DEU\",\n        \"callingCodes\": [\n            \"49\"\n        ],\n        \"capital\": \"Berlin\",\n        \"altSpellings\": [\n            \"DE\",\n            \"Federal Republic of Germany\",\n            \"Bundesrepublik Deutschland\"\n        ],\n        \"region\": \"Europe\",\n        \"subregion\": \"Western Europe\",\n        \"population\": 81770900,\n        \"latlng\": [\n             51,\n             9\n        ],\n         \"demonym\": \"German\",\n         \"area\": 357114,\n         \"gini\":  28.3,\n         \"timezones\": [\n             \"UTC+01:00\"\n        ],\n        \"borders\": [\n            \"AUT\",\n            \"BEL\",\n            \"CZE\",\n            \"DNK\",\n            \"FRA\",\n            \"LUX\",\n            \"NLD\",\n            \"POL\",\n            \"CHE\"\n        ],\n        \"nativeName\": \"Deutschland\",\n        \"numericCode\": \"276\",\n        \"currencies\": [\n            {\n                \"code\": \"EUR\",\n                \"name\": \"Euro\",\n                \"symbol\": \"€\"\n            }\n        ],\n        \"languages\": [\n            {\n                \"iso639_1\": \"de\",\n                \"iso639_2\": \"deu\",\n                \"name\": \"German\",\n                \"nativeName\": \"Deutsch\"\n            }\n        ],\n        \"translations\": {\n            \"br\": \"Alemanha\",\n            \"de\": \"Deutschland\",\n            \"es\": \"Alemania\",\n            \"fa\": \"آلمان\",\n            \"fr\": \"Allemagne\",\n            \"hr\": \"Njemačka\",\n            \"it\": \"Germania\",\n            \"ja\": \"ドイツ\",\n            \"nl\": \"Duitsland\",\n            \"pt\": \"Alemanha\"\n        },\n        \"flag\": \"https://restcountries.eu/data/deu.svg\",\n        \"regionalBlocs\": [\n            {\n                \"acronym\": \"EU\",\n                \"name\": \"European Union\"\n            }\n        ],\n        \"cioc\": \"GER\"\n    },\n    {…}\n]"
        }
      ],
      "id": "VOUuRmuI",
      "createdAt": 1681462593714,
      "updatedAt": 1682672082690
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "gJiRapX3",
        "T8D8hQN9"
      ],
      "description": "在前端代码中，使用递归函数遍历树形结构，计算节点数量。\n将计算出的节点数量展示到页面中。",
      "name": "将树形结构的数量展示到页面",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "// 递归函数，用于遍历树形结构并计算节点数量\nfunction countNodes(node) {\n  let count = 1; // 当前节点算一个\n  if (node.children && node.children.length > 0) { // 如果有子节点\n    for (let i = 0; i < node.children.length; i++) { // 遍历子节点\n      count += countNodes(node.children[i]); // 递归计算子节点数量\n    }\n  }\n  return count;\n}\n\n// 在页面中展示节点数量\nlet rootNode = { // 树形结构的根节点\n  name: 'root',\n  children: [\n    { name: 'child1' },\n    { name: 'child2', children: [\n      { name: 'grandchild1' },\n      { name: 'grandchild2' }\n    ]},\n    { name: 'child3' }\n  ]\n};\nlet nodeCount = countNodes(rootNode); // 计算节点数量\ndocument.getElementById('nodeCount').innerText = nodeCount; // 将节点数量展示到页面中\n\n在上面的代码中，我们定义了一个递归函数countNodes，用于遍历树形结构并计算节点数量。该函数接受一个节点作为参数，如果该节点有子节点，则遍历子节点并递归调用countNodes函数来计算子节点数量。最终返回的数量是当前节点数量加上所有子节点数量。\n\n在页面中，我们可以将树形结构的根节点传递给countNodes函数来计算节点数量，然后将计算出的数量展示到页面中。在上面的代码中，我们使用了一个div元素来展示节点数量，其id为nodeCount。我们通过document.getElementById('nodeCount')获取该元素，并将计算出的节点数量赋值给其innerText属性来展示节点数量。\n\n如果你需要将节点数量展示在树形结构上，可以在遍历树形结构时，将节点数量保存在节点的某个属性中，然后在渲染节点时，将该属性的值展示出来。\n"
        }
      ],
      "id": "hNF_6XsP",
      "createdAt": 1681733899191,
      "updatedAt": 1693365280386
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "SZZcOAmF"
      ],
      "description": "被代理的对象也会被修改\n什么是元编程：元编程（Metaprogramming）指的是在运行时动态地创建、修改和执行代码的能力。它是计算机科学中非常重要的一种编程范式，通常用于实现各种高级功能和框架。元编程可以通过很多不同的方式来实现，例如：动态生成代码：在程序运行时根据需要生成新的代码，并进行编译或解释执行。\n修改现有代码：利用反射等机制动态地修改已有的代码，以实现定制化的需求。\n定义DSL（领域特定语言）：通过元编程技术定义出一些特定领域的语法或语言，使得程序员可以更加方便地使用这些语言来描述领域模型。\n元编程通常需要使用一些特定的工具和技术，例如反射、注解、模板元编程、代码生成器等。同时，它也会涉及到一些底层的概念和机制，例如编译器、虚拟机、代码优化等。\n元编程在实际编程中被广泛应用，例如在框架、库、代码生成器、测试框架、模板引擎等领域。通过使用元编程技术，我们可以更加灵活地处理复杂的问题，并提高代码的可维护性、可扩展性和可重用性",
      "name": "Proxy是一种元编程机制",
      "content": [
        {
          "label": "Proxy的概念",
          "language": "javascript",
          "value": "概念\nProxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。\nProxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”\nES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。 var proxy = new Proxy(target, handler);\ntarget 参数表示所要代理的目标对象，handler 参数也是一个对象，用来定制代理拦截行为。 Proxy 对象的所有用法，都是上面这种形式，不同的只是 handler 参数的写法。其中，new Proxy() 表示生成一个Proxy实例。\n\nJavaScript中的Proxy是一种元编程机制，它允许您在运行时拦截和定义对象上的各种底层操作。通过使用Proxy，您可以对对象的默认行为进行自定义，并在访问或修改对象属性时实现更高级的逻辑。\n具体来说，Proxy包含一个目标对象（target）和一个代理处理程序（handler）。当您尝试访问或修改目标对象时，实际上会调用代理处理程序上的相应方法进行处理。代理处理程序可以定义一系列捕获器（trap），用于拦截和处理各种操作，例如属性访问、赋值、方法调用等。\n例如，以下代码演示了如何使用Proxy拦截和修改对象的属性访问：\n\nlet target = {name: 'John', age: 30};\nlet handler = {\n  get: function(target, prop) {\n    console.log('Accessing property: ' + prop);\n    return target[prop];\n  },\n  set: function(target, prop, value) {\n    console.log('Setting property: ' + prop);\n    target[prop] = value;\n  }\n};\nlet proxy = new Proxy(target, handler);\n\nconsole.log(proxy.name); // Accessing property: name  John\nproxy.age = 35; // Setting property: age\nconsole.log(proxy.age); // Accessing property: age  35\n\n在上面的代码中，我们首先定义了一个目标对象target和一个代理处理程序handler。在代理处理程序中，我们定义了两个捕获器（get和set），用于拦截目标对象的属性访问和赋值操作。然后，我们使用new关键字和Proxy构造函数创建了一个代理对象proxy，并将它指向目标对象target。\n接着，我们通过访问和修改代理对象的属性来演示了拦截器的功能。当我们访问代理对象的属性时，实际上会调用get捕获器中定义的逻辑，打印出相应的信息并返回目标对象中对应的属性值。同样地，当我们修改代理对象的属性时，实际上会调用set捕获器中定义的逻辑，打印出相应的信息并修改目标对象中对应的属性值。\n需要注意的是，虽然Proxy可以实现各种高级功能，但也可能会带来性能问题和安全隐患。因此，在使用Proxy时需要谨慎考虑，并根据具体情况进行优化和防范措施。\n\nlet obj = new Proxy(target,handler);\ntarget 参数表示所要代理的目标对象，handler 参数也是一个对象，用来定制代理拦截行为。\n自定义对象属性的获取、赋值、枚举、函数调用的等功能\n这个target对象和下面proxy实例对象是不同的对象，但都会被修改\nvar target = { a: 1,b: 2,};\nlet proxy = new Proxy(target, {  \n//第二个参数是handler，很多函数都是这种结构，很简单！\n   get(target, prop) { // 第二个参数是属性\n     console.log(\"This is property value\" + target[prop]);\n     //或 return \"This is property value\" + target[prop]\n   },\n        \n   set(target, prop,value) {\n     target[prop] = value;\n     console.log(target[prop]);\n    },\n});\n\nconsole.log(proxy.a); //This is property value 1\nconsole.log(target.a); // 1\nproxy.b = 3; // set() 设置后这里会生效\nconsole.log('target:', target); // 被代理的对象也被修改了\n\n"
        },
        {
          "label": "proxy 对数组操作",
          "language": "javascript",
          "value": "let arr = [\n        { name: \"小明\", age: 18 },\n        { name: \"小红\", age: 23 },\n        { name: \"小青\", age: 14 },\n        { name: \"小黄\", age: 35 },\n      ];\nlet persons = new Proxy(arr, {\n        get(arr, prop) {\n          return arr[prop];\n        },\n        set(arr, prop, value) { // set有三个参数\n          arr[prop] = value;\n        },\n});\n\nconsole.log(persons[3]); //{name: '小黄', age: 35}\npersons[1] = { name: \"小张\", age: 33 }; //将第二个对象，小红改掉\nconsole.log(persons, arr);"
        },
        {
          "label": "JS中代理Proxy的简单使用",
          "language": "javascript",
          "value": "//下面是一个拦截读取属性行为的例子\nlet proxy = new Proxy({},{\n  get:function (target,key) {\n    // target 是要代理的对象，key 是要获取的属性\n    // 原对象的属性名称在代理之后是不会发生变化的\n    return 35\n  }\n})\n\nconsole.log(proxy.name); // 35\nconsole.log(proxy.age);  // 35\nconsole.log(proxy.time); // 35\n\n上面代码中，作为构造函数，Proxy 接受两个参数。\n\n第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有 Proxy 的介入，操作原来要访问的就是这个对象；\n第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个 get 方法，用来拦截对目标对象属性的访问请求。get 方法的两个参数分别是目标对象和所要访问的属性。\n可以看到，由于拦截函数总是返回35，所以访问任何属性都得到35。\n\n注意，要使得 Proxy 起作用，必须针对 Proxy 实例进行操作，而不是针对目标对象进行操作。\n另外，如果 Proxy 的第二个参数 handler 没有设置任何拦截，那就等同于直接通向原对象。\n\nvar target = {};\nvar handler = {};\nvar proxy = new Proxy(target, handler);\nproxy.a = 'b';\ntarget.a // \"b\"\n\n// handler 是一个空对象，没有任何拦截效果，访问 proxy 就等同于访问 target\n\n"
        },
        {
          "label": "Proxy 实例的方法",
          "language": "javascript",
          "value": "Proxy 支持的拦截操作一共 13 种。下面介绍一下 get 和 set 的简单使用\n1、get()\nget 方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。\n下面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回 undefined。\n\nlet person = {\n  name: 'webchang'\n}\n\nlet proxy = new Proxy(person, {\n  get(target, key) {\n    if (key in target) {\n      return target[key]\n    }\n    return new Error('属性不存在')\n  }\n})\n\nconsole.log(proxy.name);\nconsole.log(proxy.age);\n\n2、set()\nset 方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。\n\nlet validator = {\n  set:function (target, key, value) {\n    if (key === 'age') {\n      if (!Number.isInteger(value) || value > 150) {\n        throw new Error('数据不合法')\n      }\n    }\n\n    // 对于满足条件的 age 属性以及其他属性，直接保存\n    target[key] = value;\n  }\n}\n\nlet proxy = new Proxy({},validator);\n\nproxy.age = 89;\nconsole.log(proxy.age); // 89\n\nproxy.age = 'webchang'; // 报错\nproxy.age = 200;        // 报错\n\n上面代码中，由于设置了存值函数 set ，任何不符合要求的 age 属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。\n\n有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合 get 和 set 方法，就可以做到防止这些内部属性被外部读写。下面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。\n\nfunction invariant (key, action) {\n  if (key[0] === '_') {\n    throw new Error(`不应该在 ${action} 方法中访问 ${key} 属性`)\n  }\n}\n\nlet handler = {\n  get(target, key) {\n    invariant(key, 'get');\n    return target[key];\n  },\n  set(target, key, value) {\n    invariant(key, 'set');\n    target[key] = value;\n  }\n}\n\nlet proxy = new Proxy({}, handler);\n\nconsole.log(proxy._age);  // Uncaught Error: 不应该在 get 方法中访问 _age 属性\nproxy._name = 'webchang'; // Uncaught Error: 不应该在 set 方法中访问 _name 属性\n\n案例  1、明星经纪人案例\n// 明星对象\nlet star = { name:'webchang', age:18, phone:'12345' }\n\n// 经纪人-代理对象，第二个参数是 handler,是所有函数常见的用法，很简单！，可以单独拎出来写\nlet agent = new Proxy(star,{\n  get:function (target,key) {\n    if (key === 'phone') {\n      // 返回经纪人自己的电话，明星的电话要保密\n      return '56789';\n    }\n\n    if (key === 'price') {\n      //明星不报价，经纪人报价\n      return 120000;\n    }\n    //如果不是上边的 phone 和price，就直接返回 star 自己的属性，可能是 name 或者 age\n    return target[key];\n  },\n  set:function (target,key,value) {\n    // 谈合作价格\n    if(key === 'customPrice') {\n      if (value < 100000) {\n        throw new Error('价格太低')\n      } else {\n        target[key] = value;\n        return true;\n      }\n    }\n  }\n})\n\n//测试\nconsole.log(agent.name);     // webchang\nconsole.log(agent.age);      // 18\nconsole.log(agent.phone);    // 56789 拿到的是经纪人的电话\nconsole.log(agent.price);    // 120000\n// agent.customPrice = 9000; // 报错 Uncaught Error: 价格太低\n\nagent.customPrice = 900000;\nconsole.log(agent.customPrice); // 900000\n\n\n"
        }
      ],
      "id": "CViPsepB",
      "createdAt": 1681889303089,
      "updatedAt": 1687248966773
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [],
      "description": "Axios ：是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中",
      "name": "axios",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "下面是在 vue 项目中的配置，包含以下设置\n\n请求时显示加载动画\n携带 token\n表单验证错误错误记录到 vuex\n无权限（401）时跳转到登录界面\n\nimport axios from 'axios'\nimport store from '@/store'\nimport router from '@/router'\nimport { ElMessage, ElLoading } from 'element-plus'\n\nconst instance = axios.create({\n    headers: {\n        'Content-Type': 'application/json',\n    },\n})\n\n//加载动画\nlet loading = null\n\ninstance.interceptors.request.use(\n    function (config) {\n        const baseUrl = import.meta.env.MODE == 'development' ? 'http://houdunren.test/api' : '/'\n        config.baseURL = baseUrl\n\n        //携带令牌\n        const token = window.localStorage.getItem('token')\n        if (token) config.headers.Authorization = `Bearer ${token}`\n        //加载动画\n        loading = ElLoading.service({\n            lock: true,\n            text: '加载中...',\n            spinner: 'el-icon-loading',\n            background: 'rgba(255, 255, 255, 0)',\n        })\n        return config\n    },\n    function (error) {\n        return Promise.reject(error)\n    }\n)\n\ninstance.interceptors.response.use(\n    function (response) {\n        loading.close()\n        const { data } = response\n        if (data.message) {\n            ElMessage.success({\n                message: data.message,\n                type: 'success',\n            })\n        }\n\n        return data\n    },\n    function (error) {\n        loading.close()\n        const { status, data } = error.response\n\n        switch (status) {\n            case 422:\n                //表单验证失败\n                store.commit('error/set', data.errors)\n                break\n            case 401:\n                store.commit('user/logout')\n                router.push('/login')\n                break\n        }\n\n        return Promise.reject(error)\n    }\n)\n\nexport default instance"
        },
        {
          "label": "axios封装",
          "language": "javascript",
          "value": "//引入axios\nimport axios from \"axios\";\n\n//创建实例\nconst api = axios.create({\n  //请求地址的公共部分\n  baseURL: \"\",\n  //请求的超时时间\n  timeout: 3000,\n});\n\n//请求拦截器\napi.interceptors.request.use(\n  (config) => {\n    //config 请求的信息\n    return config;\n  },\n  (err) => {\n    //抛出错误\n    Promise.reject(err);\n  }\n);\n\n//响应拦截器\napi.interceptors.response.use(\n  (res) => {\n    //res 响应的信息\n    console.log(res);\n    return Promise.resolve(res);\n  },\n  (err) => {\n    //抛出错误\n    Promise.reject(err);\n  }\n);\n\nexport default api;\n\n\n==================================== 以上是myAxios.js文件,下面在request.js文件封装接口\nimport api from 'myAxios.js'\n\nexport const login = () => api({\n  url: '',\n  method: 'get',\n  params: params\n})\n\n===================================下面是使用\nimport { login } from 'request.js'\n\nmethod: {\n  //是基于promise的所以这里可以用then()\n  login().then(res => {\n    console.log(res)\n  })\n}\n\n\n"
        },
        {
          "label": "atone的request.js文件",
          "language": "javascript",
          "value": "// atone使用的模板是vue Admin Template\nimport axios from 'axios'\nimport { Message } from 'element-ui'\n// import store from '@/store'\n// import { getToken } from '@/utils/auth'\n\n// create an axios instance\nconst service = axios.create({\n    baseURL: process.env.VUE_APP_BASE_API,\n    // withCredentials: true, // send cookies when cross-domain requests\n    timeout: 10000 // request timeout\n})\n\n// request interceptor\nservice.interceptors.request.use(\n    config => {\n        // do something before request is sent\n\n        if (window.localStorage.token) {\n            config.headers['Authorization'] = 'Bearer ' + window.localStorage.token\n        }\n        if (window.localStorage.uid) {\n            config.headers['X-Forwarded-User'] = window.localStorage.uid\n        }\n        if (window.localStorage.teamid) {\n            config.headers['X-Forwarded-Team'] = window.localStorage.teamid\n        }\n        return config\n    },\n    error => {\n        // do something with request error\n        console.log(error) // for debug\n        return Promise.reject(error)\n    }\n)\n\n// response interceptor\nservice.interceptors.response.use(\n    /**\n     * If you want to get http information such as headers or status\n     * Please return  response => response\n     */\n\n    /**\n     * Determine the request status by custom code\n     * Here is just an example\n     * You can also judge the status by HTTP Status Code\n     */\n    response => {\n        const res = response.data\n\n        // if the custom code is not 20000, it is judged as an error.\n\n        if (res.code !== 0) {\n            Message({\n                message: res.msg || 'Error',\n                type: 'error',\n                duration: 1 * 1000\n            })\n\n\n            // }\n            return Promise.resolve(res)\n                // return Promise.reject(new Error(res.message || 'Error'))\n        } else {\n            return res\n        }\n    },\n    error => {\n        console.log(error) // for debug\n        if (error.response) {\n            if (error.response.status === 502) {\n                Message({\n                    message: '服务暂时不可用',\n                    type: 'error',\n                    duration: 5 * 1000\n                })\n            } else if (error.response.status === 500 || error.response.status === 400 || error.response.status === 404) {\n                let msg = '服务接口调用出错 ' + error.response.status + '：' + error.response.config.url\n                if (error.response.data.msg) {\n                    msg = error.response.data.msg\n                }\n                Message({\n                    message: msg,\n                    type: 'error',\n                    duration: 5 * 1000\n                })\n            } else if (error.response.status === 401) {\n                Message({\n                    message: '用户授权已失效，请重新登陆系统。可能原因：长时间未操作或该账号已在其它位置登录。',\n                    type: 'error',\n                    duration: 5 * 1000\n                })\n                setTimeout(() => {\n                    delete window.localStorage.username\n                    delete window.localStorage.uid\n                    delete window.localStorage.teamid\n                    delete window.localStorage.token\n                    delete window.localStorage.isMaster\n                    delete window.localStorage.parentName\n                    location.reload()\n                }, 5000)\n            } else {\n                Message({\n                    message: error.response.data.msg ? error.response.data.msg : error.response.data,\n                    type: 'error',\n                    duration: 5 * 1000\n                })\n            }\n        } else {\n            Message({\n                message: error.message,\n                type: 'error',\n                duration: 5 * 1000\n            })\n        }\n    }\n)\n\nexport default service"
        },
        {
          "label": "axios封装2",
          "language": "javascript",
          "value": "// 把axios发送请求的公共信息进行提取\nlet instance = axios.create();\n// 创建axios实例,这样在把此代码加入项目里不会和已有的axios封装冲突\ninstance.defaults.baseURL = 'http://127.0.0.1:8888';\n// 设置基础URL\ninstance.defaults.headers['Content-Type'] ='multipart/form-data';\n// 设置请求头\ninstance.defaults.transformRequest = (data, headers) => {\n    const contentType = headers['Content-Type'];\n    // 如果请求头中包含Content-Type，则使用Qs.stringify()方法将data转换为字符串\n    if (contentType === \"application/x-www-form-urlencoded\") return Qs.stringify(data);\n    // 否则直接返回data\n    return data;\n};\n// 设置响应拦截处理\ninstance.interceptors.response.use(response => {\n    // 响应处理\n    return response.data;\n});"
        }
      ],
      "id": "J4kkBfUp",
      "createdAt": 1682234527113,
      "updatedAt": 1692106011790
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "ejtoZnYa",
      "tagsIds": [
        "tkMsewzC",
        "eWJmuiVv",
        "tgcSxj7Y"
      ],
      "description": "最终会打印出node、electron、chrome版本信息",
      "name": "使用预加载脚本preload.js通过node 的process查看软件版本的信息",
      "content": [
        {
          "label": "main.js 主进程脚本",
          "language": "javascript",
          "value": "const { BrowserWindow, app } = require('electron')\nconst path = require('path')\n\nconst createWindow = () => {\n  const win = new BrowserWindow({\n    width: 300,\n    height: 300,\n    webPreferences: {\n    \t//预加载脚本\n      preload: path.resolve(__dirname, 'preload.js'),\n    },\n  })\n  //因为上面引用了nodeJS的path模块这里才可以实现下面到吗\n  win.loadFile(path.resolve(__dirname, 'index.html'))\n  //打开开发者工具\n  win.webContents.openDevTools()\n}\n\napp.whenReady().then(() => {\n  createWindow()\n})"
        },
        {
          "label": "preload.js 预加载脚本",
          "language": "javascript",
          "value": "document.addEventListener('DOMContentLoaded', () => {\n  for (const soft of ['chrome', 'electron', 'node']) {\n    console.log(soft)\n    document.querySelector(`#${soft}`).innerHTML = `${soft}:` + process.versions[soft]\n  }\n})"
        },
        {
          "label": "index.html 模板文件",
          "language": "javascript",
          "value": "<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; script-src 'self'\" />\n    <meta http-equiv=\"X-Content-Security-Policy\" content=\"default-src 'self'; script-src 'self'\" />\n    <title>houdunren</title>\n  </head>\n  <body>\n    <div id=\"chrome\"></div>\n    <div id=\"node\"></div>\n    <div id=\"electron\"></div>\n    <script src=\"renderer.js\"></script>\n  </body>\n</html>"
        }
      ],
      "id": "cA_wT8z3",
      "createdAt": 1682239811026,
      "updatedAt": 1682240277150
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "ejtoZnYa",
      "tagsIds": [],
      "description": "下面介绍渲染进程向主进程通信，这是单向通信行为。本例实现的功能是渲染进程向主进程发送请求，更改窗口标题。",
      "name": "进程通信：渲染进程到主进程",
      "content": [
        {
          "label": "main.js",
          "language": "javascript",
          "value": "const { BrowserWindow, app, ipcMain } = require('electron')\nconst path = require('path')\n\nconst createWindow = () => {\n  const win = new BrowserWindow({\n    width: 300,\n    height: 300,\n    alwaysOnTop: true,\n    x: 1500,\n    y: 100,\n    webPreferences: {\n      preload: path.join(__dirname, 'preload.js'),\n    },\n  })\n  win.webContents.openDevTools()\n\n  win.loadFile(path.resolve(__dirname, 'index.html'))\n}\n\napp.whenReady().then(() => {\n  createWindow()\n\n  //主进程事件监听\n  ipcMain.on('setTitle', (event, title) => {\n    //获取用于控制网页的webContents对象\n    const webContents = event.sender\n    //获取窗口\n    const win = BrowserWindow.fromWebContents(webContents)\n    //设置窗口标题\n    win.setTitle(title)\n  })\n})"
        },
        {
          "label": "preload.js",
          "language": "javascript",
          "value": "const { contextBridge, ipcRenderer } = require('electron')\n//为渲染进程暴露API\ncontextBridge.exposeInMainWorld('api', {\n  //该API用于向主进程事件\n  setTitle: (title) => ipcRenderer.send('setTitle', title),\n})"
        },
        {
          "label": "index.html",
          "language": "javascript",
          "value": "<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; script-src 'self'\" />\n    <title>houdunren</title>\n  </head>\n  <body>\n    <input type=\"text\" name=\"title\" />\n    <button>更改标题</button>\n    <script src=\"renderer.js\"></script>\n  </body>\n</html>\n"
        },
        {
          "label": "renderer.js",
          "language": "javascript",
          "value": "window.addEventListener('DOMContentLoaded', () => {\n  document.querySelector('button').addEventListener('click', () => {\n    const value = document.querySelector('[name=title]').value\n\n    //使用preload.js暴露出的API，触发主进程事件\n    window.api.setTitle(value)\n  })\n})"
        }
      ],
      "id": "JD6syzw0",
      "createdAt": 1682240476547,
      "updatedAt": 1692066332270
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3BVGYMMN",
      "tagsIds": [],
      "description": "主进程主动向渲染进程通信，这也是单向通信IPC。将消息从主进程发送到渲染器进程时，需要指定是哪一个渲染器接收消息。 消息需要通过 WebContents ，实例的send方法发送到渲染器进程。",
      "name": "进程通信：主进程到渲染进程",
      "content": [
        {
          "label": "main.js",
          "language": "javascript",
          "value": "const { BrowserWindow, app, ipcMain, Menu } = require('electron')\nconst path = require('path')\n\nconst createWindow = () => {\n  const win = new BrowserWindow({\n    width: 300,\n    height: 300,\n    alwaysOnTop: true,\n    x: 1500,\n    y: 100,\n    webPreferences: {\n      preload: path.join(__dirname, 'preload.js'),\n    },\n  })\n  //定义菜单\n  const menu = Menu.buildFromTemplate([\n    {\n      label: '菜单',\n      submenu: [\n        {\n          click: () => win.webContents.send('increment', 1),\n          label: '增加',\n        },\n      ],\n    },\n  ])\n  Menu.setApplicationMenu(menu)\n\n  //打开开发者工具\n  win.webContents.openDevTools()\n  win.loadFile(path.resolve(__dirname, 'index.html'))\n}\n\napp.whenReady().then(() => {\n  createWindow()\n})\n\n//接收渲染进程的结果\nipcMain.on('finish', (event, value) => {\n  console.log('最后结果是：' + value)\n})"
        },
        {
          "label": "preload.js",
          "language": "javascript",
          "value": "const { contextBridge, ipcRenderer } = require('electron')\n//为渲染进程暴露API\ncontextBridge.exposeInMainWorld('api', {\n  //为渲染进程设置接口，用于接收主进程的消息\n  incrementNumber: (callback) => ipcRenderer.on('increment', callback),\n})"
        },
        {
          "label": "index.html",
          "language": "javascript",
          "value": "<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; script-src 'self'\" />\n    <title>houdunren</title>\n  </head>\n  <body>\n    <h1></h1>\n    <script src=\"renderer.js\"></script>\n  </body>\n</html>"
        },
        {
          "label": "render.js",
          "language": "javascript",
          "value": "//向预加载脚本传递回调方法，用于处理主进程的消息\nwindow.api.incrementNumber((event, value) => {\n  const h1 = document.querySelector('h1')\n  h1.innerHTML = Number(h1.innerText) + value\n  //向主进程发送消息\n  event.sender.send('finish', h1.innerHTML)\n})"
        }
      ],
      "id": "k0j_vUS9",
      "createdAt": 1682240812534,
      "updatedAt": 1682407930159
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "k7BDpYlW",
        "cRFLDtUi"
      ],
      "description": "JavaScript中的回调函数是指将一个函数作为参数传递给另一个函数，并且在另一个函数执行完毕后执行该函数的过程。回调函数通常用于异步编程中，因为JavaScript是单线程执行的语言，不能同时执行多个任务，因此通过回调函数来实现异步编程。",
      "name": "回调函数 callback",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "\nfunction greet(name, callback) {\n  console.log(`Hello ${name}!`);\n  //在一个函数执行完毕后执行该函数\n  const data={name:'qing',age:28}\n  callback(data); //注意参数传递数据的应用，很基本但很重要和容易困扰，这里是实参\n}\n//调用的时候第二个参数是函数，无需名称(当然也可以拎出来写个函数这里用名称调用)，但上面定义的时候必须有名称,注意括号里的是参数(形参)，不是函数名称\ngreet('okzu', (data) => {\n  console.log('bye!',data.name,data.age);\n})\n\n回调函数的用法： 1) 作为函数参数传递\nfunction foo(callback) {\n  console.log('foo');\n  //这里要调用一下\n  callback();\n}\nfunction bar() {\n  console.log('bar');\n}\nfoo(bar); // 输出：foo，bar\n\n2) 作为异步操作的回调函数：重点：有两个函数，其中一个是作为参数使用的\n//参数是一个函数，这里是形参，可以随便命名\nfunction getDataFromServer(callback) {\n  setTimeout(function() {\n    var data = {name: 'Tom', age: 18};\n    //函数在另一个函数体内调用了\n    callback(data);\n  }, 1000);\n}\n//定义一个函数，是用来作为另一个函数的参数的\nfunction handleData(data) {\n  console.log(data.name, data.age);\n}\n//调用函数，传入的是另一个定义过的函数,传入的是实参，接受的时候是形参\ngetDataFromServer(handleData);\n在上述例子中，getDataFromServer函数模拟了一个从服务器获取数据的异步操作，通过将handleData函数作为回调函数传递给getDataFromServer函数，当异步操作完成后，handleData函数会被调用来处理返回的数据。\n回调函数的优点是可以实现异步编程，避免了阻塞主线程，提高了程序的运行效率。但是，如果回调函数嵌套过多，代码可读性会变差，形成回调地狱，因此需要使用Promise、async/await等解决方案来改善。"
        },
        {
          "label": "写法二",
          "language": "javascript",
          "value": "function greeting(name, callback) {\n  console.log('Hello, ' + name + '!');\n  callback();\n}\n\nfunction sayGoodbye() {\n  console.log('Goodbye!');\n}\n\ngreeting('John', sayGoodbye);"
        }
      ],
      "id": "xEoWinXQ",
      "createdAt": 1682350933184,
      "updatedAt": 1682422105183
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "ejtoZnYa",
      "tagsIds": [
        "k7BDpYlW",
        "cRFLDtUi"
      ],
      "description": "下面演示的是用electron的方式选择文件，而不是html的方式；\n思路就是渲染进程向预加载脚本发送指令，预加载脚本调用主进程的方法；弹出对话框选择文件，然后把结果返回给预加载脚本，预加载脚本进行dom操作或通过回调函数把参数传递给渲染进程，使得渲染进程获得最终结果\n这里重点了解回调函数的用法",
      "name": "electron进程通讯的概念：invoke是双向通信的更佳方案",
      "content": [
        {
          "label": "renderer.js 渲染进程文件",
          "language": "javascript",
          "value": "//+++++++++++++++++++ 1）选择文件的部分，这个示例演示了双路通信，其中的关键词是handle和 invoke\n//加载后执行\nwindow.addEventListener('DOMContentLoaded,()=>{\n   const btn = document.querySelector(\"#btn\")\n   btn.addEventListener('click'()=>{\n//upload()是在preload.js预加载脚本里定义的调用主进程里事件的方法\n        //这里upload里的参数()={}是一个回调函数,是由preload.js的upload方法传过来的\n       window.api.upload((file)=>{ //file是回调函数的形参\n       //通过preload.js里定义的回调函数，在这里调用后获取到结果\n       //本例中这个file是一个文件的路径，从主线程main.js通过preload.js以回调的形式传过来。也就是说这里执行调用了preload里的回调函数upload()\n          document.querySelector('input').value = file\n       })\n   })\n})\n//+++++++++++++++++++++ 2）更改窗口标题的部分,这个示例显示了怎么从渲染进程给主进程传递参数\nwindow.addEventListener('DOMContentLoaded,()=>{\n   const btn = document.querySelector(\"#btn2\")\n   btn.addEventListener('click'()=>{\n     const title = document.querySelector(\"input\").value\n     //changeTitle是预加载脚本的方法，这里是把title传递过去，然后预加载脚本再传递给主进程\n     window.api.changeTitle(title)\n   })\n})"
        },
        {
          "label": "preload.js预加载脚本中使用invoke()",
          "language": "javascript",
          "value": "//++++++++++++++++++++++++++ 选择文件\ncontextBridge.exposeInMainWorld('api',{\n   //这里是定义了一个方法，等待别处(渲染进程)的调用\n   upload:async(callback) =>{ //注意匿名函数可以直接加async关键字，这里的参数是形参\n     //selectFile是主进程定义的事件，被预加载脚本调用\n     //return ipcRenderer.invoke('selectFile')//这里返回的是主进程里的promise对象,下面是更优的写法\n     const file = await ipcRenderer.invoke('selectFile')//await返回的是promise的resove结果\n     //console.log(file) //这里会打印出文件路径\n     //document.querySelector('input').value = file//这里进行dom操作不是最优的，应该在渲染进程完成\n     callback(file)\n   },\n})\n//++++++++++++++++++++++++++ 改变窗口标题title\ncontextBridge.exposeInMainWorld('api'，{\n   changeTitle: (newTitle) => {\n     //调用主进程事件\n     ipcRenderer.send('updateTitle',newTitle)\n   },\n})"
        },
        {
          "label": "main.js",
          "language": "javascript",
          "value": "//主进程这里是在定义事件；注意：很多程序都是基于事件响应的，很简单的概念\n//不用之前的ipcMain.on而是ipcMain.handle\nipcMain.handle('selectFile',async (event)=>{\n  // const obj = await dialog.showOpenDialog({}}) //这里返回一个对象，下面解构其中的属性\n  //console.log(obj)\n   const {filePaths} = await dialog.showOpenDialog({}})\n   //将结果return出去，preload.js里会接收到\n   return filePaths[0] \n})\n//+++++++++++++修改窗口标题\n//updateTitle是事件对象，value是从渲染进程通过预加载脚本preload.js传递过来的标题的值\nipcMain.on('updateTitle',(event,value)=>{\n   //console.log(value) //这个value就是窗口的标题\n   //找到网页对象，然后更改他的标题\n   BrowserWindow.fromWebContents(event.sender).title=value \n   \n})"
        },
        {
          "label": "html",
          "language": "javascript",
          "value": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <title>改变这里标题</title>\n  </head>\n  <body>\n    <input type=\"text\" />\n    <button id=\"btn\">上传文件</button>\n     \n    <input type=\"text\" />\n    <button id=\"btn2\">设置标题</button>\n    \n    <-- render.js是渲染进程代码 -->\n    <script src=\"renderer.js\"></script>\n  </body>\n</html>"
        }
      ],
      "id": "Aax9Kd85",
      "createdAt": 1682407857072,
      "updatedAt": 1692066350927
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [],
      "description": null,
      "name": "将英文转换为中文",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "// 1）在 Vue 实例中定义一个名为 statusMap 的对象，用于存储 status 对应的中文翻译\n// 2) 然后，在模板中使用计算属性来获取状态的中文翻译\n<template>\n  <div>\n    状态：{{ statusText }}\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      status: {\n        status: 'HEALTH_OK' // 英文状态码\n      },\n       //1）在 Vue 实例中定义一个名为 statusMap 的对象，用于存储 status 对应的中文翻译\n      statusMap: {\n        'HEALTH_Ok': '健康', // 中文翻译\n        'HEALTH_Warn': '告警',\n        'HEALTH_Err': '错误'      \n      }\n    }\n  },\n  computed: {\n  // 2) 然后，在模板中使用计算属性来获取状态的中文翻译\n    statusText() {\n      return this.statusMap[this.status.status];\n    }\n  }\n}\n</script>"
        }
      ],
      "id": "WTy1bbCe",
      "createdAt": 1682563280234,
      "updatedAt": 1682563598252
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "K9oTGZ3c",
        "jPiHk23T",
        "itTFTksg",
        "7B1vmnZR"
      ],
      "description": null,
      "name": "export/import",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "//import的代码会先执行，import的代码执行完成后才会执行自身的代码，\n//TTop level await:另外import的代码模块里用await可以不用写async,(这个叫top level await)注意await会阻断代码的执行，这个特性在某些情况下很有用，也可能在不需要的情况下有害；\n\nexport default someName  //如果是export default 过来的，那么import 的名称可以自定义"
        }
      ],
      "id": "aoKbCKP3",
      "createdAt": 1682586627971,
      "updatedAt": 1682590824364
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "uIXLFdiz",
      "tagsIds": [],
      "description": null,
      "name": "lodash install",
      "content": [
        {
          "label": "Fragment 1",
          "language": "plain_text",
          "value": "npm i lodash-es\n在vscode安装后点开node_modules目录下会有lodash_es文件夹，下面有很多.js文件，是lodash的方法；\n举例：将其中的cloneDeep.js导入,点击cloneDeep.js可以查看其中内容,可以看到这个方法是export default cloneDeep出来的，这就是说，import进来的时候可以自定义名称。"
        }
      ],
      "id": "4-gYIY6A",
      "createdAt": 1682661328548,
      "updatedAt": 1682662867017
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "uf8TkRi0",
        "BImuQBfA",
        "tocBVsRT",
        "N_xlnWtn",
        "NwaiK6Nk",
        "nO7R5SUy",
        "v8-YaD_f",
        "hUnbIkaC"
      ],
      "description": "知识点：函数的拆分；forEach()的使用；setTimeout(）宏任务的延迟作用",
      "name": "draggable-list 列表拖拽",
      "content": [
        {
          "label": "index.html",
          "language": "javascript",
          "value": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n  <link rel=\"stylesheet\" href=\"index.css\" />\n</head>\n<body>\n  <!-- \n    1. DOM\n    2. HTML5  拖拽的API\n       dragstart dragend\n       dragover  dragenter\n       dragleave \n   -->\n  <div class=\"draggable-list-wrapper\"></div>\n\n  <script src=\"index.js\"></script>\n</body>\n</html>"
        },
        {
          "label": "index.css",
          "language": "javascript",
          "value": "ul {\n  padding: 0;\n  margin: 0;\n  list-style: none;\n}\n\np {\n  margin: 0;\n}\n\n.draggable-list-wrapper {\n  width: 500px;\n  margin: 50px auto;\n  box-shadow: 1px 3px 5px #999;\n  background-color: #fff;\n  padding: 10px 30px 30px;\n}\n\n.draggable-item {\n  height: 50px;\n  line-height: 50px;\n  border: 1px solid #ddd;\n  margin-top: 20px;\n  padding: 0 15px;\n}\n\n.dragging {\n  opacity: 0;\n}"
        },
        {
          "label": "index.js",
          "language": "javascript",
          "value": "const listData = [\n  '111111111111111',\n  '222222222222222',\n  '333333333333333',\n  '444444444444444'\n];\n//建立一个模块，不需要多次执行，只执行一次\n;(() => {\n  const oWrapper = document.querySelector('.draggable-list-wrapper');\n\n  const init = () => {\n    render();\n    bindEvent();\n  }\n\n  function render () {\n    const oList = createList();\n    oWrapper.appendChild(oList);\n  }\n\n  function bindEvent () {\n    const oDraggableList = oWrapper.querySelector('.draggable-list');\n    const oDraggableItems = oDraggableList.querySelectorAll('.draggable-item');\n    \n     //事件冒泡不会被阻止（false表示事件不会被捕获或停止传播）\n    oDraggableList.addEventListener('dragover', handleDragOver, false);\n    window.addEventListener('dragover', (e) => e.preventDefault(), false);\n    oDraggableList.addEventListener('dragenter', (e) => e.preventDefault(), false);\n    window.addEventListener('dragenter', (e) => e.preventDefault(), false);\n\n    oDraggableItems.forEach(item => {\n      item.addEventListener('dragstart', handleDragStart, false);\n      item.addEventListener('dragend', handleDragEnd, false);\n    })\n  }\n\n  function handleDragStart () {\n    const item = this;\n    setTimeout(() => item.classList.add('dragging'), 0);\n  }\n\n  function handleDragEnd () {\n    const item = this;\n    item.classList.remove('dragging');\n  }\n\n  function handleDragOver (e) {\n    e.preventDefault();\n\n    const oDraggableList = this;\n\n    const oDraggingItem = oDraggableList.querySelector('.dragging');\n    const oSibItems = oDraggableList.querySelectorAll('.draggable-item:not(.dragging)');\n    const oSibItem = [...oSibItems].find(item => e.clientY <= item.offsetTop + item.offsetHeight / 2);\nclassName\n    oDraggableList.insertBefore(oDraggingItem, oSibItem);\n  }\n\n  function createList () {\n    const oDraggableList = document.createElement('ul');\n    oDraggableList.className = 'draggable-list';\n    \n    //使用forEach循环遍历listData数组中的每个元素，对于每个元素都创建一个li元素（oItem）;该代码段最终的作用是在oDraggableList列表中动态地添加了多个带有item信息的可拖动的 li元素\n    listData.forEach(item => {\n      const oItem = document.createElement('li');\n      oItem.className = 'draggable-item';\n      oItem.draggable = true;\n      oItem.innerHTML = `<p>${ item }</p>`;\n      oDraggableList.appendChild(oItem);\n    });\n\n    return oDraggableList;\n  }\n\n  init();\n\n})();"
        }
      ],
      "id": "2g0UUClo",
      "createdAt": 1682909053387,
      "updatedAt": 1682912760907
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": "该文介绍了一个名为“store”的变量，其中包含一个函数add和两个属性nextId和cache。函数add用于将函数添加到cache中以便缓存并返回true，同时会分配一个唯一的id。如果函数已经存在（根据其id判断），则不再添加并返回false。",
      "name": "存储唯一函数集合",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "//其中包含一个函数add和两个属性nextId和cache,核心理解：函数也是可以动态添加属性的\nvar store = {\n//跟踪下一个要被赋值的Id\n  nextId: 1,\n//使用一个对象作为缓存,在其中存储函数\n  cache: {},\n  //仅当函数唯一时,将该函数加入缓存\n  add: function (fn) {\n    if (!fn.id) {\n      //给函数动态添加属性\n      fn.id = this.nextId++;\n      this.cache[fn.id] = fn;\n      return true;\n    }\n  },\n};\nfunction ninja() {}\n//assert(store.add(ninja), 'Function was safely added.');\n//assert(!store.add(ninja), 'But it was only added once.');\nstore.add(ninja)"
        }
      ],
      "id": "SJQ2R0Qg",
      "createdAt": 1683173567406,
      "updatedAt": 1690788522956
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "获取数据类型",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "如何通过函数获取变量的数据类型？\n\nconst getType = (value) => {\n  const match = Object.prototype.toString.call(value).match(/ (\\w+)]/)\n  return match[1].toLocaleLowerCase()\n}\n\ngetType() // undefined\ngetType({}}) // object\ngetType([]) // array\ngetType(1) // number\ngetType('fatfish') // string\ngetType(true) // boolean\ngetType(/fatfish/) // regexp"
        }
      ],
      "id": "O8i-87bE",
      "createdAt": 1683183296670,
      "updatedAt": 1683183312174
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "设置cookies",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "设置cookies：cookie 可能是我见过的最糟糕的 API，它太难用了，我们不得不重新封装它以最大限度地提高我们的开发效率。\n\nconst setCookie = (key, value, expire) => {\n  const d = new Date();\n  d.setDate(d.getDate() + expire);\n  document.cookie = `${key}=${value};expires=${d.toUTCString()}`;\n};\n\n获取 cookie：除了写入cookie之外，我们还会参与到它的读取操作中。\n\nconst getCookie = (key) => {\n  const cookieStr = unescape(document.cookie);\n  const arr = cookieStr.split(\"; \");\n  let cookieValue = \"\";\n  for (let i = 0; i < arr.length; i++) {\n    const temp = arr[i].split(\"=\");\n    if (temp[0] === key) {\n      cookieValue = temp[1];\n      break;\n    }\n  }\n  return cookieValue;\n};\n\n删除 cookie:删除cookie的想法是什么？其实只要把它的过期时间设置到这个时刻，它就会立即过期。\n\nconst delCookie = (key) => {\n  document.cookie = `${encodeURIComponent(key)}=;expires=${new Date()}`;\n};"
        }
      ],
      "id": "k2U-hjYo",
      "createdAt": 1683183363559,
      "updatedAt": 1683183489863
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "生成随机字符串",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "生成随机字符串:不知道大家有没有遇到过需要生成随机字符串的场景。我遇到过很多次，每次都要重新google一遍，直到学会这个工具功能。\n\nconst randomString = (len) => {\n  let chars = \"ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz123456789\";\n  let strLen = chars.length;\n  let randomStr = \"\";\n  for (let i = 0; i < len; i++) {\n    randomStr += chars.charAt(Math.floor(Math.random() * strLen));\n  }\n  return randomStr;\n};\n\nrandomString(10) // pfkMfjEJ6x\nrandomString(20) // ce6tEx1km4idRNMtym2S\n\n生成指定范围内的随机数:可能出于测试目的，我经常需要生成一定范围内的随机数。\n\nconst randomNum = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n\nrandomNum(1, 10) // 6\nrandomNum(10, 20) // 11\n\n从数组中获取一个随机值:之前做过一个抽奖项目，需要让数组中的奖品随机出现。\n\nconst getRandomValue = array => array[Math.floor(Math.random() * array.length)]; \nconst prizes = [  '$100', '🍫', '🍔' ]\n\ngetRandomValue(prizes) // 🍫\ngetRandomValue(prizes) // 🍔\ngetRandomValue(prizes) // 🍫"
        }
      ],
      "id": "EpSY4vj6",
      "createdAt": 1683183516150,
      "updatedAt": 1683183656341
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "自记忆函数",
      "content": [
        {
          "label": "函数和其他对象类型的相似之处",
          "language": "javascript",
          "value": "也许让你感到惊讶的相似之处在于我们可以给函数添加属性,因为函数可以做对象能做的任何事情\n//创建新对象并为其分配一个新属性\nvar ninja = {};\nninja.name = \"hitsuke\";\n\n//创建新函数并为其分配一个新属性\nvar wieldSword = function(){};\nwieldSword.swordType = \"katana\";\n\n我们再来看看这种特性所能做的更有趣的事：\n● 在集合中存储函数使我们轻易管理相关联的函数。例如，某些特定情况下必须\n调用的回调函数。\n● 记忆让函数能记住上次计算得到的值，从而提高后续调用的性能。\n"
        },
        {
          "label": "Fragment 2",
          "language": "javascript",
          "value": ""
        }
      ],
      "id": "qN1ThAkV",
      "createdAt": 1683191590615,
      "updatedAt": 1683191843441
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "函数是第一类对象",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "JavaScript 中函数拥有对象的所有能力，也因此函数可被作为任意其他类型对象来对待。当我们说函数是第一类对象的时候，就是说函数也能够实现以下功能。\n\n● 通过字面量创建：\n  function ninjaFunction() {}\n  \n● 赋值给变量，数组项或其他对象的属性\n\tvar ninjaFunction = function() {};\n  ninjaArray.push(function(){});\n  ninja.data = function() {}; //给某个对象的属性赋值为一个新函数\n  \n● 作为函数的参数来传递\n  function call(ninjaFunction){\n    ninjaFunction();\n  }\n  call(function(){}); //一个新函数作为参数传递给函数\n  \n● 作为函数的返回值。\n  function returnNewNinjaFunction() {\n    return function() {}; //返回一个新函数\n  }"
        }
      ],
      "id": "ekTguYOA",
      "createdAt": 1683192993006,
      "updatedAt": 1683193405066
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [],
      "description": "给vue页面添加一个背景，可是在样式中添加了背景图片后，编译打包后，配置到服务器上时，由于路径解析的问题，图片并不能够正确的显示出来，如下CSS样式：background:url(\"../../assets/login.jpg\")，因此必须换一种方法，以下是百度得来并实践可行的两种方法",
      "name": "给vue页面添加背景图片",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "<div class=\"login\" :style =\"login\"></div>\n\nexport default {\n  name：'login',\n  data () {\n    return () {\n        login: {\n            backgroundImage: `url(${require('@/assets/images/bg.png')})`,\n            backgroundRepeat: 'no-repeat',\n            backgroundPosition: 'top'\n        }\n   }\n}}"
        }
      ],
      "id": "a79CjAzj",
      "createdAt": 1683774739056,
      "updatedAt": 1683774873818
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3BVGYMMN",
      "tagsIds": [],
      "description": null,
      "name": "微软雅黑字体",
      "content": [
        {
          "label": "Fragment 1",
          "language": "css",
          "value": " font-family: \"Microsoft YaHei\"\n  font-family: Microsoft YaHei UI, Microsoft YaHei UI-Regular;\n"
        }
      ],
      "id": "P-ZKOCqP",
      "createdAt": 1683776214358,
      "updatedAt": 1683776230612
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [
        "MapSWFq2",
        "KQaIthCu"
      ],
      "description": "搜索的功能方法不用写，是用后端给的filter字段去筛选即可；",
      "name": "搜索后台数据列表项",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "<template>\n  <div class=\"content\">\n    <el-form ref=\"form\" :model=\"searchForm\" :rules=\"formRules\" class=\"search-form\" inline>\n      <el-form-item prop=\"formItem\">\n        <el-select v-model=\"searchForm.unitname\" clearable placeholder=\"请选择产品\">\n          <el-option\n            v-for=\"option in options\"\n            :key=\"option.value\"\n            :label=\"option.label\"\n            :value=\"option.value\"\n          />\n        </el-select>\n      </el-form-item>\n      <el-form-item prop=\"formItem\">\n        <el-input v-model=\"searchForm.username\" placeholder=\"请输入用户\" clearable />\n      </el-form-item>\n      <el-form-item prop=\"formItem\">\n        <el-input v-model=\"searchForm.type\" placeholder=\"请输入类型\" clearable />\n      </el-form-item>\n      <el-form-item prop=\"formItem\">\n        <el-input v-model=\"searchForm.content\" placeholder=\"请输入日志内容\" clearable />\n      </el-form-item>\n      <el-form-item prop=\"formItem\" class=\"datePick\">\n        <el-date-picker\n          v-model=\"searchForm.createTime\"\n          placeholder=\"请选择时间\"\n          type=\"datetimerange\"\n          start-placeholder=\"开始日期\"\n          end-placeholder=\"结束日期\"\n          :default-time=\"['12:00:00']\"\n          clearable\n        />\n      </el-form-item>\n      <el-form-item prop=\"formItem\">\n        <el-button type=\"primary\" @click=\"search\">查询</el-button>\n      </el-form-item>\n    </el-form>\n    <el-alert\n      v-if=\"!pageList.data || pageList.data.length === 0 || pageList.data.length === null || pageList.data.length === undefined\"\n      title=\"数据不存在\"\n      type=\"info\"\n      description=\"当前条件下没有查询到任何数据\"\n      show-icon\n      center\n    />\n    <el-table\n      ref=\"table\"\n      v-loading=\"loading\"\n      border\n      :data=\"pageList.data\"\n      class=\"atone-tbl\"\n      :max-height=\"tblHeight\"\n      size=\"middle\"\n    >\n      <el-table-column fixed type=\"selection\" />\n      <el-table-column prop=\"unitname\" label=\"产品\" min-width=\"40px\" />\n      <el-table-column prop=\"username\" label=\"用户\" min-width=\"40px\" />\n      <el-table-column prop=\"type\" label=\"类型\" min-width=\"40px\" />\n      <el-table-column prop=\"content\" label=\"日志内容\" min-width />\n      <el-table-column prop=\"createTime\" label=\"时间\" min-width=\"40px\">\n        <template slot-scope=\"scope\">\n          {{ dateFormat(scope.row.createTime) }}\n        </template>\n      </el-table-column>\n      <el-table-column prop=\"comment\" label=\"备注\" min-width=\"50px\" />\n    </el-table>\n    <el-pagination\n      :current-page.sync=\"pageRequest.pageNum\"\n      :page-sizes=\"[2,10, 20, 50, 100]\"\n      :page-size=\"pageRequest.pageSize\"\n      layout=\"total, sizes, prev, pager, next, jumper\"\n      :total=\"pageList.total\"\n      background\n      :pager-count=\"7\"\n      @size-change=\"sizeChange\"\n      @current-change=\"currentChange\"\n    />\n  </div>\n</template>\n\n<script>\nimport { timeToYYYYMMDDHHmmss } from '@/utils/date'\nimport * as useApi from '@/api/user'\nexport default {\n  name: 'User',\n  data() {\n    return {\n      options: [{\n        value: 'dbone',\n        label: 'dbone'\n      }, {\n        value: 'idb',\n        label: 'idb'\n      }, {\n        value: 'graphone',\n        label: 'graphone'\n      }],\n      tblHeight: 400,\n      loading: false,\n      pageRequest: {\n        'page': 1,\n        'pageSize': 10,\n        'planType': null,\n        'filter': {\n          'unitId': '8dd94f4607c446feb27db84943feb1c1',\n          'parentId': '37ca91777b2a4a6ca2b2846f9852e78a',\n          'name': '',\n          'content': 'key'\n        }\n      },\n      pageList: {\n        pageNum: 1,\n        pageSize: 5,\n        total: 0,\n        data: []\n      },\n      searchForm: {\n        unitname: '',\n        username: '',\n        type: '',\n        content: '',\n        createTime: []\n      },\n      formRules: {\n        unitname: [\n          { required: true, message: '请选择产品', trigger: 'change' }\n        ]\n      }\n    }\n  },\n  mounted() {\n    // 获取容器当前高度，重设表格的最大高度\n    this.getTableMaxHeight()\n    window.onresize = function() { // 用于使表格高度自适应的方法\n      this.getTableMaxHeight() // 获取容器当前高度，重设表格的最大高度\n    }\n    this.getList()\n  },\n  methods: {\n    // 获取容器当前高度，重设表格的最大高度\n    getTableMaxHeight() {\n      this.$nextTick(function() {\n        this.tblHeight = document.documentElement.clientHeight - 220\n      })\n    },\n    dateFormat(date) {\n      return timeToYYYYMMDDHHmmss(date)\n    },\n    getList() {\n      this.pageRequest.order = 'ASC'\n      this.loading = true\n      this.pageRequest.order = 'ASC'\n      this.loading = true\n      useApi.logManage(this.pageRequest)\n        .then(res => {\n          if (res.code === '0') {\n            if (res.data.data && res.data.data.length > 0) {\n              this.pageList.data = res.data.data\n              this.pageList.total = res.data.totalCount\n              console.log('%c this.pageList.data', 'background:yellow', this.pageList.data, this.pageList.data[2].type)\n            } else {\n              this.pageList.data = []\n              this.pageList.total = 0\n            }\n          } else {\n            this.pageList.data = []\n            this.pageList.total = 0\n          }\n          this.loading = false\n        })\n        .catch(err => {\n          console.log(err)\n          this.loading = false\n          this.pageList.data = []\n          this.pageList.total = 0\n        })\n    },\n    onRefresh() {\n      this.getList()\n    },\n    search() {\n      //表单验证-不能全部为空\n      if (!this.searchForm.unitname && !this.searchForm.username && !this.searchForm.type && !this.searchForm.content && (!this.searchForm.createTime || this.searchForm.createTime.length === 0)) {\n        this.$message.warning('请至少选择一个搜索条件')\n        return\n      }\n      const [startTime, endTime] = this.searchForm.createTime.map(time => timeToYYYYMMDDHHmmss(time))\n      this.pageRequest.filter = {\n        // unitId: '8dd94f4607c446feb27db84943feb1c1',\n        // parentId: '37ca91777b2a4a6ca2b2846f9852e78a',\n        unitname: this.searchForm.unitname,\n        username: this.searchForm.username,\n        type: this.searchForm.type,\n        content: this.searchForm.content,\n        createTime: startTime, // 注意这里是单独的字段，不是对象，根据是后台给个字段类型\n        comment: this.searchForm.comment\n      }\n      this.pageRequest.startTime = startTime\n      this.pageRequest.endTime = endTime\n      this.pageRequest.pageNum = 1\n      // this.pageRequest.pageSize = 0 // 如果不传这个参数，后端接口会使用默认值\n      // this.pageRequest.search = '' // 如果不传这个参数，后端接口会使用默认值\n      this.$refs.table.clearSelection()\n      this.getList()\n    },\n    sizeChange(val) {\n      this.pageRequest.pageSize = val\n      this.getList()\n    },\n    currentChange(val) {\n      this.pageRequest.pageNum = val\n      this.getList()\n    }\n  }\n}\n</script>\n<style lang=\"less\" scoped>\n/deep/.el-input__inner {\n  width: 160px;\n}\n/deep/.datePick .el-input__inner {\n  width:inherit;\n}\n/deep/.el-table{\n  overflow: hidden;\n}\n</style>\n\n"
        }
      ],
      "id": "gWUSHIce",
      "createdAt": 1683799993137,
      "updatedAt": 1683800215058
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [
        "0DVV1_vt",
        "F3iRFiaA"
      ],
      "description": null,
      "name": "引跑218项目路由配置",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "//若依系统的路由配置\nimport Vue from \"vue\";\nimport Router from \"vue-router\";\nimport Main from \"../views/Main.vue\";\nimport sinaMiliary from \"../views/internet/sina/sinaMain.vue\";\nimport mineindex from \"../views/mine/setting\";\n// Vue.use(VueRouter);\nVue.use(Router);\n\n/**\n * Note: 路由配置项\n *\n * hidden: true                     // 当设置 true 的时候该路由不会再侧边栏出现 如401，login等页面，或者如一些编辑页面/edit/1\n * alwaysShow: true                 // 当你一个路由下面的 children 声明的路由大于1个时，自动会变成嵌套的模式--如组件页面\n *                                  // 只有一个时，会将那个子路由当做根路由显示在侧边栏--如引导页面\n *                                  // 若你想不管路由下面的 children 声明的个数都显示你的根路由\n *                                  // 你可以设置 alwaysShow: true，这样它就会忽略之前定义的规则，一直显示根路由\n * redirect: noRedirect             // 当设置 noRedirect 的时候该路由在面包屑导航中不可被点击\n * name:'router-name'               // 设定路由的名字，一定要填写不然使用<keep-alive>时会出现各种问题\n * query: '{\"id\": 1, \"name\": \"ry\"}' // 访问路由的默认传递参数\n * roles: ['admin', 'common']       // 访问路由的角色权限\n * permissions: ['a:a:a', 'b:b:b']  // 访问路由的菜单权限\n * meta : {\n    noCache: true                   // 如果设置为true，则不会被 <keep-alive> 缓存(默认 false)\n    title: 'title'                  // 设置该路由在侧边栏和面包屑中展示的名字\n    icon: 'svg-name'                // 设置该路由的图标，对应路径src/assets/icons/svg\n    breadcrumb: false               // 如果设置为false，则不会在breadcrumb面包屑中显示\n    activeMenu: '/system/user'      // 当路由设置了该属性，则会高亮相对应的侧边栏。\n  }\n */\n// 公共路由\nexport const constantRoutes = [];\nlet routes = [\n  {\n    path: \"/im/home\",\n    component: () => import(\"@/views/im/home2\"),\n  },\n  {\n    path: \"/test\",\n    component: () => import(\"@/views/test\"),\n  },\n  {\n    path: \"/pathRedirect\",\n    name: \"pathRedirect\",\n    meta: {\n      index: 2,\n    },\n    component: () => import(\"@/views/login/pathRedirect\"),\n  },\n  {\n    path: \"/\",\n    redirect: \"/index\",\n    name: \"Main\", // 路由名称\n    component: Main, // 组件对象\n    children: [\n      {\n        path: \"/index\",\n        name: \"index\",\n        meta: {\n          index: 1,\n          keepAlive: true,\n        },\n        component: () => import(\"@/views/home/index\"),\n      },\n      {\n        path: \"/index_old\",\n        name: \"index_old\",\n        meta: {\n          index: 1,\n          keepAlive: true,\n        },\n        component: () => import(\"@/views/home\"),\n      },\n      {\n        path: \"/zl\",\n        name: \"specialColumn\",\n        meta: {\n          index: 1,\n          keepAlive: true,\n        },\n        component: () => import(\"@/views/specialColumn/index\"),\n      },\n      {\n        path: \"/course\",\n        name: \"course\",\n        /*meta: {\n          index: 1,\n          keepAlive: true,\n        },*/\n        component: () => import(\"@/views/course\"),\n      },\n      //虚拟因特网\n      {\n        path: \"/internet/index\",\n        name: \"internet\",\n        meta: {\n          index: 1,\n          keepAlive: true,\n        },\n        component: () => import(\"@/views/internet\"),\n      },\n      {\n        path: \"/resource/index\",\n        name: \"resource\",\n        meta: {\n          index: 1,\n          keepAlive: true,\n          activeMenu: \"/resource/index\",\n        },\n        component: () => import(\"@/views/resource\"),\n        // children: [\n        //   {\n        //     path: \"/content/list\",\n        //     name: \"contentList\",\n        //     meta: {\n        //       index: 1,\n        //       keepAlive: true,\n        //     },\n        //     component: () => import(\"@/views/content/list\"),\n        //   },\n        // ],\n      },\n      {\n        path: \"/knowledge/encyclopedia\",\n        name: \"encyclopedia\",\n        meta: {\n          index: 1,\n          keepAlive: true,\n        },\n        component: () => import(\"@/views/knowledge/encyclopedia.vue\"),\n      },\n      {\n        path: \"/knowledge/encyclopedia2\",\n        name: \"encyclopedia2\",\n        meta: {\n          index: 1,\n          keepAlive: true,\n        },\n        component: () => import(\"@/views/knowledge/encyclopedia2.vue\"),\n      },\n      {\n        path: \"/knowledge/ency_detail\",\n        name: \"ency_detail\",\n        meta: {\n          index: 1,\n          keepAlive: true,\n        },\n        component: () => import(\"@/views/knowledge/ency_detail.vue\"),\n      },\n      {\n        path: \"/know\",\n        name: \"know\",\n        meta: {\n          index: 1,\n          keepAlive: true,\n        },\n        component: () => import(\"@/views/knowledge/encyclopedia_sub.vue\"),\n      },\n      {\n        path: \"/academic/index\",\n        name: \"academicindex\",\n        meta: {\n          index: 1,\n          keepAlive: true,\n        },\n        component: () => import(\"@/views/academic\"),\n      },\n      {\n        path: \"/academic/circles/:id\",\n        name: \"academiccircles\",\n        meta: {\n          index: 1,\n          keepAlive: true,\n        },\n        component: () => import(\"@/views/academic/circles.vue\"),\n      },\n      {\n        path: \"/academic/detail/:id/:columnId\",\n        name: \"academicDetail\",\n        meta: {\n          index: 1,\n          keepAlive: true,\n        },\n        component: () => import(\"@/views/academic/detail.vue\"),\n      },\n      {\n        path: \"resource/content/list\",\n        name: \"contentList\",\n        meta: {\n          index: 1,\n          keepAlive: true,\n        },\n        component: () => import(\"@/views/content/list\"),\n      },\n      {\n        path: \"/content/detail\",\n        name: \"detail\",\n        meta: {\n          index: 1,\n          keepAlive: true,\n        },\n        component: () => import(\"@/views/content/detail\"),\n      },\n      {\n        path: \"/search\",\n        name: \"search\",\n        meta: {\n          index: 1,\n          keepAlive: true,\n        },\n        component: () => import(\"@/views/search\"),\n      },\n      {\n        path: \"/subject/index\",\n        name: \"subject\",\n        meta: {\n          index: 1,\n          keepAlive: true,\n        },\n        component: () => import(\"@/views/subject\"),\n      },\n      {\n        path: \"/article\",\n        name: \"article\",\n        meta: {\n          index: 1,\n          keepAlive: true,\n        },\n        component: () => import(\"@/views/content/detail\"),\n      },\n      {\n        path: \"/pic\",\n        name: \"pic\",\n        meta: {\n          index: 1,\n          keepAlive: true,\n        },\n        component: () => import(\"@/views/home/components/Pic_detail\"),\n      },\n      {\n        path: \"/video\",\n        name: \"video\",\n        meta: {\n          index: 1,\n          keepAlive: true,\n        },\n        component: () => import(\"@/views/content/Video_detail\"),\n      },\n      // {\n      //   path: \"/clip\",\n      //   name: \"clip\",\n      //   meta: {\n      //     index: 1,\n      //     keepAlive: true,\n      //   },\n      //   component: () => import(\"@/views/home/components/Video_clips\"),\n      // },\n      {\n        path: \"/doc\",\n        name: \"docdetail\",\n        meta: {\n          index: 1,\n          keepAlive: true,\n        },\n        component: () => import(\"@/views/content/doc\"),\n      },\n      {\n        path: \"/attention\",\n        name: \"mineattention\",\n        meta: {\n          index: 1,\n          keepAlive: true,\n        },\n        component: () => import(\"@/views/content/list\"),\n      },\n      {\n        path: \"/mine/setting\",\n        name: \"mineindex\",\n        redirect: \"/mine/setting/mine\",\n        meta: {\n          index: 3,\n          keepAlive: true,\n        },\n        component: () => import(\"@/views/mine/setting\"),\n        children: [\n          {\n            path: \"/mine/setting/mine\",\n            name: \"mine\",\n            meta: {\n              index: 3,\n              keepAlive: true,\n            },\n            component: () => import(\"@/views/mine/setting/mine\"),\n          },\n          {\n            path: \"/mine/mySubscribe\",\n            name: \"mySubscribe\",\n            meta: {\n              index: 3,\n              keepAlive: true,\n            },\n            component: () => import(\"@/views/mine/mySubscribe\"),\n          },\n          {\n            path: \"/mine/myFeedback\",\n            name: \"myFeedback\",\n            meta: {\n              index: 3,\n              keepAlive: true,\n            },\n            component: () => import(\"@/views/mine/myFeedback\"),\n          },\n          {\n            path: \"/mine/academic/:type\",\n            name: \"academic\",\n            meta: {\n              index: 3,\n              keepAlive: true,\n            },\n            component: () => import(\"@/views/mine/setting/academic\"),\n          },\n          {\n            path: \"/mine/thumbsUp\",\n            name: \"thumbsUp\",\n            meta: {\n              index: 3,\n              keepAlive: true,\n            },\n            component: () => import(\"@/views/mine/setting/thumbsUp\"),\n          },\n          {\n            path: \"/mine/myfootprint\",\n            name: \"minefootprint\",\n            meta: {\n              index: 3,\n              keepAlive: true,\n            },\n            component: () => import(\"@/views/mine/setting/myfootprint\"),\n          },\n          {\n            path: \"/mine/collection\",\n            name: \"collection\",\n            meta: {\n              index: 3,\n              keepAlive: true,\n            },\n            component: () => import(\"@/views/mine/setting/collection\"),\n          },\n          {\n            path: \"/mine/VideoList\",\n            name: \"VideoList\",\n            meta: {\n              index: 3,\n              keepAlive: true,\n            },\n            component: () =>\n              import(\"@/views/mine/setting/components/VideoList\"),\n          },\n          {\n            path: \"/mine/knowledge\",\n            name: \"topicKnowledge\",\n            meta: {\n              index: 3,\n              keepAlive: true,\n            },\n            component: () => import(\"@/views/mine/setting/knowledge\"),\n          },\n        ],\n      },\n    ],\n  },\n  {\n    path: \"/knowledge/graph\",\n    component: () => import(\"@/views/knowledge/graph\"),\n  },\n  {\n    path: \"/screen\",\n    name: \"screen\",\n    meta: {\n      index: 1,\n      keepAlive: true,\n    },\n    component: () => import(\"@/views/home/components/Echarts/allScreen\"),\n  },\n  // sina military\n  {\n    path: \"/sinaMilitary\",\n    redirect: \"/sinaMilitary/sina\",\n    name: \"sinaMilitary\", // 路由名称\n    meta: {\n      index: 1,\n      keepAlive: true,\n    },\n    component: () => import(\"@/views/internet/sina/sinaMain.vue\"),\n    children: [\n      {\n        path: \"/sinaMilitary/sina\",\n        name: \"sina\",\n        meta: {\n          index: 1,\n          keepAlive: true,\n        },\n        component: () => import(\"@/views/internet/sina\"),\n      },\n      {\n        path: \"/sinaMilitary/china_info\",\n        name: \"china_info\",\n        meta: {\n          index: 1,\n          keepAlive: true,\n        },\n        component: () => import(\"@/views/internet/sina/subPage/china_info\"),\n      },\n    ],\n  },\n  // internet site\n  {\n    path: \"/internet/site\",\n    redirect: \"/internet/site\",\n    name: \"internet-site\", // 路由名称\n    meta: {\n      index: 1,\n      keepAlive: true,\n    },\n    component: () => import(\"@/views/internet/site\"),\n    children: [\n      {\n        path: \"/internet/site/:alias\",\n        name: \"internet-site-item\",\n        meta: {\n          index: 1,\n          keepAlive: true,\n        },\n        component: () => import(\"@/views/internet/site/components/Main.vue\"),\n      },\n      {\n        path: \"/internet/site/:alias/:sub\",\n        name: \"internet-site-sub-item\",\n        meta: {\n          index: 1,\n          keepAlive: true,\n        },\n        component: () => import(\"@/views/internet/site/sub\"),\n      },\n    ],\n  },\n];\nconst routerContext = require.context(\"./modules\", true, /\\.js$/);\nrouterContext.keys().forEach((route) => {\n  const routerModule = routerContext(route);\n  /**\n   * 兼容 import export 和 require module.export 两种规范\n   */\n  routes = [...routes, ...(routerModule.default || routerModule)];\n});\n\nconst originalPush = Router.prototype.push;\nRouter.prototype.push = function push(location) {\n  return originalPush.call(this, location).catch((err) => err);\n};\n\n// 动态路由，基于用户权限动态去加载\nexport const dynamicRoutes = [];\n\nconst router = new Router({\n  mode: \"history\",\n  routes: routes,\n  linkActiveClass: \"is-active\",\n  scrollBehavior(to, from, savedPosition) {\n    if (savedPosition) {\n      return savedPosition;\n    } else {\n      return {\n        x: 0,\n        y: 0,\n      };\n    }\n  },\n});\n\nexport default router;\n"
        }
      ],
      "id": "jV8X96in",
      "createdAt": 1684203943721,
      "updatedAt": 1684204005574
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "CIqaS_Yh",
      "tagsIds": [],
      "description": null,
      "name": "日期使用动态值",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "<template>\n  <div>\n    <div id=\"bar_1\" style=\"width: 100%; height: 300px\"></div>\n  </div>\n</template>\n\n<script>\nimport moment from 'moment'\n\nexport default {\n  methods: {\n    echarts_1() {\n      var myChart = this.$echarts.init(document.getElementById('bar_1'))\n      // 获取当前日期和前6天日期\n      var now = moment()\n      var dates = []\n      for (var i = 6; i >= 0; i--) {\n        var date = now.clone().subtract(i, 'days')\n        dates.push(date.format('M-D'))\n      }\n       // 指定图表的配置项和数据\n      var option = {\n        yAxis: {\n          type: 'category',\n          data: dates  //这里使用当前日期和前6天日期\n        },\n      \n ..."
        }
      ],
      "id": "i6EuqACf",
      "createdAt": 1684552902314,
      "updatedAt": 1684553137939
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [
        "ap7EPQjh",
        "U4R_iTAE",
        "LWxPHcOo"
      ],
      "description": null,
      "name": "路径判断",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "// 排除一个路径，如首页\nv-if和v-show的区别：\n注意：v-if决定dom元素是否存在，而v-show是隐藏和显示\n\n<div v-show=\"$route.path !== '/index'\">\n      <portalMenu></portalMenu>\n</div>\n\n//同一个div容器，路径不同样式不同\n<div class=\"main-container\" :style=\"{'margin-left': $route.path === '/index' ? '12px' : '200px'}\">"
        },
        {
          "label": "引跑星光项目隐藏二级菜单",
          "language": "plain_text",
          "value": " <sidebar v-show=\"shouldShowSidebar\" class=\"sidebar-container\" />\n "
        },
        {
          "label": "Fragment 3",
          "language": "javascript",
          "value": " <sidebar v-show=\"shouldShowSidebar\" class=\"sidebar-container\" />\n \n<div :class=\"{ hasTagsView: needTagsView }\" class=\"main-container\" :style=\"styles\">\n   <app-main :style=\"isDeductionUrl ? 'padding-top:0' : ''\" />\n</div>\n\ncomputed: {\n  styles() {\n      let res = \"\";  //先定义一个之后要返回的变量res,存储css属性margin-left的值\n      if (this.isDeductionRealUrl || this.isReportUrl) {\n        res = \"margin-left:12px\";\n      } else if (this.isDeductionUrl) {\n        res = \"margin-left: 1px ; margin-top: 1px; padding-top: 0;\";\n      } else {\n        res = \"margin-left:200px\";\n      }\n      return res;\n    },\n    \n    isDeductionUrl() {\n      return this.$route.path.endsWith(\"/deduction/detail\");\n    },\n    isDeductionRealUrl() {\n      return this.$route.path.endsWith(\"/deduction/real\");\n    },\n    isReportUrl() {\n      return this.$route.path.endsWith(\"/report/index\");\n    },\n  },\n}\n "
        }
      ],
      "id": "_4zn4SsK",
      "createdAt": 1684725573866,
      "updatedAt": 1699757074472
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "递归",
      "content": [
        {
          "label": "递归函数遍历DOM",
          "language": "javascript",
          "value": "<div id=\"subTree\">\n  <form>\n \t\t <input type=\"text\"/>\n  </form>\n  <p>Paragraph</p>\n  <span>Span</span>\n</div>\n\n<script>\n  function traverseDOM(element, callback) {\n    //用回调函数处理当前节点\n    callback(element);\n    element = element.firstElementChild;\n    //遍历每个子树\n    while (element) {\n      traverseDOM(element, callback);\n      element = element.nextElementSibling;\n    }\n  }\n  const subTree = document.getElementById(\"subTree\");\n  //通过调用travenscDOM 方法从根节点开始遍历\n  traverseDOM(subTree, function(element) {\n  \tassert(element !== null, element.nodeName);\n  });\n</script>"
        },
        {
          "label": "将树形结构的数量展示到页面",
          "language": "javascript",
          "value": "//在前端代码中，使用递归函数遍历树形结构，计算节点数量。将计算出的节点数量展示到页面中。\n// 递归函数，用于遍历树形结构并计算节点数量\nfunction countNodes(node) {\n  let count = 1; // 当前节点算一个\n  if (node.children && node.children.length > 0) { // 如果有子节点\n    for (let i = 0; i < node.children.length; i++) { // 遍历子节点\n      count += countNodes(node.children[i]); // 递归计算子节点数量\n    }\n  }\n  return count;\n}\n\n// 在页面中展示节点数量\nlet rootNode = { // 树形结构的根节点\n  name: 'root',\n  children: [\n    { name: 'child1' },\n    { name: 'child2', children: [\n      { name: 'grandchild1' },\n      { name: 'grandchild2' }\n    ]},\n    { name: 'child3' }\n  ]\n};\nlet nodeCount = countNodes(rootNode); // 计算节点数量\ndocument.getElementById('nodeCount').innerText = nodeCount; // 将节点数量展示到页面中\n\n在上面的代码中，我们定义了一个递归函数countNodes，用于遍历树形结构并计算节点数量。该函数接受一个节点作为参数，如果该节点有子节点，则遍历子节点并递归调用countNodes函数来计算子节点数量。最终返回的数量是当前节点数量加上所有子节点数量。\n\n在页面中，我们可以将树形结构的根节点传递给countNodes函数来计算节点数量，然后将计算出的数量展示到页面中。在上面的代码中，我们使用了一个div元素来展示节点数量，其id为nodeCount。我们通过document.getElementById('nodeCount')获取该元素，并将计算出的节点数量赋值给其innerText属性来展示节点数量。\n\n如果你需要将节点数量展示在树形结构上，可以在遍历树形结构时，将节点数量保存在节点的某个属性中，然后在渲染节点时，将该属性的值展示出来。\n"
        },
        {
          "label": "不用循环计算数组的累加值",
          "language": "javascript",
          "value": "var nums = [5,1,3,6,2];\n\nfunction f(i) {\n    //i >= nums.length为终止条件；f(i + 1)是个有返回值的函数,每次会有一个返回值\n    return i >= nums.length ? 0 : nums[i] + f(i + 1);\n}\n\nconsole.log(f(0));\n/*\n首次调用f(0)时，当前索引i为0，不满足终止条件，进入递归调用。\n在第一次递归调用f(1)时，当前索引i为1，不满足终止条件，继续递归调用。\n在第二次递归调用f(2)时，当前索引i为2，不满足终止条件，继续递归调用。\n在第三次递归调用f(3)时，当前索引i为3，不满足终止条件，继续递归调用。\n在第四次递归调用f(4)时，当前索引i为4，不满足终止条件，继续递归调用。\n在第五次递归调用f(5)时，当前索引i为5，满足终止条件，返回0。\n\n然后，开始回溯计算结果。\n在第四次递归调用中，将返回的0与nums[4]相加，得到2 + 0 = 2，并返回该结果。\n在第三次递归调用中，将返回的2与nums[3]相加，得到6 + 2 = 8，并返回该结果。\n在第二次递归调用中，将返回的8与nums[2]相加，得到3 + 8 = 11，并返回该结果。\n在第一次递归调用中，将返回的11与nums[1]相加，得到1 + 11 = 12，并返回该结果。\n最终，在第一次函数调用中，将返回的12与nums[0]相加，得到5 + 12 = 17。\n因此，console.log(f(0))会输出结果17。\n\n*/"
        }
      ],
      "id": "JPoYSV0T",
      "createdAt": 1684735267295,
      "updatedAt": 1693365804700
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "assert()断言函数",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "《JavaScript忍者秘籍》中的assert()断言函数是作者自己编写并使用的一个简单断言工具。它用于检查给定表达式的值是否为真，如果不是则抛出异常。断言函数通常在测试和调试代码时非常有用，它可以帮助开发人员快速发现问题所在，并及时采取措施修复。\n\n下面是assert()函数的基本语法：\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n}\n/*其中，condition参数是待检查的表达式，如果该表达式的值为false，则会抛出异常；message参数是可选的错误消息，用于描述断言失败的原因。\n例如，我们可以使用assert()函数来检测函数返回值是否符合预期：*/\n\nfunction addNumbers(x, y) {\n  return x + y;\n}\n// 检查addNumbers函数返回值是否为5\nassert(addNumbers(2, 3) === 5, \"加法计算错误\");\n\n/*在这个例子中，断言函数assert()将会检查addNumbers(2, 3)的返回值是否等于5，如果不是，则抛出异常并输出错误消息\"加法计算错误\"。\n\n需要注意的是，断言函数通常只在开发环境或测试环境中使用，并且应该在生产环境中移除。虽然断言能够帮助我们快速发现代码中的问题，但它也会影响性能，并且可能暴露敏感信息。因此，在生产环境中，我们通常会使用更加健壮和可靠的错误处理机制。"
        },
        {
          "label": "通过浏览器控制台打印断言Log",
          "language": "javascript",
          "value": "function greaterThan(x, y){\n\tconsole.assert(\n    //条件 ,只有 x < y 第二个参数才会输出\n  \tx > y,  \n    //message, 这里是json\n  \t{\"message\":\"x is not greater than y\", \"x\":x ,y\": y} \n  );\n}\ngreaterThan(4,5);"
        }
      ],
      "id": "MN4AipIH",
      "createdAt": 1684736188245,
      "updatedAt": 1688462237982
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [
        "XIITO5Tv"
      ],
      "description": null,
      "name": "动态class和样式",
      "content": [
        {
          "label": "动态 class",
          "language": "javascript",
          "value": "//动态:class的值将合并到静态class里成为：class=\"demo active\" 注意boxASelected是一个布尔值\n<div class=\"demo\" :class=\"{active: boxASelected}\" @click=\"boxSelected('A')\">\n//使用计算属性\n<div class=\"demo\" :class=\"boxBClasses\" @click=\"boxSelected('B')\">\n//如果boxASelected为true相当于 class=\"demo active\"\n<div :class=\"['demo',{active: boxASelected}]\" @click=\"boxSelected('C')\">\n\ndata(){\n  return{\n     boxASelected:false,\n     boxBSelected:false,\n     boxCSelected:false\n  }\n},\ncomputed:{\n  //如果有复杂的条件判断等，d可以用computed属性简化template的代码\n  boxBClasses(){\n   \t if(...) return{active: this.boxBSelected}\n  },\n  //根据条件设置一个样式为无或‘flat’\n  storedResButtonMode() {\n\t\treturn this.selectedTab ==='stored-resources' ? null : 'flat';\n},\nmethods:{\n  //true or flase 判断\n}"
        },
        {
          "label": "动态 :style",
          "language": "javascript",
          "value": "输入框输入色值改变页面元素样式\n\n<input type=\"text\" v-model=\"inputBackgroundColor\" />\n//注意：style里实际就是用的js的代码，所以css的属性名用驼峰格式不用background-color这样的写法\n<p :style=\"{backgroundColor: inputBackgroundColor}\"> style me </p>\n\ndata(){\n return{\n    inputBackgroundColor:''\n }\n}"
        }
      ],
      "id": "exRFnG4Q",
      "createdAt": 1684747582559,
      "updatedAt": 1685846553298
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [
        "7BPAbRet",
        "evMV3Veq",
        "94resVPE",
        "IlFuQhsy",
        "Ejq9XUle",
        "WS4qeyy8",
        "82l3EbqQ"
      ],
      "description": null,
      "name": "添加和删除元素",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "<template>\n  <section id='user-goals'>\n    <input type='text' v-model='enteredGoalValue'/>\n    <button @click='addGoal'> Add Goal </button>\n\n    //goals是数组所以有length属性可用,v-else必须直接在v-if后面\n    <p v-if='goals.length===0'> No goals have been added yet </p>\n    <ul v-else> \n       <li v-for=\"(goal,index) in goals\" @click='removeGoal(index)'> \n         <p> {{goal}} - {{index}} <p>\n         //用.stop阻止时间冒泡，就是要点击当前元素，和其他元素无关，不要有关联\n         <input type='text' @click.stop>\n       </li>\n    </ul>\n  </section>\n</template>\n\n<script>\n   data(){\n     return{\n        //enteredGoalValue是input里v-model的值\n        enteredGoalValue:'',\n        goals:[]\n     }\n   },\n  methods:{\n    addGoal(){\n      this.goals.push(this.enteredGoalValue)\n    },\n    //删除元素；idx是v-for传过来的index值\n    removeGoal(idx){\n      this.goals.splice(idex,1)\n    }\n  }\n</script>\n"
        },
        {
          "label": "v-for 遍历对象或数字",
          "language": "javascript",
          "value": "//遍历对象或数组(数组不用key)\n  <li v-for=\"(value, key,index) in {name: 'Max', age: 31}\"> {{value}} - {{key}} </li>\n\n  //遍历数字\n  <li v-for=\"num in 10\">{{num }}</li>"
        }
      ],
      "id": "jqCf8pXS",
      "createdAt": 1684810775638,
      "updatedAt": 1685158476781
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "kYeA3Yuv",
      "tagsIds": [
        "9HOc4GA1",
        "Rj0DhGLo",
        "UiLjTXux",
        "iZ0i6WtJ"
      ],
      "description": "在element ui 多选table的selection-change函数中判断，符合条件时当前行才能被选中如何实现？",
      "name": "符合条件时当前行才能被选中",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "在这个例子中，我们创建了一个表格，并通过@selection-change事件来监听用户选择行的变化。当用户选中或取消选中某一行时，会触发handleSelectionChange方法。其中，我们使用filter()方法来过滤出符合条件的行，并调用toggleRowSelection()方法来切换行的选择状态。\n需要注意的是，在组件内部使用this.$refs可以访问到组件的 DOM 元素。在上面的例子中，我们使用this.$refs.table来访问到表格组件的实例，并调用toggleRowSelection()方法来切换行的选择状态。\n\n<template>\n  <el-table :data=\"tableData\" @selection-change=\"handleSelectionChange\">\n    <el-table-column type=\"selection\"></el-table-column>\n    <el-table-column prop=\"name\" label=\"Name\"></el-table-column>\n    <el-table-column prop=\"age\" label=\"Age\"></el-table-column>\n  </el-table>\n</template>\n\n<script>\nexport default {\n  data () {\n    return {\n      tableData: [\n        { name: 'John', age: 20 },\n        { name: 'Tom', age: 25 },\n        { name: 'Mary', age: 30 }\n      ]\n    }\n  },\n  methods: {\n    handleSelectionChange(rows) {\n      // 断条件，例如只有年龄大于等于25的才能被选中\n      const selectedRows = rows.filter(row => row.age >= 25)\n      this.$refs.table.toggleRowSelection(selectedRows)\n    }\n  }\n}\n</script>"
        },
        {
          "label": "toggleRowSelection()方法是？",
          "language": "javascript",
          "value": "toggleRowSelection()是 Element UI 表格组件中的一个方法，用于切换表格行的选择状态。它可以接受一个参数 row，表示需要切换选择状态的行数据。以下是 toggleRowSelection() 方法的基本语法：\n\nthis.$refs.table.toggleRowSelection(row)\n\n这里的 $refs.table 是表格组件的引用名，通常在表格上添加了 ref 属性后可以通过 $refs.table 获取到表格组件的实例。\n当调用 toggleRowSelection() 方法时，会自动根据传入的行数据判断该行是否已经被选中，如果已经被选中则将其取消选择，否则将其选中。如果没有传入行数据，则会将所有行的选择状态全部切换一遍。\n需要注意的是，toggleRowSelection() 方法只能在表格组件实例上调用，而不能在表格列组件内部使用。如果需要在列组件内部控制表格行的选择状态，可以使用作用域插槽或者事件来实现对应的逻辑。"
        },
        {
          "label": "$refs的用法",
          "language": "javascript",
          "value": "<template>\n   //用v-model或$refs都能获取到值，但结果的类型会有不同，也可以这样写v-model.number\n  <input type='number' ref='ageInput' v-model='userAge'/>\n</template>\n\n<script>\ndata(){\n  return{\n   //注意数字类型可以先赋值为null\n    userAge:null,\n  }\n},\nmounted:{\n  //注意 $refs 的值是string,而v-model的值是number,在实际开发中容易出bug，注意打印查看结果的类型，输出的颜色也是不同的\n  console.log(this.$refs.ageInput.value + 5) //这里不是数字相加而会是字符串拼接\n}\n</script>\n\n"
        }
      ],
      "id": "SIoGN1I4",
      "createdAt": 1684897328911,
      "updatedAt": 1685884176752
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [
        "YMapeYW6",
        "kU7jx3aE",
        "5Dflw_1b",
        "Fcl20gmo",
        "QbBV4zvx",
        "eb97zzvl",
        "JKa1LBV-",
        "oahZqjuX",
        "EbtawnJh",
        "N9T0vt1r",
        "4_xeTOND",
        "u9pCoFM3"
      ],
      "description": "we can use props customize the behavior of a component similar to how HTML attributes change the behavior of an element\nprops is short for properties\n另外注意，在父组件定义回调函数，然后在子组件调用也可以实现$emit的功能，但用$emit更好些，在devtool里通过Timeline可以debug,回调函数不行",
      "name": "组件之间通信-1 子组件props、自定义事件",
      "content": [
        {
          "label": "friendContact.vue ---Child-1",
          "language": "vue",
          "value": "这个组件将父组件传递的数据展示出来，并向父组件发送自定义事件\n\nprops和data()里定义的数据是一样的，所以不能重名,可以对数据设置类型、初始值以及验证；\n如果要修改值，不能修改父级的原始值，但可以在data()里声明一个变量，将props的要修改的值赋给这个变量，然后修改这个变量即可\n\n<template>\n   <ul>\n     //props里的值和data里的用法一样，注意不用加this关键字,这里的值都是父组件通过v-for循环一个数组后传递过来的\n    <h2>{{name}}</h2>\n    <h2>{{...}}</h2>\n   </ul>\n    // $emit也可以写在这里, 和在methods里一样,注意在模板里是不用写this关键字的，直接用数据名\n  <button @click=\"$emit('delete',id)\"> Delete </button>\n</template>\n\n<script>\n  export default{\n     可以是数组的简单形式,或对象形式，可以更多的设置\n    //props:['name','phoneNumber',....]\n    //props是父组件传给子组件的，而emits是子组件传给父组件的\n    props:{\n     isFavoriate:{\n         type:String,\n          required:false,\n          default:'0',\n          validator(value){ //validator作为验证返回true或false\n            return value === '1' ||  value==='0';\n          }\n          /* validator(value){\n            return value < 130\n          } */\n      },\n      id:{\n \t\t\t\t type:String,\n         required:true,\n      },\n      name:{\n         type:String,\n         //required:true,\n         default:'okzu',\n      },\n     \n    },\n    //emits是自定义的事件\n    emits:['toggle-favorite','delete'], //这里不是必须的，但不加的的话控制台有报错\n    data(){\n      return{\n       通过这种形式改变props的值，注意这并没有改变父级的原始值, 所以才可以。\n       注意对props里值的引用，其实就是在引用data()里的值。\n       \n       Favoriate:this.isFavoriate\n      }\n    },\n    methods:{\n     toggleFavorite(){\n       $emit是内置的方法，在父元素可以直接通过v-on: (简写为@)进行事件监听接收 \n       $emit方法设置了一个自定义事件'toggle-favorite',第二个参数是传递的数据，当然参数可以更多，或者将若干值包裹在一个对象里...\n       \n       this.$emit('toggle-favorite',this.id)\n        \n       父元素用 @ 接收事件：@toggle-favorite = 'toggle-favoriteState'\n       \n        //父元素的friendId参数就是子元素发送过来的数据，可以有多个参数：\n         // toggleFavoriteStatus(friendId) { \n            //const findId = this.friends.find(friend => friend.id === friendId);\n            //identifiedFriend.isFavorite = !identifiedFriend.isFavorite;\n         //}\n     },\n     这个和上面模板里写的一个作用，只是不同的写法\n     deleteFriend() {\n        this.$emit('delete',this.id);\n      }     \n    }\n  }\n</script>"
        },
        {
          "label": "newFriend.vue ---Child-2",
          "language": "vue",
          "value": "//这个组件通过用户输入，利用自定义事件add-contact向父组件添加数据\n核心：this.$emit('自定义的事件名称',第二个参数是传递给父组件的数据)\n<template>\n    <form @submit.prevent='submitData'>\n        <input type='text' v-model='enteredName'/>\n        <input type='tel' v-model='enteredPhone'/>\n        <input type='email' v-model='enteredEmail'/>\n\n        <button>Add Contact</button>\n    </form>\n</template>\n\n<script>\n    export default {\n        emits: ['add-contact'],\n        data() {\n            return {\n              //绑定表单输入的数据,v-model的数据都要在data中声明\n               enteredName: '',\n               enteredPhone: '',\n               enteredEmail: ''\n            }\n        },\n        methods: {\n            //提交自定义事件,将表单v-model的数据通过参数传递出去\n            submitData() {\n                this.$emit('add-contact',this.enteredName, this.enteredPhone, this.enteredEmail)\n                // OR\n                // const contactData = {\n                //     name: this.enteredName,\n                //     phone: this.enteredPhone,\n                //     email: this.enteredEmail\n                // }\n                // this.$emit('add-contact', contactData)\n            }\n        },\n        \n    }\n</script>\n"
        },
        {
          "label": "Parent.vue",
          "language": "vue",
          "value": "//数据是从父组件通过props传递给子组件的\n<template>\n    <div>\n       //监听子组件自定义事件 add-contact\n       <new-friend @add-contact=\"addContact\"></new-friend>\n    </div>\n    <ul>\n      //friend-contact这个组件就是第一个标签页的子组件,注意v-for的用法,friends数组里的值是如何循环并传递给子组建的\n      <friend-contact\n          v-for=\"friend in friends\"\n          :key=\"friend.id\"\n          :id=\"friend.id\"\n          :name=\"friend.name\"\n          :phone-number=\"friend.phone\"\n          :email-address=\"friend.email\"\n          :is-favorite=\"friend.isFavorite\"\n          @toggle-favorite=\"toggleFavoriteStatus\"\n          @delete=\"deleteContact\"\n      >\n      </friend-contact>\n</template>\n\n<script>\n    export default {\n        data() {\n           return {\n            friends:[\n              {\n                id:'manuel',\n                name:'Lorenz',\n                phone:0123 45678 90,\n                email: 'manuel.com',\n                isFavorite:true\n              },\n              {...},\n              {...}\n            ]\n           }\n        },\n        methods: {\n            id是从子组件的自定义方法toggle-favorite的参数里传递过来的数据\n            toggleFavoriteStatus(id) {\n                const friend = this.friends.find(friend => friend.id === id)\n                friend.isFavorite = !friend.isFavorite\n            },\n            接收子组件自定义事件add-contact的参数里传递过来的数据\n            addContact(name, phone, email) {\n               const newContact = {\n                id: new Data().toISOString(),\n                name: name,\n                phone: phone,\n                email: email,\n                isFavorite: false\n               }\n               push一个对象进入friends数组\n               this.friends.push(newContact)\n            },\n            deleteContact(id){\n              通过覆盖原数组的方式删除数组中的某一项，之后重新渲染模板的friend-contact组件\n              this.friends = this.friends.filter(friend=>friend.id !== id)\n            }\n        }\n    }\n</script>"
        },
        {
          "label": "用props设置样式",
          "language": "javascript",
          "value": "子组件，用一个动态class接受父组件的数据\n\n<template>\n\t<button :class=\"mode\">\n     slot里也是显示父组件定义的内容\n     <slot></slot>\n  </button>\n</template>\n\n<script>\n  export default {\n     props: ['mode']\n  }\n</script>\n\n<style scoped>\n button {\n   ...\n }\n</style>\n\n\n//----------------------------------父组件,逻辑很简单, 把父组件的条件数据传递给子组件, 可以是样式也可以是数据\n<template>\n\t<button :mode='storedResButtonMode'>\n  </button>\n</template>\n\n<script>\n  data(){\n    return{\n       selectedTab:'stored-resources'\n    }\n  },\n  computed:{\n    根据条件设置一个样式为无或‘flat’\n    storedResButtonMode() {\n      return this.selectedTab ==='stored-resources' ? null : 'flat';\n    },\n</script>"
        }
      ],
      "id": "3X84iSe8",
      "createdAt": 1684986180885,
      "updatedAt": 1690449121340
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [],
      "description": null,
      "name": "provide & inject",
      "content": [
        {
          "label": "Fragment 1",
          "language": "vue",
          "value": "provide & inject 必须是父子关系;也可以用于事件,目的是避免跨越组件props的繁琐使用\nprovide & inject is a very helpful pattern if you want to avoid pass through componets and pass through props unnecessarily\n\n//父组件\n<script>\ndata(){\n return{\n     topics:{\n       ....\n    }\n  }\n},\nprovide(){\n  return{\n     topics.this.topics\n  }\n},\nmethods:{\n ...\n}\n\n</script>\n\n//在子组件：\n<script>\nexport default{\n  inject:['topics']\n}\n</script>"
        }
      ],
      "id": "dc1NcO_0",
      "createdAt": 1685093837135,
      "updatedAt": 1685158236469
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [
        "BBDSI8V5",
        "uoTqJWq5",
        "9H_WKuOk"
      ],
      "description": "provide/inject、props、slot有一个共同点就是父子组件之间的通信;\nprovide/inject是避免跨组件使用props的繁琐,两者都是对data数据的传输;\n而slot是提供html内容的出口,通过slot 我们可以在父组件为子组件添加内容",
      "name": "provide/inject 以及 slot 和 props的区别",
      "content": [
        {
          "label": "slot",
          "language": "vue",
          "value": "props are meant to  be used for data which a component needs;\nslot are meant to be used for html code for the template code a component needs,so here we just provide a shell with some styling we could also add some logic if this component needed to but we then allow the parent component to provide the html code that should be inside of that div,and that's the core idea behind slolts\n\nslot (父组件 在子组件<slot> </slot>处插入内容)\nVue 实现了一套内容分发的 API，将<slot>元素作为承载分发内容的出口, 这是vue文档上的说明:\n//子组件 ： (假设名为：ebutton)\n\n<template>\n   //注意 $slots 的用法\n  <div class= 'button' v-if='$slots.header'>\n      <button> </button>\n     <slot></slot>\n  //slot 可以放在任意位置，这个位置就是父组件添加内容的显示位置 \n  </div>\n</template>\n\n//父组件：（引用子组件 ebutton）\n<template>\n  <div class= 'app'>\n     <ebutton> {{ parent }}</ebutton>\n  </div>\n</template>\n<script>\n  data:{\n    parent:'父组件'\n  }\n</script>\n\n//++++++++ 有时没有在父组件内添加内容，那么slot就会显示默认值,父组件有内容会覆盖默认值,如：\n\n//子组件 ： (假设名为：ebutton)\n<template>\n  <div class= 'button'>\n      <button> </button>\n      <slot> 这就是默认值 </slot>\n  </div>\n</template>"
        },
        {
          "label": "通过作用域插槽从父组件获取子组件的数据",
          "language": "vue",
          "value": "\n作用域插槽 \n(父组件在子组件 <slot> </slot> 处使用子组件 data)\n\n通过slot 我们可以在父组件为子组件添加内容, 通过给slot命名的方式,我们可以添加不止一个位置的内容。但是我们添加的数据都是父组件内的。上面我们说过不能直接使用子组件内的数据,但是我们是否有其他的方法让我们能够使用子组件的数据呢？ 其实我们也可以使用v-slot的方式：\n//子组件 ： (假设名为：ebutton)\n<template>\n  <div class= 'button'>\n      <button>  </button>\n      <slot name= 'one' :value1='child1'> 这就是默认值1 </slot>    //绑定child1的数据\n      <slot :value2='child2'> 这就是默认值2 </slot>  //绑定child2的数据，这里我没有命名slot\n  </div>           \n</template>\n\n<script>\nnew Vue({\n  el:'.button',\n  data:{\n    child1:'数据1',\n    child2:'数据2'\n  }\n})\n</script>\n\n//父组件：（引用子组件 ebutton）\n<template>\n  <div class= 'app'>\n     <ebutton> \n        // 通过v-slot的语法 将插槽 one 的值赋值给 slotonevalue \n        <template v-slot:one = 'slotonevalue'>  \n           {{ slotonevalue.value1 }}\n        </template>\n\n        // 同上，由于子组件没有给slot命名，默认值就为default\n        <template v-slot:default = 'slottwovalue'> \n           {{ slottwovalue.value2 }}\n        </template>\n\n     </ebutton>\n  </div>\n</template>\n\n总结来说就是：\n首先在子组件的slot上动态绑定一个值( :key='value')\n然后在父组件通过v-slot :name = 'values' 的方式将这个值赋值给 values\n最后通过{{ values.key }}的方式获取数据\n\n// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 另一个案例\n//子组件，名称为course-goals.vue\n<ul>\n  <li v-for=\"goal in goals' :key=\"goal\">\n  \t<slot :item=\"goal\" another-prop = \"...\"></slot>\n  </li>\n</ul>\n\n//父组件引入子组件course-goals\n//#default 是v-slot: 的简写,item就是子组件定义的item\n<course-goals>\n  <template #default=\"slotProps\">\n  \t<h2> {{ slotProps.item }} </h2>\n    //下面没有用点语法，因为名称里带'-'符号\n    <p> {{ slotProps['another-prop'] }} </p>\n  </template>\n</course-goals>\n\n\n"
        },
        {
          "label": "provide & inject",
          "language": "vue",
          "value": "provide & inject 必须是父子关系;也可以用于事件,目的是避免跨越组件props的繁琐使用，就是说可以用在子组件的子组件..里\nprovide & inject is a very helpful pattern if you want to avoid pass through componets and pass through props unnecessarily\n\n//父组件\n<script>\ndata(){\n return{\n     topics:{\n       ....\n    }\n  }\n},\nprovide(){\n  return{\n     topics.this.topics\n  }\n},\nmethods:{\n ...\n}\n\n</script>\n\n//在子组件：\n<script>\nexport default{\n  inject:['topics']\n}\n</script>"
        },
        {
          "label": "使用 #简化v-slot 的写法",
          "language": "javascript",
          "value": "//+++++++++++ 使用 #简化v-slot 的写法：在 Vue.js 2.6中，使用 # 符号来代替 v-slot 指令的名称只适用于单个默认插槽的情况，并且只能使用 #default 来代表默认插槽。但是，在 Vue.js 3.0 版本中，# 符号被引入为一个新的简化语法，可以用来代替 v-slot 指令的名称，并且可以用于任何插槽，包括具名插槽，如：\n<my-component>\n    <template #header=\"{ text }\">\n      {{ text }}\n    </template>\n    <template #footer>这是底部插槽的内容</template>\n</my-component>\n//这种新的简化语法只适用于 Vue.js 3.0 版本及以上，对于 Vue.js 2.x 版本，仍然需要使用 v-slot 指令来定义插槽作用域。\n  //子组件\n  <div>\n    <header><slot name=\"header\"></slot></header>\n    <main><slot></slot></main>\n    <footer><slot name=\"footer\"></slot></footer>\n  </div>\n  \n  //下面是一个父组件使用这个组件的示例：\n <template>\n  <my-component>\n    <h1 slot=\"header\">这是头部</h1>\n    <p>这是主要内容</p>\n    <template #default>\n      <p>这是默认插槽的内容</p>\n    </template>\n    <p slot=\"footer\">这是底部</p>\n  </my-component>\n </template>\n\n//+++++++++++ 使用 # 符号来代替 v-slot 指令的名称只适用于单个默认插槽的情况，如果有多个插槽，仍然需要使用 v-slot 指令来定义插槽作用"
        }
      ],
      "id": "YUtcSzmW",
      "createdAt": 1685150011696,
      "updatedAt": 1685858544256
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [
        "q717p6YY"
      ],
      "description": null,
      "name": "动态组件",
      "content": [
        {
          "label": "Fragment 1",
          "language": "vue",
          "value": "//目的：注意组件并没有写入模板里,这样避免了将全部组件写入模板里然后v-if去判断的繁琐;\n//核心；就是用内置的关键字 component 以及绑定 :is;\n\n<button @click=\"setSelectedComponent('active-goals')\">Active Goals</button>\n<button @click=\"setSelectedComponent('manage-goals')\">manage Goals</button>\n\n//keep-alive 常常在动态组件里应用\n<keep-alive>\n\t<component :is=\"selectedComponent\"></component>\n</keep-alive>\n\n<script>\nimport activeGoals from ...\nimport manageGoals from ...\n data(){\n   return{\n     //默认显示组件 activeGoals\n     selectedComponent:'active-goals',\n   }\n },\n methods:{\n   //动态组件切换\n   selectedComponent(cmp){\n     this.selectedComponent = cmp; \n   }\n }\n</script>"
        },
        {
          "label": "引跑 graphone 项目",
          "language": "vue",
          "value": "<template>\n  <div class=\"el-container\"> \n    <h4 style=\"color:red\">main page</h4>  \n    <div class=\"panel panel-default\">\n      <el-tabs v-model=\"activeName\" type=\"card\" @tab-click=\"handleClick\">\n        <el-tab-pane label=\"任务列表\" name=\"first\"></el-tab-pane>\n        <el-tab-pane label=\"新增任务\" name=\"second\"></el-tab-pane>\n        <el-tab-pane label=\"数据源管理\" name=\"third\"></el-tab-pane>\n  </el-tabs>\n\n    <section>\n        //属性:is决定那个组件动态显示出来\n        <component :is=\"isComponents\"></component>\n     </section>\n    </div>\n  </div>\n</template>\n\n<script>\nimport importList from '@/page/database/components/dataImport/taskList'\nimport tabs from '@/page/database/components/dataImport/addImport'\nimport datasource from '@/page/database/source'\n\nexport default {\n   components: { \n      importList,\n      tabs,\n      datasource\n  },\n  data(){\n    return{\n       activeName: 'first',\n       componentsList: {\n          first:importList,\n          second:tabs,\n          third:datasource\n        }   \n    }\n  },\n  methods: {\n     handleClick(tab, event) {\n    }\n  },\n  computed: {\n    isComponents() {\n         return this.componentsList[this.activeName];\n     }\n    }\n}\n</script>\n\n<style lang=\"less\" scoped>\n .el-container{\n   display: block;\n   .panel{\n   padding:10px 30px;\n   }\n }\n</style>"
        },
        {
          "label": "动态组件传参给同一个子组件",
          "language": "javascript",
          "value": "==========在父组件中，你需要传递一个布尔值:is-success=\"true\"给子组件 ，而不是字符串,如下：\n<el-tab-pane label=\"活动状态\" name=\"actionCase\">\n  <component :is=\"'ActionCase'\" ref=\"refActionCase\" :is-success=\"true\" :height=\"tabHeight\" @clickActionCase=\"onClickActionCaseNme\" />\n</el-tab-pane>\n<el-tab-pane label=\"未通过==\" name=\"actionFailed\">\n  <component :is=\"'ActionCase'\" ref=\"refActionCase\" :is-success=\"false\" :height=\"tabHeight\" @clickActionCase=\"onClickActionCaseNme\" />\n</el-tab-pane>\n\n=========在子组件中，你需要接收一个布尔值，所以你需要在子组件中修改props的声明，如下：\nprops: {\n  isSuccess: {\n    type: Boolean,\n    default: true\n  },\n}\n\n==========然后你需要在子组件的getActionCases方法中根据isSuccess的值来过滤数据，如下：\ngetActionCases() {\n  const param = {\n    actionId: this.actionId\n  }\n  apiScheduler.listActionAllCases(param).then(res => {\n    if (res.code === '0') {\n      const filteredCases = []\n      for (let i = 0; i < res.data.length; i++) {\n        const casesData = res.data[i]\n        if (casesData.status !== null && casesData.status === (this.isSuccess ? 'success' : 'failed')) {\n          casesData.actionState = planState[casesData.status]\n          casesData.planState = planState[casesData.status]\n          casesData.statusStr = planState[casesData.status].zh\n          casesData.color = planState[casesData.status].color\n          casesData.icon = planState[casesData.status].icon\n          casesData.num = filteredCases.length + 1\n          filteredCases.push(casesData)\n        }\n      }\n      this.actionCaseData = filteredCases\n    }\n  })\n}\n这样，当你在父组件中设置isSuccess为true时，子组件会显示状态为'success'的数据，当你设置isSuccess为false时，子组件会显示状态为'failed'的数据。\n\nAI - 10:49:59  -此内容由AI生成，真假自辨\n\n// 上面的需求后来有了变化：我希望this.isSuccess是true的时候，返回casesData.status的所有数据，而不仅是success的数据，同时要判断如果this.isSuccess是false的时候就只返回false的数据，怎么写？ \n\n//您可以使用条件语句来根据this.isSuccess的值进行筛选，如下所示：\ngetActionCases() {\n  const param = {\n    actionId: this.actionId\n  }\n  apiScheduler.listActionAllCases(param).then(res => {\n    if (res.code === '0') {\n      const filteredCases = []\n      for (let i = 0; i < res.data.length; i++) {\n        const casesData = res.data[i]\n        console.log('%c casesData.status', 'background:yellow', casesData.status)\n\n        if (this.isSuccess) {\n          // 当 this.isSuccess 是 true 时，返回所有数据\n          if (casesData.status !== null) {\n            casesData.actionState = planState[casesData.status]\n            casesData.planState = planState[casesData.status]\n            casesData.statusStr = planState[casesData.status].zh\n            casesData.color = planState[casesData.status].color\n            casesData.icon = planState[casesData.status].icon\n            casesData.num = filteredCases.length + 1\n            filteredCases.push(casesData)\n          }\n        } else {\n          // 当 this.isSuccess 是 false 时，只返回与 casesData.status 匹配的数据\n          if (casesData.status === 'failed') {\n            casesData.actionState = planState[casesData.status]\n            casesData.planState = planState[casesData.status]\n            casesData.statusStr = planState[casesData.status].zh\n            casesData.color = planState[casesData.status].color\n            casesData.icon = planState[casesData.status].icon\n            casesData.num = filteredCases.length + 1\n            filteredCases.push(casesData)\n          }\n        }\n      }\n      this.actionCaseData = filteredCases\n    }\n  })\n},\n在上面的代码中，我们使用了条件语句来判断this.isSuccess的值。当this.isSuccess为真时，将所有数据都添加到filteredCases数组中。当this.isSuccess为假时，只添加casesData.status为failed的数据。所以，这样就可以根据this.isSuccess的值返回相应的数据了。\n\n"
        }
      ],
      "id": "7MeKvDeL",
      "createdAt": 1685163272158,
      "updatedAt": 1688373918987
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "kYeA3Yuv",
      "tagsIds": [
        "AyqVhk7R"
      ],
      "description": "在这个代码中，我们新增了一个退出全屏按钮，并在标题栏上动态绑定 v-if 指令来控制其显示和隐藏。当窗口进入全屏模式时，退出全屏按钮会显示出来；当窗口退出全屏模式时，退出全屏按钮会被隐藏。\n\n需要注意的是，在 exitFullscreen 方法中，我们调用了 document.exitFullscreen() 方法来退出全屏模式。而不是像之前错误回答中给出的 BrowserWindow.unmaximize() 方法。另外，我们还在 toggleFullscreen 方法中删除了进入全屏模式时的调用，以避免在窗口已经处于全屏模式时再次尝试进入全屏模式，从而导致报错。",
      "name": "el-dialog 全屏切换",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "//以下是引跑atone项目代码，通过chatgpt给出的方案，可行\n<template>\n  <el-dialog :title=\"dialogTitle\" :fullscreen=\"isFullscreen\" @fullscreen=\"fullscreenChanged\">\n    <!-- ... -->\n    <div slot=\"title\" class=\"dialog-title\" :style=\"{ paddingTop: isFullscreen ? 'calc(3vw + 20px)' : '20px' }\">\n      {{ dialogTitle }}\n      <el-button icon=\"el-icon-full-screen\" class=\"fullscreen-btn\"  @click=\"toggleFullscreen\"></el-button>\n      <el-button v-if=\"isFullscreen\" icon=\"el-icon-copy-document\"  @click=\"exitFullscreen\"></el-button>\n    </div>\n  </el-dialog>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      isFullscreen: false,\n      dialogTitle: '新建用例'\n    }\n  },\n  methods: {\n    toggleFullscreen() {\n      this.isFullscreen = !this.isFullscreen\n    },\n    enterFullscreen() {\n      document.documentElement.requestFullscreen()\n      this.isFullscreen = true\n    },\n    exitFullscreen() {\n      document.exitFullscreen()\n      this.isFullscreen = false\n    },\n    fullscreenChanged(isFullscreen) {\n      this.isFullscreen = isFullscreen\n    }\n  }\n}\n</script>\n\n<style scoped>\n.dialog-title {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  position: relative;\n}\n.fullscreen-btn {\n  margin-left: 10px;\n  position: absolute;\n  right: 0;\n  top: 50%;\n  transform: translateY(-50%);\n}\n</style>"
        }
      ],
      "id": "ODRpW_Ei",
      "createdAt": 1685502414868,
      "updatedAt": 1694570570540
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "WblIddgQ",
      "tagsIds": [],
      "description": "在项目的根目录添加一个.vscode文件夹，将这个json格式的文件放里面即可排除相关的搜索",
      "name": "settings.json",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "{\n    \"search.exclude\": {\n        \"**/dist\": true,\n        \"**/node_modules\": true,\n        \"**/.svn\": true\n    }\n}"
        }
      ],
      "id": "C-0kX73z",
      "createdAt": 1685590245600,
      "updatedAt": 1689213418619
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [
        "F3iRFiaA",
        "Vzi-lwKq",
        "MgYAa9Ky"
      ],
      "description": "这段代码中，beforeEach() 钩子函数会在每次路由跳转前被调用。如果目标路由的 meta 属性中的 title 值为 '接口管理'，那么会打开一个新的窗口访问 realurl + ':9230/account/login'，并阻止路由跳转，将当前路由重定向到来源路由。\n\n这里的 urls[0] + ':' + urls[1] 代码是为了获取当前访问站点的协议和主机地址，组成一个字符串。例如，如果当前访问的站点为 http://localhost:8080，那么 realurl 的值就是 http://localhost。这个值将被用于拼接登录页面的 URL。\n\n注意，这里的代码依赖于全局变量 window 和 router，请确保它们已经正确引入。\n\n另外，因为该钩子函数会在每次路由跳转前都会被调用，所以需要特别注意不要陷入无限循环的情况，否则可能会导致浏览器崩溃。",
      "name": "引跑dataone_158项目路由router/index.js 文件",
      "content": [
        {
          "label": "Fragment 1",
          "language": "vue",
          "value": "import Vue from 'vue'\nimport Router from 'vue-router'\nimport { constantRouterMap } from '@/config/router.config'\n\nconst originalPush = Router.prototype.push\nRouter.prototype.push = function push(location) {\n  return originalPush.call(this, location).catch((err) => err)\n}\n\nVue.use(Router)\n\nconst router = new Router({\n  mode: 'history',\n  base: process.env.BASE_URL,\n  scrollBehavior: () => ({ y: 0 }),\n  routes: constantRouterMap\n})\n//beforeEach() 钩子函数会在每次路由跳转前被调用\nrouter.beforeEach((to, from, next) => {\n  let url = window.location.href\n  let urls = url.split(':')\n  //这里的 urls[0] + ':' + urls[1] 代码是为了获取当前访问站点的协议和主机地址，组成一个字符串\n  let realurl = urls[0] + ':' + urls[1]\n\n  if (to.meta.title === '接口管理') {\n    let api_url = realurl + ':9230/account/login'\n    window.open(api_url, '_blank')\n    next(false)\n    router.push(from.path)\n  } else {\n    next()\n  }\n})\n\nexport default router\n"
        }
      ],
      "id": "NVIXeJPX",
      "createdAt": 1685686183611,
      "updatedAt": 1685693108057
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "MqWdF2i4",
      "tagsIds": [
        "nGiQa5U6"
      ],
      "description": null,
      "name": "dialog",
      "content": [
        {
          "label": "Fragment 1",
          "language": "html",
          "value": "<dialog open>\n  //这样就可以生成一个弹框\n</dialog>"
        }
      ],
      "id": "1ED1YHPV",
      "createdAt": 1685696064002,
      "updatedAt": 1685696123739
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [
        "0J7JvK0e"
      ],
      "description": null,
      "name": "form表单",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "// v-model和 $refs都可以获取表单的输入值， $refs.value默认是String类型\n//表单里多选框用数组，checkbox用布尔值，提交后在方法里清空输入\n<template>\n  //重点 @submit.prevent=\"submitForm'  @表示监听事件'.prevent'表示阻止默认的提交刷新页面行为\n  <form @submit.prevent=\"submitForm'>\n      <div class=\"form-control\">\n         <label for=\"user-name\">Your Name</label>\n         //blur是内置事件\n         <input id=\"user-name\" name=\"user-name\" type=\"text\" v-model='userName' @blur='validateInput'/>\n      </div>\n      <div class=\"form-control\">\n          <label for=\"age\">Your Age (Years)</label>\n          //可以这样 v-model.number\n          <input id=\"age\" name=\"age\" type=\"number\" v-model='userAge' ref='ageInput'/>\n      </div>\n      \n      <div class=\"form-control\">\n          <label for=\"referrer\">How did you hear about us?</label>\n              <select id=\"referrer\" name=\"referrer\" v-model='referrer'>\n              \t<option value=\"google\">Google</option>\n                <option value=\"wom\">Word of mouth</option>\n                <option value=\"newspaper\">Newspaper</option>\n\t\t\t\t\t\t\t</select>\n\t\t\t</div>\n   </form>\n</template>\n\n<script>\n  data(){\n    return{\n      userName:'',\n      userAge:null,  //nul表示目前没有值\n      referrer:'wom'\n    }\n  },\n  methods:{\n\t\tsubmitForm(){\n      console.log('userName:',this.userName)\n      this.uesrName = '',\n      console.log('userAge:',this.userAge + 5) //v-model这里输出的是number类型\n      console.log('ageInput这里显示的是String类型:',this.$refs.ageInput.value + 5)//$refs这里输出的是String类型\n      this.referrer = 'wom'\n    },\n    validateInput(){\n    \n    }\n  }\n</script>"
        },
        {
          "label": "formatter属性",
          "language": "javascript",
          "value": "<el-table-column\n  prop=\"status\"\n  label=\"状态\"\n  width=\"80px\"\n  show-overflow-tooltip\n  sortable=\"custom\"\n  :formatter=\"formatStatus\"\n/>\n\nmethods: {\n    formatStatus (row, column, cellValue, index) {\n      if (cellValue === 0) {\n        return '有效'\n      } else if (cellValue === 1) {\n        return '删除'\n      } else {\n        return ''\n      }\n    }\n  }\nformatter是一个表格列的属性，用于自定义表格中某一列的显示内容。它是一个函数，接收四个参数：\nrow：当前行的数据对象- column：当前列的属性配置对象- cellValue：当前单元格的数据值- index：当前行的索引\n函数需要返回一个字符串，用于在表格中显示。\n通过设置formatter属性，我们可以自定义表格中某一列的显示内容，比如将某一列的数值转换为对应的文本、格式化日期、添加链接等。\n\nformatStatus是一个自定义方法，用于将表格中的status属性值转换为对应的文本值，以便于在表格中显示。\n\n该方法接收四个参数：\nrow：当前行的数据对象- column：当前列的属性配置对象- cellValue：当前单元格的数据值\nindex：当前行的索引\n在这个方法中，我们首先判断cellValue的值，如果为0，则返回“有效”，如果为1，则返回“删除”，否则返回空字符串。\n在表格中，当formatter属性被设置为一个方法时，这个方法会接收上述四个参数，并返回一个字符串，用于在表格中显示。"
        }
      ],
      "id": "O9PZYCen",
      "createdAt": 1685873098925,
      "updatedAt": 1686047754849
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [],
      "description": null,
      "name": "Untitled snippet",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": ""
        }
      ],
      "id": "5lstTJVz",
      "createdAt": 1686047655684,
      "updatedAt": 1687231113428
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [],
      "description": null,
      "name": "transition component 动画",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "//transition也有Events如@before-enter等,并且含有参数\n<transition\n  :css='false' //可以禁用css动画，使用js的\n  @before-enter='beforeEnter' \n\t@enter='enter'\n  @after-enter='afterEnter'\n\t@before-leave=\"beforeLeave\" \n\t@leave='leave'\n  @enter-cancelled=\"enterCancelled\" //这个事件可以立即取消之前的事件，避免抖动\n  @leave-cancelled=\"leaveCancelled\"\n> //transition只允许一个child\n// <transition name='para'> \n  \t<p> 上面添加name后,css里的.v-enter-from名称就可以自定义了 para-enter-from</p>\n</transition>\n\n<transition name=\"fade-button\" mode=\"out-in\"> //mode有两个状态in-out和out-in\n\t<button @click=\"showUsers\" v-if=\"!usersAreVisible\"> Show User </button>\n  <button @click=\"hideUsers\" v-else> Hide Users </button>\n</transition>\n\n<transition-group> //加group可以对对多元素进行动画\n  <li v-for=\"user in users\" :key=\"user\" @click=\"removeUser(user)\"></li>\n</transition-group>\n\n<script>\n  data(){\n    return{\n       enterInterVal:null\n    }\n  },\n  methods:{\n    beforeEnter(el) { //el内置参数可以获取dom\n      console.log('beforeEnter');\n      console.log(el);\n      el.style.opacity = 0;\n    },\n    enter(el,done){ //done是vue内置的参数\n      console.log('enter');\n      console.log(el);\n      let round = 1;\n      //setInterval的回调用的箭头函数，否则this指向有问题\n      this.enterInterVal = setInterval(()=> { //将enterInterVal放在上面data里这样别的方法可以访问到\n        el.style.opacity = round * 0.01;\n        round++;\n        if (round > 100) {\n           clearInterval(this.enterInterVal);\n           done();//这个是调用上面第二个参数，告诉vue,这个事件完成了\n        }\n      },20);\n    }\n  }\n</script>\n\n<style>\n  //vue的内置三个css状态：\n  .v-enter-from {\n    opacity: 0;\n    transform: translateY(-30px);\n  }\n  .v-enter-active{\n    transition: all 0.3s ease-out;\n  }\n  .v-enter-to {\n    opacity: 1;\n    transform: translateY(0);\n  }\n\n  //------ leave \n  .v-leave-from {\n    opacity: 1;\n    transform: translateY(0);\n  }\n  .v-leave-active {\n    transition: all 0.3s ease-in;\n  }\n  .v-leave-to{\n    opacity: 1;\n    transform: translateY(30px);\n  }\n</style>"
        }
      ],
      "id": "-ZLzDs6M",
      "createdAt": 1686456204600,
      "updatedAt": 1686820821704
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "3BVGYMMN",
      "tagsIds": [
        "kzDE3A3E"
      ],
      "description": null,
      "name": "[type=\"text\"]",
      "content": [
        {
          "label": "Fragment 1",
          "language": "css",
          "value": "input[type=\"text\"]{\n  margin: 10px ;\n  display: block;\n}"
        }
      ],
      "id": "BEbqFjZn",
      "createdAt": 1686885138589,
      "updatedAt": 1686885345884
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [],
      "description": null,
      "name": "computed & watchers",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "Computed properties are similar to watchers and that they watch our data for changes.\nwatch:  whenever you want to perform asynchronous tasks.\nComputed: Computed properties can never be asynchronous, or at least they shouldn't be.You expect the value to be returned from the computed properties function.However watchers don't bear that responsibility.\n\n// by using watchers, we can run additional logic when a value changes.\n// 以下代码在两秒后会改变页面的值\nwatch: {\n  age(newVal,oldVal) {\n    setTimeout(() => {\n      this.age = 20\n    },2000)\n  }\n}"
        }
      ],
      "id": "UcD_qK3D",
      "createdAt": 1686982363596,
      "updatedAt": 1686982967592
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "MqWdF2i4",
      "tagsIds": [],
      "description": null,
      "name": "input 有很多实用type",
      "content": [
        {
          "label": "Fragment 1",
          "language": "html",
          "value": "<label>perspectiv:{{perspectiv}} px </label>\n<input type='range' min='0' max='999' v-model='perspective'>"
        }
      ],
      "id": "AV0wDPkA",
      "createdAt": 1687162238093,
      "updatedAt": 1687162392408
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [],
      "description": null,
      "name": "Untitled snippet",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": ""
        }
      ],
      "id": "2rIetmnR",
      "createdAt": 1687230339185,
      "updatedAt": 1687230339185
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "07hR6-Qz"
      ],
      "description": null,
      "name": "拷贝内容到剪切板 navigator.clipboard.writeText()",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "//该函数依赖于浏览器的剪贴板 API，只有在支持该 API 的浏览器中才能正常工作\nasync copy(){\n  let text = `transform:${this.box.transform}`\n  //由于该方法返回的是一个 Promise 对象，因此需要使用 await 等待其完成\n  await navigator.clipboard.writeText(text)\n  \n  alert(\"css Copied to Clipboard!\")\n}\n======= 详细解释 navigator.clipboard.writeText()\nnavigator.clipboard.writeText() 是一个 Web API，它允许前端开发者将文本内容写入到用户的剪贴板中。\n该方法接受一个字符串作为参数，将该字符串的内容写入到剪贴板中。它返回一个 Promise 对象，该对象在写入操作完成后会被 resolve。如果写入操作失败，则会被 reject。\n在使用该方法之前，需要先检查浏览器是否支持该 API。可以通过检查 navigator.clipboard 对象是否存在来判断。\n以下是使用 navigator.clipboard.writeText() 的示例代码：\n\nif (navigator.clipboard) {\n  navigator.clipboard.writeText('Hello, World!')\n    .then(() => {\n      console.log('文本已成功写入剪贴板');\n    })\n    .catch((error) => {\n      console.error('写入剪贴板失败:', error);\n    });\n} else {\n  console.error('当前浏览器不支持 navigator.clipboard API');\n}\n\n在上述示例中，我们首先检查浏览器是否支持 navigator.clipboard API。如果支持，我们调用 writeText() 方法并传入要写入剪贴板的文本内容。然后，我们使用 Promise 的 then() 方法来处理成功写入剪贴板的情况，并使用 catch() 方法来处理写入失败的情况。如果浏览器不支持 navigator.clipboard API，则会在控制台打印错误消息。\n需要注意的是，由于安全性考虑，该方法只能在用户交互的上下文中调用，例如在点击按钮、触发事件等操作中。否则会抛出权限错误。"
        }
      ],
      "id": "mlxpI8XS",
      "createdAt": 1687243967884,
      "updatedAt": 1687244484057
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [
        "R7WFWPun"
      ],
      "description": null,
      "name": "Vite",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "npm create vite@latest\n\nnpm run build\n\nnpm run preview\n\nnpm install sass  //后缀名为scss\n\nnpm install autoprefixer --save-dev  //postcss相关，This module is a plugin for post CSS。lt will scan our CSS properties for missing vendors.这里没有站桩postcss因为vite自带了\n\n"
        },
        {
          "label": "postcss.config.cjs",
          "language": "javascript",
          "value": "postcss.config.cjs是自己在vite项目里建立的一个文件，vite会自动查询该文件对postcss进行相关设置;\npostcss is a tool you can configure with plugins to transform the output of your CSS\npostcss会对css进行处理，然后再编译成css\n\nmodule.exports = {\n  plugins:[require('autoprefixer')] //需要先安装：npm install autoprefixer --save-dev\n}\n\n\n//==========下面不属于配置文件内容，是一个示例\nPostCSS can handle adding the prefixes during compilation.比如自动添加火狐浏览器适用的前缀,\n下面的::placeholder在编译后会添加火狐浏览器适用的前缀\n\n//可以更改placeholder的样式\n::placeholder{\n\tcolor:red;\n}"
        }
      ],
      "id": "L9KsPt00",
      "createdAt": 1687250925085,
      "updatedAt": 1687318697409
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "TGQqRGFr",
      "tagsIds": [],
      "description": null,
      "name": "基本概念",
      "content": [
        {
          "label": "Fragment 1",
          "language": "plain_text",
          "value": "Node.js并不是一个用于实现具体功能的第三方工具库，而是JavaScript程序的运行环境。\nNode.js是一个基于Chrome V8引擎的JavaScript运行环境。Node.js使用了一个事件驱动的、非阻塞式I/O的模型，轻量又高效，它的底层是用C/C++编写的。\nNode.js是一个基于Chrome V8引擎的JavaScript运行环境。Node.js使用了一个事件驱动的、非阻塞式I/O的模型，轻量又高效，它的底层是用C/C++编写的。\n由于Node.js底层使用的是异步非阻塞的I/O机制，因此它更适合于I/O密集、少量业务逻辑和计算消耗的场景。尽管解释型脚本语言本身并不适合执行计算型任务，但Node.js底层是由C/C++代码编写的，并且提供了JavaScript代码层与C/C++代码交互的接口，面对计算密集型任务时，Node.js只需要作为启动脚本调用底层C/C++程序来完成计算密集型任务就可以了。\n毫不夸张地说，Node.js对前端开发的推动作用简直就像“工业革命”对生产力的推进作用一样。十几年前，JavaScript连最基本的模块化规范都没有，代码的优化也只能依赖于IDE的简陋工具和手动优化。现今的前端开发工作流则已经拥有了全生命周期的自动化工具支持："
        }
      ],
      "id": "pxRMCzn1",
      "createdAt": 1687255400292,
      "updatedAt": 1687256943348
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3BVGYMMN",
      "tagsIds": [
        "0Hny-xOz",
        "WORBBpq9"
      ],
      "description": "后缀名为scss",
      "name": "sass less postcs",
      "content": [
        {
          "label": "Fragment 1",
          "language": "css",
          "value": "darken() 函数：\nh1{\n\tcolor:#CC3244;\n  &:hover {\n\tcolor: darken(#CC3244，15%);\n }\n}\n"
        },
        {
          "label": "Sass、Less 和 PostCSS的不同点",
          "language": "css",
          "value": "Sass、Less 和 PostCSS 都是前端 CSS 预处理器，用于提高 CSS 的可维护性和可扩展性。下面是它们的主要不同之处：\n\nSass\nSass 是一种基于 Ruby 的 CSS 预处理器，使用 .scss 扩展名。Sass 具有以下特点：\n\n支持变量、嵌套规则、混入（Mixin）、函数等强大的功能，可以让 CSS 更加模块化和易于维护。\n提供了一个类似编程语言的语法，支持条件语句、循环语句等高级语法，可以实现更复杂的逻辑判断和计算。\n可以通过 @import 导入其他 Sass 文件或 CSS 文件，使样式表更加组件化和灵活。\nLess\nLess 是一种基于 JavaScript 的 CSS 预处理器，使用 .less 扩展名。Less 具有以下特点：\n\n与 Sass 相比，Less 的语法更加简洁明了，更接近原生 CSS 语法，学习曲线较低。\n支持变量、嵌套规则、混入（Mixin）等功能，但相对于 Sass 功能较为简单。\n可以在浏览器端使用，通过 JavaScript 解析 Less 样式表并动态生成 CSS。\nPostCSS\nPostCSS 不同于 Sass 和 Less，它是一种基于 JavaScript 的 CSS 后处理器，使用插件来实现各种功能。PostCSS 具有以下特点：\n\n不提供预处理器的语法和功能，而是通过插件对 CSS 进行转换、优化和扩展。\n可以与大多数现代前端工具集成，如 webpack、gulp 等，使得对 CSS 的处理变得更加灵活和可配置。\n插件丰富，支持自动添加浏览器前缀、转换 CSS 新特性语法、优化样式表等各种功能。\n总之，Sass 和 Less 更加侧重于提供一种新的 CSS 编写方式，可以使 CSS 更加模块化和易于维护；而 PostCSS 则更加注重对 CSS 进行后处理，以提高样式表的可读性、可维护性和性能。"
        },
        {
          "label": "Less",
          "language": "css",
          "value": "在 Less 中，@ 符号代表变量的声明。在 @base-color 这个变量中，@ 表示这是一个 Less 变量的声明，它用于存储一个颜色值，并可以在样式表中多次引用该颜色值。\nLess 变量可以包含任何有效的 CSS 值，如颜色、长度、字体等。使用 Less 变量可以提高代码的可维护性和便捷性，因为我们可以通过修改变量值来改变所有引用该变量的地方，而无需手动逐一更改。\n例如，我们可以定义一个名为 @color-primary 的变量，将其设置为主题色，在需要使用该颜色的地方直接使用变量名即可：\n\n@color-primary: #0080FF; // 定义主题色\n.button {\n  background-color: @color-primary; // 使用主题色\n}\n\n这样，在需要修改主题色时，只需要修改一次 @color-primary 的值，就可以自动更新整个页面中所有使用该颜色的元素的样式。\n\n除了 darken() 函数，在 Less 中还有很多其他实用的函数和方法，下面是一些常用的函数和方法：\n\nlighten() 函数：用于调亮颜色值，与 darken() 函数的作用相反。\n@base-color: #3498db;\n@light-color: lighten(@base-color, 10%);\nsaturate() 函数：用于增加颜色的饱和度。\n@base-color: #3498db;\n@saturated-color: saturate(@base-color, 20%);\ndesaturate() 函数：用于降低颜色的饱和度。\n@base-color: #3498db;\n@desaturated-color: desaturate(@base-color, 20%);\nspin() 函数：用于旋转颜色的色相。\n@base-color: #3498db;\n@rotated-color: spin(@base-color, 180deg);\nmix() 函数：用于混合两种颜色，返回一个新的颜色。\n@color1: #f44336;\n@color2: #2196f3;\n@mixed-color: mix(@color1, @color2, 50%);\ncalc() 函数：用于进行数学计算。\n@width: 200px;\n@padding: 10px;\n.box {\n  width: calc(@width - 2 * @padding); // 计算宽度\n}\nrem() 函数：将像素转换为 rem 值。\n@font-size: 16px;\nh1 {\n  font-size: rem(@font-size); // 将像素转换为 rem 值\n}\n除了上述函数和方法外，Less 还提供了许多实用的工具和功能，如混合（Mixin）、变量（Variable）、嵌套规则（Nested Rules）等"
        }
      ],
      "id": "Mlw4dPHX",
      "createdAt": 1687314510215,
      "updatedAt": 1687342871577
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "使用ESLint规范编程风格",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "editorconfig只对程序文件的通用基本格式进行了限制，并不关心某个编程语言自身的语法特性，而ESLint可以说是专为JavaScript服务的代码检查工具。ESLint通过对工程目录中的js或jsx文件执行自动扫描来查找常见的语法和代码风格错误（安装插件后即可支持ts和tsx），并根据用户设定的报警等级给出提示，甚至还可以配置自动修复策略。\n它的整体架构是一个插件平台，这就意味着我们可以只让自己期望的检测规范生效，或者编写自己团队专属的检测规范，而不是被动地接受某些设定。当然，如果你觉得配置很烦琐，也可以直接下载一些知名的前端技术团队开源的配置文件来使用。\n另一方面，ESLint的流行得益于其广泛支持的集成方式，我们不仅可以通过编辑器插件使用它，也可以直接在命令行中启用它，或者配合各种自动化构建工具及API通过编写代码的方式将它接入自己的前端工程化体系中。ESLint具有如此广泛的适用性，可以称得上是业界良心了。\n\nESLint可以支持如下两种配置方式。\n● 注释配置：直接使用JavaScript注释把配置信息嵌入代码源文件中。\n● 文件配置：使用JavaScript、JSON或YAML文件格式为整个目录配置“.eslintrc.*”文件来存放配置信息。\n\n规则集的配置格式如下：\nrules:{\n    \"规则名\" : [规则值, 规则配置]\n}\n//规则值支持:\"off\"或0表示关闭，\"warn\"或1表示告警，\"error\"或2表示错误\n\n=========下面展示的是一份配置好的“.eslintrc.js”文件（以JS格式为例）：\nmodule.exports = {\n    //根级设置，全局生效\n    \"root\":true,\n    //设置支持的环境，支持的环境激活后会提供一组特定环境的预定义全局变量\n    \"env\":{\n        \"browser\":true,\n        \"node\":true\n    },\n    //要检查的规则集\n    \"rules\":{\n        // 进行条件判断时，强制使用\"===\"或\"！==\"，告警级别为\"错误\"\n        \"eqeqeq\" : 2,\n        // 禁止在条件表达式中出现赋值语句，告警级别为\"错误\"\n        \"no-cond-assign\" : 2,\n        // 禁止使用alert()方法，告警级别为\"警告\"\n        \"no-alert\" : 1,\n        // 禁止使用eval方法，告警级别为\"错误\"\n        \"no-eval\" : 2\n    }\n}\n把上面的配置文件放在项目的根目录下，通过任何一种方式启用ESLint对代码进行检查，都会得到上述几个规则的检测结果，开发者一般会选择在IDE中安装ESLint插件的方式来使用。官方提供的可选检测规则多达200条，我们可以从中筛选出自己需要的规则，或者下载共享配置文件，然后通过配置文件中的“extends”字段来启用官方推荐的规则，或者使用某些知名的前端团队提供的开源规则集。例如，下面的配置就会默认启用ESLint官方推荐的规则（即官方网站的规则集中所有带有绿色对号标记的规则）：\n\"extends\" : \"eslint:recommended\"\n如果在某些特殊场景中，需要有针对性地避开某些检测规则（而不是对整个工程禁用某项检测），则可以使用下面的语法在源代码中进行注释：\nalert('foo'); /* eslint-disable-line no-alert*/\n/*eslint-disable-next-line no-alert*/\nalert('foo');"
        },
        {
          "label": "Prettier",
          "language": "javascript",
          "value": "“使用Prettier最大的理由就是它可以终止所有现存的有关格式的争论”\nPrettier可用于扫描文件中的格式问题，并自动重新格式化代码，以确保缩进、间距、分号、单双引号等遵循一致的规则，可以将它看作升级版的editorconfig，但Prettier的使用方式更加多元化，对于排版格式的控制粒度也更细，支持命令行、nodeAPI、ESLint插件等多种引入方式，是一个非常适合前端开发的新秀工具\nESLint和Prettier是非常好的搭档，尽管有时候因为配置的问题可能会在检查项上出现冲突，这种时候根据实际要求关闭其中一个的检查项即可。总之，ESLint更倾向于发现和修复语言本身相关的漏洞或风险，而Prettier关注的则是格式和排版风格方面的一致性，两者各司其职。\n一个典型的“.prettierrc”配置文件是下面这样的（完整的配置项可以查阅官方文档）：\n{\n    \"printWidth\":80,             //每一行字符数，超出后会启用换行策略\n    \"tabWidth\":4,                //每个Tab代表几个空格\n    \"useTabs\":false,             //是否使用Tab进行缩进，默认为false，即使用空格进行缩进\n    \"semi\":false,                //是否在语句后强制加分号\n    \"singleQuote\":true,          //字符串是否使用单引号\n    \"trailingComma\":none,        //是否去除末尾逗号\n    \"bracketSpacing\":true,       //对象字面量的大括号与内容之间是否自动添加空格\n}"
        }
      ],
      "id": "I4hIMkEj",
      "createdAt": 1687331072067,
      "updatedAt": 1687336027294
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [],
      "description": null,
      "name": "devTools",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "Checking the dev tools is a great way to verify if a component is being registered successfully.前提是给组件的name赋值\nexport default{\n  name:\"Greeting\",\n  data(){\n    ...\n  }\n}\n============ inspect\n有了name在devTools的inspect里可以查看组件是否加载了\n\n=========== Timeline\nThe time line tool will display a list of events emitted by our app,  it'll even display events emitted by the browser"
        }
      ],
      "id": "-vkC7yLL",
      "createdAt": 1687342036741,
      "updatedAt": 1687408378564
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": "export \\ import + 模板语法拼接其他值",
      "name": "config.js & helpers.js 文件之间数据导入导出",
      "content": [
        {
          "label": "config.js",
          "language": "javascript",
          "value": "//config.js,下面大写是配置文件常用的写法\nexport const API_URL = 'https://forkify-api.herokuapp.com/api/v2/recipes';\nexport const TIMEOUT_SEC = 10;\n\n\n//在另一个文件使用：\nimport {API_URL} from './config.js'\n\n...\n  const res = await fetch(`${API_URL}/${id}`);\n  const data = await res.json();\n"
        },
        {
          "label": "helpers.js",
          "language": "javascript",
          "value": "import {TIMEOUT_SEC} from './config.js'  //将配置的值用大写字母明示,方便阅读理解和配置\n\nconst timeout = function (s) {\n  return new Promise(function (_, reject) {//某个位置的参数忽略但又要占位，就要这么写 '_',这里不需要resolved\n     setTimeout(function () {\n    \t reject(new Error(`Request took too long! Timeout after ${s} second`));\n      }, s * 1000);\n   });\n};\n\nexport const getJSON = async function (url){\n  try {\n      //因为是promise对象所以必须await,用了race,这样实现了超时功能\n      const res = await Promise.race([fetch(url), timeout(TIMEOUT_SEC)]); //TIMEOUT_SEC的值是10\n      const data = await res.json(); //这)里会返回一个resovled 的值\n\n      if (!res.ok) throw new Error(`${data.message} (${res.status})`);\n      return data;//返回resovled 的值\n   }catch (err){\n      throw err;\n  }\n};"
        },
        {
          "label": "model.js 这里导入另外两个js的数据",
          "language": "javascript",
          "value": "/*在导出模块时，可以使用 export default 语句来将一个函数、对象或者类作为默认导出导出到模块中。在导入模块时，不使用花括号 {} 来引用被默认导出的模块。需要特别注意的是，每个模块只能有一个默认导出。因此，在同一个模块中，不能同时使用命名导出和默认导出的方式。*/\nimport {getJSON} from './helper.js'\nimport {API_URL} from './config.js'\n\nexport const loadRecipe = async function (id) {\n  try {\n  //注意这里使用了另一个JS文件helpers.js的函数getJSON()\n  \tconst data = await getJSON(`$(API URL}/${id}`);\n    \n \t\tconst {recipe } = data.data;\n    state.recipe = {\n    \tid: recipe.id,\n      title: recipe.title,\n      sourceUrl: recipe.source_url,\n      image: recipe.image_url,\n      ingredients: recipe.ingredients,\n    }\n\t\t\tconsole.log(state.recipe);\n    } catch (err){\n    // Temp erro handling\n    \tconsole.error(`${err}`)\n      throw err\n    }\n}"
        }
      ],
      "id": "M0NOPeCB",
      "createdAt": 1687588715891,
      "updatedAt": 1687847184109
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "TwMzSlbz",
        "V_npm_YK",
        "9XW5Mpot",
        "9C5XAC_v",
        "ZCfYVnNs",
        "sYJYnob2",
        "7l5V15ey"
      ],
      "description": "在一个Vue项目中，通常会使用MVC（Model-View-Controller）或者MVVM（Model-View-ViewModel）的架构模式来组织代码。\n\nmodel.js（模型）：主要负责与数据相关的逻辑，包括数据的获取、处理和存储等。它定义了数据的结构和操作方法，可以是一个单独的文件或者一个模块。\n\ncontroller.js（控制器）：负责处理业务逻辑和用户交互，接收来自视图的输入，并根据输入调用模型和更新视图。它一般包含了各种事件处理函数、请求处理和数据操作等。\n\nview.js（视图）：负责展示数据和用户界面，通常是一个Vue组件或者模板。它只关注数据的展示和用户的交互，不包含业务逻辑。\n这些文件分别代表了MVC或MVVM模式中的不同角色，通过分离不同的责任，可以使代码更加清晰、可维护和可扩展。当然，具体的命名和组织方式可能会因项目的规模和团队的约定而有所不同。\n\npublisher subscriber pattern.",
      "name": "MVC架构模式以及类的实例",
      "content": [
        {
          "label": "controller.js",
          "language": "javascript",
          "value": "controller.js（控制器）：负责处理业务逻辑和用户交互，接收来自视图的输入，并根据输入调用模型和更新视图。它一般包含了各种事件处理函数、请求处理和数据操作等。\n//文件定义了几个方法，然后在init方法里进行了调用,这个文件作为controller不处理UI渲染\n\nimport * as model from './model.js' //将整个模块作为一个对象引入\nimport recipeView from './views/recipeView.js\nimport searchView from './views/searchView.js'\nimport resultsView from './views/resultsView.js'\nimport paginationView from './views/paginationView.js'\n\n //省略 ....\n \nconst controlRecipes = async function () {\n  try{\n    const id = window.location.hash.slice(1);\n    \n    if (!id) return;\n    //使用上面导入的recipeView文件里的renderSpinner方法\n    recipeView.renderSpinner();\n    \n    // 1) Loading recipe\n    await model.loadRecipe(id);\n    \n    // 2) Rendering recipe\n    recipeView.render(model.state.recipe);\n  } catch (err) {\n  \trecipeView.renderError();\n  }\n};\n\nconst controlSearchResults = async function(){\n  try {\n    resultsView.renderSpinner(); //Loading\n    \n    // 1)get search query\n    const query = searchView.getQuery();\n    if (!query) return;\n    \n    // 2)load search results\n    await model.loadSearchResults(query);\n    \n    // 3) render results\n    console.log(model.state.search.results);\n    //resultsView.render(model.state.search.results) 没有分页前\n     resultsView.render(model.getSearchResultsPage())\n     \n     // 4) Render initia pagination buttons\n     paginationView.render(model.state.search) //将model里的整个search对象作为参数\n    } catch (err) {\n    \tconsole.log(err);\n    }\n };\n \nconst controlPagination = function(goToPage) {//goToPage是从pagenationView.js传过来的页码数字\n  //console.log(goToPage);\n   // 1) render NEW results\n   resultsView.render(model.getSearchResultsPage(goToPage))\n     \n   // 2) Render NEW pagination buttons\n   paginationView.render(model.state.search) //将model里的整个search对象作为参数\n}\n\nconst controlServings = function(newServing) {\n   // Update the recipe servings (in state)\n   model.updateServings(newServing);\n   // Update the recipe view\n   //recipeView.render(model.state.recipe);\n   recipeView.updata(model.state.recipe); //局部更新，避免页面闪烁\n}\n \n//调用上面定义的方法\nconst init = function () {\n  recipeView.addHandlerRender(controlRecipes)\n  recipeView.addHandlerUpdateServings(controlServings)\n  searchView.addHandlerSearch(controlSearchResults)\n  paginationView.addHandlerClick(controlPagination)\n}\n\ninit();"
        },
        {
          "label": "searchView.js",
          "language": "javascript",
          "value": "class SearchView {\n  //#和_开头的变量命名都是一种约定俗成的规范，用来表示该属性是私有（private）的。但是，它们在语言层面上是没有特殊意义的，只是一种书写习惯。\n  //#parentEl = document.querySelector('.search');\n  _parentEl = document.querySelector('.search');\n  getQuery() {\n  \tconst query = this.#parentEl.querySelector('.search_field').value;\n    this.#clearInput();\n    return query;\n  }\n  \n  _clearInput() {\n\t\tthis.#parentEl.querySelector('search__field').value =''\n   }\n    \n  //这里addHandlerSearch是发布者 publisher\n  addHandlerSearch(handler){ \n  \tthis.#parentEl.addEventListener('submit,function(e) {\n    \te.preventDefault();\n      handler();//这里是订阅者，执行的是controller.js里的controlSearchResults函数\n    });\n  }\n}\n//注意对于class在export时加了new 因为要实例化，普通的函数等是不加new的\nexport default new SearchView();"
        },
        {
          "label": "recipeView",
          "language": "javascript",
          "value": "import View from './View.js'\nimport icons from  'url:../../img/icons.svg';\nimport { Fraction } from 'fractional'; //z这是一个将小数点数字转变为分子分母类型的npm上的第三方库\n\nclass RecipeView extends View {\n  _parentElement = document.querySelector('.recipe');\n  _errorMessage = 'We could not find that recipe. Please try another one!';\n  _message ='';\n  \n  addHandlerRender(handler) {\n  \t['hashchange','load'].forEach(ev => window.addEventListener(ev, handler));\n  }\n  //用了事件代理，closest()方法和事件代理是好搭档\n  //发布者\n  addHandlerUpdateServings(handler) {\n\t\tthis._parentElement.addEventListener('click', function (e){ \n    \tconst btn = e.target.closest('.btn--tiny');\n      if (!btn) return;//守卫\n      console.log(btn);\n      //updateTo这个dataset值在html的属性里是这样的：data-update-to='xxx'\n      const { updateTo } = btn.dataset; //相当于const updateTo = btn.dataset.updateTo;\n      //订阅者\n      if(+updateTo>0) handler(+updateTo);\n    })\n  }\n  \n  generateMarkup() {\n    return `\n   \t <figure class=\"recipe_fig\"><img src=\"${this._data.image}\" alt=\"${this._data.title}\"\n    \t....\n"
        },
        {
          "label": "View.js",
          "language": "javascript",
          "value": "view.js（视图）：负责展示数据和用户界面，通常是一个Vue组件或者模板。它只关注数据的展示和用户的交互，不包含业务逻辑。\n//view是作为父文件想下面的相关文件提供方法和数据\n\nimport icons from  'url:../../img/icons.svg';\n\nexport default class View {\n  _data;\n  \n  render(data) {\n    // 没有数据 || 有数据但不是数组 && 数据为空\n    if(!data || (Array.isArray(data) && data.length === 0)) \n      return this.rederError(); //注意这个用法,作为守卫，返回一个错误信息\n  \n    this._data = data;\n    const markup = this._generateMarkup();\n    this._clear(); //这里很关键，会删除之前的数据，已方便用新的数据覆盖上去\n    this._parentElementinsertAdjacentHTML('afterbegin', markup);\n  }\n  \n  updata(data){\n    // 没有数据 || 有数据但不是数组 && 数据为空\n    if(!data || (Array.isArray(data) && data.length === 0)) \n      return this.rederError(); //注意这个用法,作为守卫，返回一个错误信息\n  \n    this._data = data;\n    const newMarkup = this._generateMarkup();\n    ... //这里省略许多有关局部更新页面的逻辑(对比DOM和虚拟dom)。核心是使用一些dom的方法并通过Array.from()将nodelist转化为数组\n  }\n  \n  clear() {\n    this._parentElement.innerHTML ='';\n  }\n  \n  renderSpinner(){\n    const markup =`\n      <div class=\"spinner\">\n     \t\t <svg><use href=\"${icons}#icon-loader\"></use></svg>\n      </div>\n     `;\n    this._clear();\n    this._parentElement.insertAdjacentHTML('afterbegin',markup)\n  }\n  \n  renderError(message = this._errorMessage){\n    const markup =`\n      <div class=\"error\">\n          <div>\n             <svg><use href=\"${icons}#icon-alert-triangle\"></use></svg>\n          </div>\n          <p>${message}</p>\n      </div>\n     `;\n     this._clear();\n     this._parentElement.insertAdjacentHTML('afterbegin',markup)\n   }\n\n}"
        },
        {
          "label": "resultsView.js",
          "language": "javascript",
          "value": "import View from './View.js'\n\n\n//这个文件继承自View.js，所以用了extends View,其中会带有父文件的所有方法，如 renderSpinner()\nclass ResultsView extends View {\n\t_parentElement = document.querySelector('.results');\n  _errorMessage = 'No recipes found for your query! Please try again'\n  _message = ''\n  \n  _generateMarkup(){\n    console.log(this._data) //这个_data是View.js传过来的\n    //使用map方法遍历this._data数组，对每个元素调用_generateMarkupPreview方法生成一个预览的HTML字符串\n    return this._data.map(this._generateMarkupPreview).join('');\n    \n    _generateMarkupPreview(result) {\n      return `\n        <li class=\"preview\">\n          <a class=\"preview_link preview  link--active\" href=\"#${results.id}\">\n              <figure class=\"preview fig\"><img src=\"${results.images}\" alt=\"Test\" /></figure>\n              <div class=\"preview data'\">\n                  <h4 class=\"preview__title\">${results.title}</h4>\n                  <p class=\"preview_publisher\">${results.publisher}</p>\n              </div>\n          </a>\n         </li>\n       `;\n      }\n    }\n}\n\nexport default new ResultsView();"
        },
        {
          "label": "model.js",
          "language": "javascript",
          "value": "model.js（模型）：主要负责与数据相关的逻辑，包括数据的获取、处理和存储等。它定义了数据的结构和操作方法，可以是一个单独的文件或者一个模块\n\nimport { API_URL, RES_PER_PAGE } from './config.js'\nimport { getJSON } from './helpers.js'\n\nexport const state = {\n  recipe:{}\n  search:{\n    query:'',\n    results: [],\n    page:1,\n    resultsPerPage:RES_PER_PAGE\n   }\n };\n \n export const loadRecipe = async function (id) {\n   try {\n      const data = await getJSON(`$(API_URL}${id}`);\n      const { recipe } = data.data;\n       state.recipe = {\n           id: recipe.id,\n           title: recipe.title,\n           publisher: recipe.publisher,\n           sourceUrl: recipe.source_url,\n           image: recipe.image_url,\n           servings: recipe.servings,\n           ...\n         }\n         console.log(state.recipe);\n       }catch (err){\n          console.error(`${err}`)\n          throw err;\n       }\n     };\n     \n   export const loadSearchResults = async function (query) {\n    try {\n        state.search.query = query;\n\n        const data = await getJSON(`$(API_URL}?search=${query}`);\n        console.log(data);\n\n        state.search.results = data.data.recipes map(rec => {\n          return {\n             id: rec.id,\n             title: rec.title,\n             publisher: rec.publisher,\n             image: rec.image_url,\n          }\n        })\n     } catch (err) { \n      throw err\n     }\n   };\n   \n   export const getSearchResultsPage = function (page = state.search.page){ //page是页码，如1、2、4 ...\n     state.search.page = page;\n     \n     const start = (page - 1) * state.search.resultsPerPage; // 这里根据页码会有不同的值，如0、10、20、30... \n     const end = page * state.search.resultsPerPage; // 同上\n     \n     return state.search.results.slice(start, end);\n   }\n   \n   export const updateServings = function (newServings){\n   \t\tstate.recipe.ingredients.forEach(ing => {\n        ing.quantity = (ing.quantity * newServings) / state.recipe.servings\n        // newQt = oldQt *newServings / oldServings   // 2*8 /4=4;\n      })\n\t\t\tstate.recipe.servings = newServings\n   }\n\n     "
        },
        {
          "label": "config.js",
          "language": "javascript",
          "value": "//这里是配置文件\nexport const API_URL = 'https://forkify-api.herokuapp.com/api/v2/recipes/';\nexport const TIMEOUT SEC = 10;\nexport const RES_PER_PAGE = 10;"
        },
        {
          "label": "pagenationView.js",
          "language": "javascript",
          "value": "//这个文件是分页的显示,分页按钮的显示逻辑很简单，根据不同的页码，显示不同的导航button\n\nimport View from './View.js';\nimport icons from 'url:../../img/icons.svg'; // Parcel 2\n\nclass PaginationView extends View {\n  parentElement = document.querySelector('.pagination');\n  \n   //发布者与订阅者模式，发布者就是个函数，其回调函数就是订阅者\n   //这里使用了事件代理，通过父元素控制左右导航的两个按钮\n  addHandlerClick(handler){\n    this._parentElement.addEventListener('click', function(e){\n      //closest()是很关键的用法, 可以用来选择父元素\n    \tconst btn = e.target.closest('.btn--inline');\n      if(!btn) return; //这里是个守卫，没有值就跳出，以免执行下面代码出现报错\n      \n      //+号是为了转换为数字类型,从浏览器的console的返回值颜色可以判断值的类型是字符还是数字\n      //dataset可以获取在html里自定义的data值\n      const goToPage = +btn.dataset.goto \n      //goToPage是页码\n      handler(goToPage);\n    });\n  }\n  \n  _generateMarkup(){\n     const curPage = this._data.page;\n     const numPages = Math.ceil(this._data.results.length / this._data.resultsPerPage); \n     console.log(numPages);\n     \n   \t\t// Page 1, and there are other pages\n     if (curPage === 1 && numPages > 1 ){\n      return `\n        //这里添加了自定义属性 data-goto\n        <button data-goto=\"${curPage + 1}\" class=\"btn--inline pagination__btn--next\">\n          <span>Page ${curPage + 1}</span>\n          <svg class=\"search__icon\">\n            <use href=\"${icons}#icon-arrow-right\"></use>\n           </svg>\n        </button>\n      `;\n     }\n    // Last page\n     if (curPage === numPages && numPages > 1 ){\n      return `\n       \t<buttondata-goto=\"${curPage - 1}\" data-goto=\"${curPage + 1}\" class=\"btn--inline pagination__btn--prev\">\n        \t<svg class=\"search__icon\">\n          \t\t<use href=\"${icons}#icon-arrow-left\"></use>\n          </svg>\n\t\t\t\t\t<span>Page ${curPage - 1}</span>\n        </button>\n      `;\n     }\n    // Other page\n      if (curPage < numPages){\n       return `\n       \t<button class=\"btn--inline pagination__btn--prev\">\n        \t<svg class=\"search__icon\">\n          \t\t<use href=\"${icons}#icon-arrow-left\"></use>\n          </svg>\n\t\t\t\t\t<span>Page ${curPage - 1}</span>\n        </button>\n        <button class=\"btn--inline pagination__btn--next\">\n          <span>Page ${curPage + 1}</span>\n          <svg class=\"search__icon\">\n            <use href=\"${icons}#icon-arrow-right\"></use>\n           </svg>\n        </button>\n      `;\n     }\n      // Page 1, and there are NO other pages,Only one page\n      //只有一页就不显示任何导航按钮\n       return ''; \n    }\n}\n\nexport default new PaginationView();\n    "
        }
      ],
      "id": "R_in17Yr",
      "createdAt": 1687850654011,
      "updatedAt": 1687945747065
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "njDRzcoh",
        "4LLYvAFl"
      ],
      "description": null,
      "name": "ES6的模块化语法",
      "content": [
        {
          "label": "*  将整个模块作为一个对象引入",
          "language": "javascript",
          "value": "import * as model from './model. js'  //这句什么意思?\n\n这个语句使用ES6的模块化语法，将./model.js模块中导出的所有内容都导入到一个名为model的对象中，可以理解为将整个模块作为一个对象引入。例如，如果./model.js中有如下代码：\n\nexport const name = 'Tom';\nexport const age = 18;\nexport function sayHello() {\n  console.log(`Hello, my name is ${name}, I am ${age} years old`);\n}\n\n//那么在另一个文件中，你可以按照以下方式导入和使用这些方法：\n\nimport * as model from './model.js';\n\nconsole.log(model.name); // 输出 'Tom'\nconsole.log(model.age); // 输出 18\nmodel.sayHello(); // 输出 'Hello, my name is Tom, I am 18 years old'\n\n这里的*通配符表示导入模块中的所有内容，并将它们作为一个对象导入到model命名空间中。因此，在使用导入的方法时需要通过model.来进行访问。需要注意的是，使用这种方式导入模块中的所有内容可能会导致变量名冲突或者产生不必要的代码量。因此，在实际开发中，推荐只导入需要的模块成员，而非导入整个模块。"
        }
      ],
      "id": "VzA1P3WQ",
      "createdAt": 1687856018621,
      "updatedAt": 1688869376123
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3BVGYMMN",
      "tagsIds": [],
      "description": null,
      "name": "css自定义变量",
      "content": [
        {
          "label": "Fragment 1",
          "language": "css",
          "value": "双减号（--）用于表示自定义属性（custom property）。它允许开发者定义自己的变量，并在整个样式表中重复使用这些变量\n//自定义变量\n:root{\n  --success-color:#2ecc71;\n}\n\n//使用自定义变量\n.form-control.success input {\n\tborder-color: var(--success-color);\n}"
        }
      ],
      "id": "Z9ID9FzV",
      "createdAt": 1688017985582,
      "updatedAt": 1688018318249
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "J2CKWazz",
        "udbxbqmP",
        "cJzn_M8B"
      ],
      "description": "知识点：选择父元素；定义函数并传参；给css添加类；",
      "name": "JS表单验证",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "<form id=\"form\" class=\"form\">\n  <div class=\"form-control\">\n    <input type=\"text\" id=\"username\" placeholder=\"Enter username\"/>\n    <small>Error message</small>\n  </div>\n  \n  <div class=\"form-control\">\n  ...\n  \n\n  //------------------------------js 文件\n  // Show input error message\n  function showError(input, message) { //定义函数和其中的形参\n    //注意，事件代理在选择共同的父元素的时候用closet()\n  \tconst formControl = input.parentElement; //这个parentElement选择的就是html里的 form-control\n    formControl.className = 'form-control error';//给html添加css类，显示红色\n    const small = formControl.querySelector('small');\n    small.innerText = message; //应用实参到innerText\n   }\n   \n   // Show success outline\n   function showSuccess(input) {\n      const formControl = input.parentElement;\n      formControl.className = 'form-control success';\n   }\n  \n  // Event listeners\n  form.addEventListener('submit', function(e) {\n    e.preventDefault();\n\n    if (username.value === '') {\n      showError(username,'Username is required');//调用函数并传递实参\n    } else {\n      showSuccess(username);//调用函数并传递实参\n   }\n})\n  </script>"
        },
        {
          "label": "升级版-给函数的参数传递数组",
          "language": "javascript",
          "value": " // Check required fields\nfunction checkRequired(inputArr) {\n\tinputArr.forEach(function(input){//(input是形参\n  \tif (input.value.trim() === '') {\n    \tshowError(input,`${getFieldName(input)} is required`);\n\t\t}else{\n\t\t\tshowSuccess(input);\n  \t}\n  })\n}\n \n // Check input length\nfunction checkLength(input, min,max) {\n\tif (input.value.length < min){\n  \tshowError(input,`${getFieldName(input)} must be at least $(min} characters`);\n\t}else if (input.value.length > max){\n  \tshowError(input,`$getFieldName(input)} must be less than $(max} characters`);\n\t}else{\n\t\tshowSuccess(input);\n }\n}\n\n // Get fieldname 并将首字母大写，input.id是html的id值\nfunction getFieldName(input) {\n\treturn input.id.charAt(0).toupperCase() + input.id.slice(1);\n}\n \n// Event listeners\nform.addEventListener('submit', function(e) {\n  e.preventDefault();\n    \n  checkRequired([username, email，password，password2]);\n  checkLength(username,3,15)\n  checkLength(password,6,25)\n});"
        }
      ],
      "id": "T0GdZyq1",
      "createdAt": 1688019405342,
      "updatedAt": 1688023961058
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "spread 扩展运算符",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "const arr =[1,2,3]\nconst arr2 =[...arr,4,5]\n\narr2.forEach(function(item) {\n\tconsole.log(item + 'Hello')\n})\n\nconst arr3 = arr2.map(function(item) {\n\treturn item * 2\n})\nconsole.log(arr3) //返回 Array[2,4,6,8,10]"
        }
      ],
      "id": "B6XmkKpr",
      "createdAt": 1688094538039,
      "updatedAt": 1688094768466
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": "节流函数和防抖函数都是用于限制函数的执行频率，但它们实现的机制略有不同。\n\n防抖函数的作用是当一个事件连续触发时，在一定的时间延迟后才执行最后一次触发的事件。如果在延迟时间内又有新的事件触发，则重新计时延迟时间。这样可以避免事件频繁触发时造成过多的函数执行。\n\n而节流函数的作用是当一个事件连续触发时，在一定的时间间隔内只执行一次事件处理函数。无论事件触发频率如何，节流函数会按照固定的时间间隔执行函数。这样可以控制函数的执行频率，保证函数在一定时间间隔内被均匀调用。\n因此，虽然节流函数和防抖函数都是用于限制函数的执行频率，但它们的具体实现和应用场景有所不同。需要根据具体的需求选择使用节流函数还是防抖函数。",
      "name": "节流和防抖函数",
      "content": [
        {
          "label": "节流函数",
          "language": "javascript",
          "value": "function throttle(fn, delay) {\n  var t = null,\n    begin = new Date().getTime();\n\n  return function() {\n    var _self = this,\n      args = arguments,\n      cur = new Date().getTime();\n\n    clearTimeout(t);\n\n    if (cur - begin >= delay) {\n      fn.apply(_self, args);\n      begin = cur;\n    } else {\n      t = setTimeout(function() {\n        fn.apply(_self, args);\n      }, delay);\n    }\n  };\n}\nexport { throttle };\n\n//可以通过以下方式使用导出的throttle函数：\n\nimport { throttle } from '@/libs/utils/throttle.js';\n\nconst myFunction = () => {\n  // 要执行的函数逻辑\n};\n\nconst throttledFunction = throttle(myFunction, 1000); // 创建一个节流版本的函数\n\n// 在需要限制执行频率的地方调用节流函数\nthrottledFunction();"
        },
        {
          "label": "防抖函数",
          "language": "javascript",
          "value": "1）带参数传递的版本：\n可以这样使用,写在项目src/components/utils/utils.js文件里：\n// 发抖函数:在一定时间内，只执行最后一次操作，而忽略之前的操作,比如避免向后台频繁提交数据\nexport function debounce(fn, delay) {  \n  let timerId;  \n  \n  return function(...args) {  \n    clearTimeout(timerId); // 清除之前的等待时间  \n  \n    timerId = setTimeout(() => {  \n      fn.apply(this, args);  \n    }, delay);  \n  };  \n}\n按钮：\n<button @click=\"onRefreshDebounced()\"> 微博热搜 </butto>\n引入到页面：\nimport { debounce } from \"@/components/_util/util\";\n\nmethods: {\n    // 箭头函数不会绑定正确的上下文this,这里只能用普通函数\n    onRefreshDebounced: debounce(function () {\n      this.getData();\n      console.log(\"Refreshing data...\");\n    }, 1500),\n    \n    getData() {\n      //。。。获取接口数据\n    }\n}\n\n或者\n\n以下是一个简单的实现防抖函数的例子：在这个函数中，我们使用了闭包来保存一个定时器的ID，并在每次函数被调用时清除之前的定时器。然后，再设置一个新的定时器来延迟执行函数。这样做的目的是为了确保在一定时间内，如果函数被连续调用多次，只有最后一次调用会被执行。\nfunction debounce(fn, delay) {\n  let timerId;\n\n  return function(...args) {\n    clearTimeout(timerId);//清除之前的等待时间\n\n    timerId = setTimeout(() => {\n      fn.apply(this, args);\n    }, delay);\n  };\n}\n\nexport { debounce };\n\n//使用方法示例：\nimport { debounce } from './debounce.js';\n\nconst myFunction = () => {\n  // 要执行的函数逻辑\n};\n\nconst debouncedFunction = debounce(myFunction, 1000); // 创建一个防抖版本的函数\n\n// 在需要限制执行频率的地方调用防抖函数\ndebouncedFunction();\n\n\n\n2）只传一个参数的实用版\n函数防抖是指在一定时间内，只执行最后一次操作，而忽略之前的操作。\n这个版本和第二个带参数的版本在使用上没有太大的不同，但是在实现上有一些细微的差异。\n在这个版本中，我们没有使用剩余参数语法(...args)，而是直接定义了一个没有参数的匿名函数。这意味着在调用debounce函数时，我们只能传入一个函数作为参数，而不能传入任意数量的参数。\n另外，这个版本中的定时器的回调函数直接调用了fn函数，而不是使用apply方法来传递参数。这意味着在调用fn函数时，不会传递任何参数。\n\nfunction debounce(fn, delay) {\n  var timerId;\n  return function() {\n    clearTimeout(timerId);//清除之前的等待时间\n    timerId = setTimeout(fn, delay);\n  };\n}\n//使用：\nvar func = debounce(layout，1000);\nwindow.onresize = func  //在改变窗口的时候不会频繁调用函数，让页面卡顿\n\n\n\n\n\n\n\n\n"
        },
        {
          "label": "使用ladash库",
          "language": "javascript",
          "value": "import debounce from \"lodash/debounce\";"
        }
      ],
      "id": "XWVeHpG_",
      "createdAt": 1688967884934,
      "updatedAt": 1705633749943
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": "JavaScript中的对象解构和数组解构有一些相似之处，但它们实际上是不同的概念",
      "name": "解构和扩展运算符",
      "content": [
        {
          "label": "对象解构",
          "language": "javascript",
          "value": "对象解构（Object Destructuring）：对象解构允许我们从一个对象中提取属性，并将它们赋值给对应的变量。这样可以更方便地获取和使用对象的特定属性。对象解构使用花括号 {} 来表示，变量名与对象的属性名对应。例如：\n注意解构赋值中的变量名必须与要解构的对象中的属性名匹配;\n\nconst obj = { x: 1, y: 2 };\nconst { x, y } = obj;\nconsole.log(x); // 输出 1\nconsole.log(y); // 输出 2\n\n属性简写，它是对象解构的另一种方式：\n\nlet [x, y] = ['a', 'b'];\nlet obj = { x, y }; \nconsole.log(obj); // { x: \"a\", y: \"b\" }\n\n以上代码和下面代码的效果是相同的\n\nvar x = 'a';\nvar y= 'b';\nvar obj2 = {x: x, y: y};\nconsole.log(obj2); // [ x:\"a\",y:\"b\"}"
        },
        {
          "label": "数组解构",
          "language": "javascript",
          "value": "数组解构（Array Destructuring）：数组解构允许我们从一个数组中提取元素，并将它们赋值给对应的变量。这样可以更方便地获取和使用数组中的特定元素。数组解构使用方括号 [] 来表示，变量名与数组的索引对应。例如：\n\nconst arr = [1, 2, 3];\nconst [a, b, c] = arr;\nconsole.log(a); // 输出 1\nconsole.log(b); // 输出 2\nconsole.log(c); // 输出 3\n\n//====================数组本质上也是对象，所以使用对象解构赋值的方式也可以解构数组：\nconst numbers =[\"a\",\"b\",\"c\",\"d\",{a:1,b:2}]\n\nconst {\n  0: n1, //因为数字不是合法的变量名，这里要赋值给字符变量\n  3: n2\n} = numbers;\n\nconsole.log(n1,n2) //a,b\n\n//当然简洁的写法是：\nconst [n1,n2] = numbers//注意[]里面的变量是按照下标顺序的，如果要跳过，需要用空位[, , n, m, , ,]\n//解构数组中的对象属性值\nconst{b} = numbers[4]\nconsole.log(b)//2"
        },
        {
          "label": "对象解构与扩展运算符",
          "language": "javascript",
          "value": "扩展运算符和解构有一定的关系。\n对象解构与扩展运算符：\n当使用对象解构时，可以通过扩展运算符将剩余的属性复制到一个新的对象中。\n\nconst obj = { a: 1, b: 2, c: 3, d: 4 };\nconst { a, b, ...rest } = obj;\nconsole.log(a); // 输出 1\nconsole.log(b); // 输出 2\nconsole.log(rest); // 输出 { c: 3, d: 4 }\n\n数组解构与扩展运算符：\n当使用数组解构时，可以通过扩展运算符将剩余的元素复制到一个新的数组中。\nconst arr = [1, 2, 3, 4, 5];\nconst [first, second, ...rest] = arr;\nconsole.log(first); // 输出 1\nconsole.log(second); // 输出 2\nconsole.log(rest); // 输出 [3, 4, 5]\n\n因此，扩展运算符可以与解构一起使用，用于将对象或数组中的剩余属性或元素复制到新的对象或数组中\n\n\n++++++++++++++++++++++++ 对象上的扩展运算符用于浅拷贝对象的可枚举属性到一个新对象\nconst obj1 = { a: 1, b: 2 };\nconst obj2 = { ...obj1, c: 3 };\nconsole.log(obj2); // 输出 { a: 1, b: 2, c: 3 }\n注意事项：\n如果被复制的对象中含有相同的属性，后面的属性会覆盖前面的属性。\n扩展运算符只能用于浅拷贝，即它只会复制原始对象的一级属性值，如果属性值是引用类型，则复制后的新对象仍然引用同一个内存地址。\n\n++++++++++++++++++++++++ 数组上的扩展运算符用于将一个数组展开为逗号分隔的多个参数。\nconst arr1 = [1, 2, 3];\nconst arr2 = [...arr1, 4, 5];\nconsole.log(arr2); // 输出 [1, 2, 3, 4, 5]\n注意事项：\n扩展运算符只会展开一层，如果数组中的元素是引用类型，则复制后的新数组仍然引用同一个内存地址。\n\n"
        },
        {
          "label": "参数位置的解构",
          "language": "javascript",
          "value": "参数位置的解构是es6应用最多的场景\n\nfunction ajax({\n\tmethod = \"get\", //解构的同时给了一个默认参数\n  url = \"/\",\n  data //可以没有默认值\n}){\n   console.log(method, url)\n}\n\n//ajax的参数是一个对象\najax({\n  url:\"/abc\",\n})\n\n\n//===================看另一个不传参的版本,给参数一个空对象作为默认值，不会报错\nfunction ajax({\n\tmethod = \"get\",\n  url = \"/\",\n  parm\n}={}){ //就是给一个匿名参数了一个默认值，而对象里面的是具名参数\n   console.log(method, url)\n}\n\n//ajax没有参数传递的就是undefined,将会报错，但参数给个默认值就不会报错了\najax()"
        }
      ],
      "id": "boFdQWa_",
      "createdAt": 1689040757355,
      "updatedAt": 1691637101761
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "WblIddgQ",
      "tagsIds": [],
      "description": null,
      "name": "VSCode 必装插件",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "console Ninja  //在vscode里直接返回调试结果\nRandom Everything  //先alt+多选 然后 shift + ctrl + p 输入random 可以选择插入的random数据类型\nQuokka.js //avaScript and TypeScript playground in your editor.Quokka.js is a powerful tool for JavaScript developers that enhances productivity by providing real-time feedback and visibility into code execution.\n//注意 ctrl+shift+p 调出面板输入Quokka后会有各种选项；\n//在代码行后面输入 //? 后有结果\n//ctrl + k  j 新建一个JavaScript文件并启动Quokka\n//ctrl + k q 在当前JavaScript文件下启动运行Quokka\n//ctrl + k e 结束当前文件Quokka\n//ctrl + shift + u 打开output窗口\n别名路径跳转 ：别名路径跳转插件，支持任何项目，可以自由配置映射规则，自由配置可缺省后缀名列表"
        }
      ],
      "id": "lKwo4RaA",
      "createdAt": 1689062868857,
      "updatedAt": 1689835311916
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "",
      "tagsIds": [],
      "description": null,
      "name": "",
      "content": [
        {
          "label": "Fragment 1",
          "value": "Random Everything",
          "language": "plain_text"
        }
      ],
      "id": "htmGgI9J",
      "createdAt": 1689063659387,
      "updatedAt": 1689141350141
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "",
      "tagsIds": [],
      "description": null,
      "name": "create snippet",
      "content": [
        {
          "label": "Fragment 1",
          "value": "电脑",
          "language": "plain_text"
        }
      ],
      "id": "9Kz0MuXZ",
      "createdAt": 1689063776967,
      "updatedAt": 1689141345484
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "",
      "tagsIds": [],
      "description": null,
      "name": "",
      "content": [
        {
          "label": "Fragment 1",
          "value": "电脑",
          "language": "plain_text"
        }
      ],
      "id": "8wyOUwFe",
      "createdAt": 1689063800821,
      "updatedAt": 1689141337410
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "",
      "tagsIds": [],
      "description": null,
      "name": "",
      "content": [
        {
          "label": "Fragment 1",
          "value": "电脑",
          "language": "plain_text"
        }
      ],
      "id": "n0GSXkcC",
      "createdAt": 1689063958305,
      "updatedAt": 1689141334573
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "map 数据的使用",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "let cartMap = new Map(); //创建map\n\n//addTo()是一个按钮点击事件，获取的参数item是一个对象类型\n addTo(item) {\n    let mapItem = cartMap.get(item.id); //get方法是map的方法，用来获取map中的值\n    if (mapItem) {\n        mapItem.num += 1; //\n     } else {\n       let obj = {\n          ...item, // 这里的...item是展开运算符，相当于把item中的所有属性都展开了\n          num: 1,\n        };\n        this.cartList.push(obj);\n        cartMap.set(item.id, obj); // 这里的set方法是map的方法，用来设置map中的值,这里的item.id是key，obj是value\n     }\n }"
        }
      ],
      "id": "yJfGP3L9",
      "createdAt": 1689153144410,
      "updatedAt": 1689153629054
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "6vOxmQF6",
        "sUpoZMyz",
        "MtywOPyV"
      ],
      "description": "object有许多内置属性和方法容易导致错误，而map没有这些；map是可以保持顺序的",
      "name": "数据结构 ",
      "content": [
        {
          "label": "stack 栈结构",
          "language": "javascript",
          "value": " //Stack的实际例子就是一碟盘子，last In First Out (LIFO)\n // push()  pop() 是相反的操作，都是对数组的最后一个元素的操作\n class Stack {\n  //constructor()`构造函数用于初始化栈\n  constructor() {\n    this.items = [];\n    this.count = 0;\n  }\n  \n  //下面全部是方法\n  // Add element to top of stack\n  push(element) {\n    this.items[this.count] = element;\n    console.log(`${element} added to ${this.count}`);\n    this.count += 1; // increment count\n    return this.count - 1; // return the size of the stack\n  }\n  // Return and remove top element in stack\n  // Return undefined if stack is empty\n  pop() {\n    if (this.count == 0) return undefined;\n    console.log(this.count);\n    let deleteItem = this.items[this.count - 1]; // save last element\n    this.count -= 1; // decrement count,count是自定义的，不是数组的\n    console.log(`${deleteItem} removed`);\n    return deleteItem;\n  }\n\n  // Check top element in stack,返回栈顶元素,不改变栈, peek()是自定义的方法，不是内置的方法\n  peek() {\n    console.log(`Top element is ${this.items[this.count - 1]}`);\n    return this.items[this.count - 1];\n  }\n\n  // Check if stack is empty,isEmpty()是自定义的方法\n  isEmpty() {\n    console.log(this.count == 0 ? \"Stack is empty\" : \"Stack is NOT empty\");\n    return this.count == 0;\n  }\n\n  // Check size of stack\n  size() {\n    console.log(`${this.count} elements in stack`);\n    return (this.count = 0);\n  }\n\n  // Print elements in stack\n  print() {\n    let str = \"\";\n    for (let i = 0; i < this.count; i++) {\n      str += this.items[i] + \" \";\n    }\n    return str;\n  }\n\n  // Clear stack\n  clear() {\n    this.items = [];\n    this.count = 0;\n    console.log(\"Stack cleared..\");\n    return this.items;\n  }\n}\n\nconst stack = new Stack();\n\nstack.isEmpty(); //Stack is empty\n\nstack.push(100); // 100 added to 0\n\nstack.push(200); // 200 added to 1\nstack.peek(); // return 200\nstack.push(300); // 300 added to 2,后面的在stack的顶部\n\nconsole.log(stack.print()); // 100,200,300\n\nstack.pop(); // remove 300,从顶部移除\nstack.peek(); // return 200\nstack.pop(); // remove 200\n\nstack.size(); // 1 elements in stack\n\nstack.peek(); // 100\n\nstack.isEmpty(); // Stack is NOT empty\n\nstack.size(); // 1 elements in stack\n\nstack.clear(); // Stack cleared..\n\nstack.size(); // 0 elements in stack\n\n\n这段代码定义了一个名为`Stack`的类，实现了栈的基本功能。下面是每个方法的功能解释：\n- `constructor()`构造函数用于初始化栈，它创建了一个空数组`items`和一个计数器`count`，初始值为0。\n\n- `push(element)`方法用于把元素添加到栈的顶部。它将元素存储在数组`items`的索引为`count`的位置，并将计数器`count`增加1。同时，它会打印出添加的元素和当前栈的大小，并返回栈的大小（即`count - 1`）。\n\n- `pop()`方法用于返回并移除栈顶的元素。如果栈为空，即`count`为0，那么它返回`undefined`。否则，它会保存栈顶的元素到变量`deleteItem`中，并将计数器`count`减少1。同时，它会打印出被移除的元素，并返回该元素的值。\n\n- `peek()`方法用于返回栈顶的元素，但不对栈进行修改。它打印出栈顶的元素，并返回该元素的值。\n\n- `isEmpty()`方法用于检查栈是否为空。如果栈为空，即`count`为0，它会打印出\"Stack is empty\"，并返回`true`；否则，它会打印出\"Stack is NOT empty\"，并返回`false`。\n\n- `size()`方法用于返回栈的大小，即栈中元素的个数。它打印出栈的元素个数，并将计数器`count`重置为0，并返回0。\n\n总之，这段代码实现了一个简单的栈数据结构，并提供了基本的栈操作方法。"
        },
        {
          "label": "queue 队列",
          "language": "javascript",
          "value": "//queue:first in first out or FIFO data structures\n//现实的例子：printer queue \n\nclass Queue\n{\n    constructor()\n    {\n        this.items = []\n    }\n\n    enqueue(value)\n    {\n        this.items.push(value) // add to the end,如果想将数据放在数组的前面，可以使用unshift()方法。\n    }\n\n    dequeue()\n    {\n        if(this.items.length > 0)\n            return this.items.shift() // remove the first element\n    }\n\n    peek()\n    {\n        if(this.items.length > 0)\n            return this.items[0]\n    }\n\n    print()\n    {\n        for(let i = 0; i < this.items.length; i++)\n            console.log(this.items[i])\n    }\n}\n\nconst q = new Queue()\n\nq.enqueue(10)\nq.enqueue(20)\nq.enqueue(30)\n\nq.dequeue(30) // 10 20 30\n\nconsole.log(q.peek()) // 20 \n\nq.print() // 20 30"
        },
        {
          "label": "Sets",
          "language": "javascript",
          "value": "const numbers = [2,2,3,5,6,2,3,3,4,4]\nconst refinedNumbers = new Set(numbers)\nconsole.log(refinedNumbers) // Set { 2, 3, 5, 6, 4 }\n\n//方法has()用于判断Set结构中是否包含某个元素\nconsole.log(refinedNumbers.has(2)) // true\n\nconst newNumbersArray = [...refinedNumbers]\nconsole.log(newNumbersArray) // [ 2, 3, 5, 6, 4 ]\n\n\n在JavaScript中，Set是一种数据类型，用于存储一组唯一的值。以下是Set数据类型的主要方法：\n\nadd(value)：向Set中添加一个值。\ndelete(value)：从Set中删除一个值。\nhas(value)：判断Set中是否存在某个值。\nclear()：清空Set中的所有值。\nsize：返回Set中值的个数。\nkeys()：返回一个包含Set中所有键的迭代器对象。\nvalues()：返回一个包含Set中所有值的迭代器对象。\nentries()：返回一个包含Set中所有键值对的迭代器对象。\nforEach(callbackFn, thisArg)：对Set中的每个值执行一个回调函数。\n这些方法可以帮助你对Set数据类型进行增删改查操作。\n"
        },
        {
          "label": "Map vs Object in JavaScript",
          "language": "javascript",
          "value": "const map = new Map([\n    //key在map可以是任何数据类型，相比object的key只能是string\n    [1, \"one\"],\n    [2, \"two\"]\n]);\n\nconst obj = {\n    //key 在object只能是string,如果是number会被转换成string\n    1: \"one\",\n    2: \"two\"\n}\nconsole.log({ map, obj }); // { map: Map(2) { 1 => 'one', 2 => 'two' }, obj: { '1': 'one', '2': 'two' } }\n\n// Set\nmap.set(3, \"three\");\nobj[3] = \"three\";\n\nconsole.log(map);// Map(3) { 1 => 'one', 2 => 'two', 3 => 'three' }\nconsole.log(obj);// { '1': 'one', '2': 'two', '3': 'three' }\n\n// Get\nconsole.log(\"map get:\", map.get(3)); // map get: three\nconsole.log(\"obj get:\", obj[3]);// obj get: three\n\n// Delete\nmap.delete(3); \ndelete obj[3];\n\n// Keys\nconsole.log(\"map keys:\", map.keys()); // map keys: MapIterator { 1, 2 }\nconsole.log(\"obj keys:\", Object.keys(obj)); // obj keys: [ '1', '2' ]\n\n// Has\nconsole.log(\"map has key 1:\", map.has(2)); // map has key 1 true\nconsole.log(\"obj has key 1:\", 2 in obj);// obj has key 1: true\nconsole.log(\"obj has key 1:\", obj.hasOwnProperty(2))// obj has key 1: true\n\n// Values\nconsole.log(\"map values:\", map.values()); // map values: MapIterator\nconsole.log(\"obj values:\", Object.values(obj)); // obj values: [ 'one', 'two' ]\n\n// Entries\nconsole.log(\"map entries:\", map.entries()); // map entries: MapIterator\nconsole.log(\"obj entries:\", Object.entries(obj));// obj entries: [ [ '1', 'one' ], [ '2', 'two' ] ]\n// Length\nconsole.log(\"map size:\", map.size);// map size: 2\nconsole.log(\"obj size:\",Object.keys(obj).length);// obj size: 2\n\n// Iteration for 在遍历map数据的时候可以保证数据的顺序，而object的顺序是不确定的\nfor (const [key, value] of map) {\n  console.log({ key, value }); // { key: 1, value: 'one' } { key: 2, value: 'two' }\n}\n\nfor (const [key, value] of Object.entries(obj)) {\n  console.log({ key, value }); //  { key: '1', value: 'one' } { key: '2', value: 'two' }\n}\nconst obj1 = { a: 1, b: 2, c: 3 };\n\nfor (let key in obj1) {\n  console.log(key, obj1[key]);\n}\n\n// Iteration forEach\nmap.forEach((value, key) => console.log({ key, value })); //{ key: 1, value: 'one' } { key: 2, value: 'two' }\n\n//entries 返回一个数组，数组的每一项是一个键值对\nObject.entries(obj).forEach((entry) => console.log(entry)); // [ '1', 'one' ] [ '2', 'two' ]\n\n//[key, value] 解构赋值\nObject.entries(obj).forEach(([key, value]) => console.log({ key, value })); // { key: '1', value: 'one' } { key: '2', value: 'two' }\n\n// Swap Keys & Values \n//这段代码是用来创建一个新的 Map 对象，并将原始 Map 对象中的键值对进行交换的操作。\n// Array.from(map) 将 Map 对象转换为数组的目的是为了使用数组的 reduce() 方法来进行迭代和操作,虽然 Map 对象本身是可迭代的，但是它的迭代器只能返回键值对的数组，而不能返回键或值的数组。\n//reduce()的参数是一个函数，这个函数接受四个参数，分别是累加器、当前值、当前索引、源数组，返回值是累加器\nconst swapMap = Array.from(map).reduce((acc, [key, value]) => {\n  //\n  acc.set(value, key);\n  return acc;\n}, new Map()); // new Map()是reduce的第二个参数，是一个空的map对象,初始值为一个新的 Map 对象 new Map()\n//在 reduce 方法的回调函数中，通过解构赋值的方式将子数组的第一个元素作为键，第二个元素作为值。然后，将值作为新 Map 对象的键，原始键作为值，最终将结果保存在累加器 acc 中。\n\nconsole.log(swapMap); // Map(2) { 'one' => 1, 'two' => 2 }\n\nconst swapObj = Object.entries(obj).reduce((acc, [key, value]) =>\n // { acc[value] = key; return acc; },\n({ ...acc,[value]:key }),\n{}); \nconsole.log(swapObj);//{ one: '1', two: '2' }\n\n\n\n/*Map数据类型有以下方法：\n\nset(key, value): 向Map中添加一个键值对。\nget(key): 根据键获取对应的值。\nhas(key): 判断Map中是否存在指定的键。\ndelete(key): 根据键删除对应的键值对。\nclear(): 清空Map中的所有键值对。\nsize: 返回Map中键值对的数量。\nkeys(): 返回一个包含Map中所有键的迭代器对象。\nvalues(): 返回一个包含Map中所有值的迭代器对象。\nentries(): 返回一个包含Map中所有键值对的迭代器对象。\nforEach(callbackFn, thisArg): 遍历Map中的每个键值对，执行指定的回调函数。\n这些方法可以帮助我们在Map数据类型中进行键值对的增删改查操作，并且可以方便地遍历Map中的所有键值对。\n*/\n\njs 如何遍历一个对象？ 要遍历一个对象，你可以使用 JavaScript 中的不同方法。以下是几种常用的遍历对象的方式：\n\n1) 使用 for...in 循环：\nconst obj = { a: 1, b: 2, c: 3 };\n\nfor (let key in obj) {\n  console.log(key, obj[key]);\n}\n\n2)使用 Object.keys() 方法结合 forEach 循环：\nconst obj = { a: 1, b: 2, c: 3 };\n\nObject.keys(obj).forEach(key => {\n  console.log(key, obj[key]);\n});\n\n3)使用 Object.entries() 方法结合 forEach 循环（ES8+）：\nconst obj = { a: 1, b: 2, c: 3 };\n\nObject.entries(obj).forEach(([key, value]) => {\n  console.log(key, value);\n});\n\n4)使用 for...of 循环（ES6+，适用于可迭代对象）：\nconst obj = { a: 1, b: 2, c: 3 };\n\nfor (let [key, value] of Object.entries(obj)) {\n//当你使用 for...of 循环来遍历对象时，你需要使用 Object.entries(obj) 或 Object.keys(obj) 等方法将对象转换为可迭代的形式。Object.entries(obj) 方法将对象的每个键值对都转换为一个数组 [key, value]，它们可以被 for...of 循环逐个迭代。而直接使用 obj 是无法进行迭代的。如果你只关心对象的键，而不需要访问对应的值，你可以使用 Object.keys(obj) 方法获取对象的键数组\n  console.log(key, value);\n}\n\n无论你选择哪种方式，它们都可以帮助你遍历对象的属性和值。请根据你的具体需求选择适合的方法。注意，在使用 for...in 或 for...of 循环时，需要注意属性的遍历顺序可能不会与定义时的顺序一致。\n\n"
        },
        {
          "label": "将对象ID转换为key",
          "language": "javascript",
          "value": "通过将对象的id转化为key，已字典的形式再查询更加高效\nconst people = [\n  { id: \"1\", name: \"Leigh\", age: 35 },\n  { id: \"2\", name: \"Jenny\", age: 30 },\n  { id: \"3\", name: \"Heather\", age: 28 },\n];\n\n// convert to id => person lookup (dict) 以id为key，person为value,这样就可以通过id来查找person了,是更好的数据结构\nresult = people.reduce((acc, person) => {\n    return {...acc, [person.id]: person}\n}, {});\nconsole.log(result); // {1: {…}, 2: {…}, 3: {…}}\n\n现在的查询效率比循环要高效多了：\nconsole.log(result[\"3\"]);// {id: \"3\", name: \"Heather\", age: 28}"
        }
      ],
      "id": "_Zeq1ccR",
      "createdAt": 1689823186954,
      "updatedAt": 1690188958328
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [
        "MapSWFq2",
        "A6GXFH-I",
        "a43hQOW6"
      ],
      "description": null,
      "name": "router 路由相关-2",
      "content": [
        {
          "label": "ATOne 项目JDBC页面",
          "language": "javascript",
          "value": "<template>\n  <el-container>\n    <el-aside width=\"120px\">\n      <el-menu :default-active=\"active\" active-text-color=\"#5faeff\" router>\n        <el-menu-item\n          v-for=\"item in leftMenu\"\n          :key=\"item.route\"\n          :index=\"item.route\"\n          :route=\"item.route\"\n        >\n          <i :class=\"[item.icon]\" />{{ item.name }}\n        </el-menu-item>\n      </el-menu>\n    </el-aside>\n    <el-main style=\"padding-left: 12px; padding-top: 12px\">\n      <router-view />\n    </el-main>\n  </el-container>\n</template>\n\n<script>\nimport { permissionCheck } from '@/utils/permissionCheck'\n\nexport default {\n  name: 'JdbcManagement',\n  data() {\n    return {\n      active: this.$route.path, //重点\n      leftMenu: [\n        {\n          name: '用例管理',\n          route: '/jdbc/plan',\n          icon: 'iconfont icon-banben',\n          permission: 'jdbcSql'\n        },\n        {\n          name: '执行记录',\n          route: '/jdbc/runRecord',\n          icon: 'el-icon-trophy',\n          permission: 'jdbcRunRecord'\n        },\n        {\n          name: '执行计划',\n          route: '/jdbc/RunPlan',\n          icon: 'iconfont icon-xitongguanli_canshushezhi',\n          permission: 'jdbcRunRecord'\n        }\n      ]\n    }\n  },\n  mounted() {\n    if (\n      this.$route.path === '/jdbc/management' ||\n      this.$route.path === '/jdbc/func/' ||\n      this.$route.path === '/jdbc/case/'\n    ) {\n      this.active = '/jdbc/plan'\n    } else if (this.$route.path.includes('/jdbc/runRecord')) {\n      this.active = '/jdbc/runRecord'\n    }\n    this.leftMenu = permissionCheck(\n      this.$store.getters.getRolePermissions(),\n      this.leftMenu,\n      'permission'\n    )\n  }\n}\n</script>\n\n<style scoped>\n.el-main {\n  margin: 0;\n  padding: 0;\n}\n\n.el-container {\n  height: calc(100vh - 70px);\n}\n.el-aside {\n  border-right: solid 1px #e6e6e6;\n}\n</style>\n\n\n//  import { permissionCheck } from '@/utils/permissionCheck.js' 这个js文件\nexport const permissionCheck = function(rolePermissions, menus, permissionCol) {\n  return menus.filter((item) => {\n    if (rolePermissions) {\n      return rolePermissions.indexOf(item[permissionCol]) > -1  // > -1 表示有\n    }\n  })\n}\n"
        },
        {
          "label": "this.$route.path",
          "language": "javascript",
          "value": "// 用动态class覆盖前面一个class实现定制化样式.注意最终的class可以继承之前class的属性\n\n<section class=\"app-main\" :class=\"mainClass\">\n   //用路由的唯一性作为key,强制页面刷新\n  <router-view :key=\"key\" />\n</section>\n\ncomputed: {\n  key() {\n      return this.$route.path;\n  },\n  mainClass() {\n      const currentPath = this.$route.path;\n      if (currentPath === \"/graph/graph/visual/index\") {\n        return \"app-main_darkBg\";\n      }\n    },\n}"
        },
        {
          "label": "舆情项目判断二级侧边栏",
          "language": "javascript",
          "value": "<sidebar v-show=\"sideBarShow\"/>\n\n<div :style=\"fullContent\" :class=\"{hasTagsView:needTagsView}\" class=\"main-container\">\n\n</div>\n    \ncomputed: {\n    fullContent(){\n      return {'margin-left': this.$route.path === '/index' || this.$route.path === '/meta/metadata' ? '12px' : '200px'}\n    },\n    sideBarShow(){\n      return this.$route.path !== '/index' && this.$route.path !== '/meta/metadata'\n    },\n}"
        }
      ],
      "id": "25Y802Po",
      "createdAt": 1690033918620,
      "updatedAt": 1698746686431
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "-fio_qG6",
      "tagsIds": [
        "MapSWFq2"
      ],
      "description": null,
      "name": "组件之间通信-2",
      "content": [
        {
          "label": "事件总线模式",
          "language": "javascript",
          "value": "如果你在项目中需要更加复杂的组件间通信，可以考虑使用事件总线模式。Vue.js 中有多种方式来实现事件总线，比如使用一个全局的 Vue 实例作为事件中心，或者使用第三方库如 EventBus。通过事件总线，可以实现任意组件之间的通信，不仅限于父子组件关系。\n在这个示例中，我们创建了一个全局的 eventBus 实例作为事件中心。子组件通过 eventBus.$emit 触发自定义事件，并将数据传递给父组件。父组件通过 eventBus.$on 监听自定义事件，并在事件发生时调用相应的方法处理子组件传递的数据。\n请注意，在使用事件总线模式时，需要确保全局的 eventBus 实例被正确引入并创建，以及在适当的时机取消监听自定义事件，避免造成内存泄漏。\n此代码是引跑项目实际案例：\n\n// main.js\nimport Vue from 'vue';\n\n// 创建一个全局的 EventBus\nexport const eventBus = new Vue();\n\n// ...\n\n// ChildComponent.vue\n<template>\n  <div>\n    <button @click=\"modifyExecEnv\">执行异步操作</button>\n  </div>\n</template>\n\n<script>\nimport { eventBus } from './main.js';\n\nexport default {\n  methods: {\n    async modifyExecEnv() {\n      // 执行异步操作\n      \n      await yourAsyncFunction();\n      \n      this.$message.success('修改测试计划运行环境信息成功。');\n      \n      // 触发自定义事件，将数据传递给父组件\n      eventBus.$emit('modifyExecEnvSuccess', yourData);\n    },\n  },\n};\n</script>\n\n// ParentComponent.vue\n<template>\n  <div>\n    <ChildComponent />\n    <button @click=\"onConfirm\" :disabled=\"buttonDisabled || loading\">\n      <span v-if=\"loading\">\n        <i class=\"el-icon-loading\"></i>\n        加载中...\n      </span>\n      <span v-else>确定</span>\n    </button>\n  </div>\n</template>\n\n<script>\nimport { eventBus } from './main.js';\n\nexport default {\n  data() {\n    return {\n      buttonDisabled: false,\n      loading: false,\n    };\n  },\n  created() {\n    // 监听自定义事件，处理子组件传递的数据\n    eventBus.$on('modifyExecEnvSuccess', this.onModifyExecEnvSuccess);\n  },\n  beforeDestroy() {\n    // 取消监听自定义事件\n    eventBus.$off('modifyExecEnvSuccess', this.onModifyExecEnvSuccess);\n  },\n  methods: {\n    onModifyExecEnvSuccess(data) {\n      // 处理子组件传递的数据\n      console.log(data);\n      this.loading = false;\n    },\n    onConfirm() {\n      this.buttonDisabled = true;\n      this.loading = true;\n      \n      // 执行其他操作\n      \n      // 模拟异步操作\n      setTimeout(() => {\n        this.loading = false;\n      }, 2000);\n    },\n  },\n};\n</script>"
        },
        {
          "label": "$emit 和自定义事件",
          "language": "javascript",
          "value": "以下为引跑项目atone实际案例,实现点击确定提交按钮后，按钮显示加载中...等待数据处，\n$emit是内置的方法,父元素用@接收子组件事件,但本例没有使用到\n//=============================================== 父组件\n<template>\n  <div>\n    //这里传递给子组件一个方法名enableConfirmButton，子组件在一个你希望的位置触发这个方法,而这个方法可以执行你希望的结果在页面的任何位置\n    <ChildComponent :enable-confirm-button=\"enableConfirmButton\" />\n    //子组件$emit()的信息可以改变这个按钮的状态，如恢复禁用，显示loading等\n    <button :disabled=\"buttonDisabled || loading\" @click=\"onConfirm\">\n      <span v-if=\"loading\">\n        <i class=\"el-icon-loading\"></i>\n        加载中...\n      </span>\n      <span v-else>确定</span>\n    </button>\n  </div>\n</template>\n\n<script>\nimport ChildComponent from './ChildComponent.vue';\n\nexport default {\n  components: {\n    ChildComponent,\n  },\n  data() {\n    return {\n      buttonDisabled: false,\n      loading: false,\n    };\n  },\n  methods: {\n    //这个方法可以被子组件触发\n    enableConfirmButton() {\n      this.buttonDisabled=false\n      this.loading = false;\n    },\n    onConfirm() {\n      this.buttonDisabled = true;\n      this.loading = true;\n      //下面的操作会在另一个外部组件执行, this.loading = false;需要通过 this.$emit('enableConfirmButton')传递过来\n\t\t\tthis.$refs[this.setRef[this.stepArr.active - 1]].stepNext()\n    },\n  },\n};\n</script>\n\n<script>\n//======================================================= 子组件\n    modifyExecEnv() {\n      apiScheduler.modifyExecEnv(this.envData).then((res) => {\n        if (res.code === '0') {\n          this.$message.success('修改测试计划运行环境信息成功')\n\n          this.$emit('enableConfirmButton')  //就是这一句向父组件发送信息触发父组件的方法enableConfirmButton()改变按钮状态\n          \n          // 跳转到计划详情\n          this.$router.push(`/scheduler/plan-details/${this.envData.id}`)\n        } else { this.$message.error(`修改测试计划运行环境信息失败。 ${res.msg}`) }\n      })\n    }\n</script>"
        }
      ],
      "id": "2v6gYqii",
      "createdAt": 1690442160401,
      "updatedAt": 1690449112028
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3BVGYMMN",
      "tagsIds": [],
      "description": null,
      "name": "Grid布局",
      "content": [
        {
          "label": "Fragment 1",
          "language": "css",
          "value": ".meals {\n  display: grid;\n  grid-template-columns: repeat(4, 1fr);\n  grid-gap: 20px;\n  margin-top: 20px;\n}"
        }
      ],
      "id": "PLbmSeIm",
      "createdAt": 1690601241163,
      "updatedAt": 1690699414913
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3BVGYMMN",
      "tagsIds": [
        "38-kGUGm",
        "4FgER6K6",
        "_WKR4zEa"
      ],
      "description": null,
      "name": "媒体查询",
      "content": [
        {
          "label": "Fragment 1",
          "language": "css",
          "value": "@media (max-width: 800px) {\n  .meals {\n    grid-template-columns: repeat(3, 1fr);\n  }\n}\n@media (max-width: 700px) {\n  .meals {\n    grid-template-columns: repeat(2, 1fr);\n  }\n\n  .meal {\n    height: 200px;\n    width: 200px;\n  }\n}\n@media (max-width: 500px) {\n  input[type='text'] {\n    width: 100%;\n  }\n\n  .meals {\n    grid-template-columns: 1fr;\n  }\n\n  .meal {\n    height: 300px;\n    width: 300px;\n  }\n}"
        }
      ],
      "id": "3OhxIYkT",
      "createdAt": 1690685524812,
      "updatedAt": 1690772286050
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3BVGYMMN",
      "tagsIds": [],
      "description": null,
      "name": "hover 效果",
      "content": [
        {
          "label": "图片hover有标题和遮罩",
          "language": "css",
          "value": "\n思路：跟简单，hover的div先绝对定位并把opacity设置为0; hover在设置成1即可\n//.maels是父容器，用grid布局\n.meals {\n  display: grid;\n  grid-template-columns: repeat(4, 1fr);\n  grid-gap: 20px;\n  margin-top: 20px;\n}\n.meal {\n  cursor: pointer;\n  position: relative;\n  height: 180px;\n  width: 180px;\n  text-align: center;\n}\n\n.meal img {\n  width: 100%;\n  height: 100%;\n  border: 4px #fff solid;\n  border-radius: 2px;\n}\n\n.meal-info {\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  width: 100%;\n  background: rgba(0, 0, 0, 0.7);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transition: opacity 0.2s ease-in;\n  opacity: 0;\n}\n\n.meal:hover .meal-info {\n  opacity: 1;\n}"
        },
        {
          "label": "box-shadow：hover后元素出现阴影",
          "language": "css",
          "value": "hover后元素出现阴影：\n.elemnt:hover{\n   box-shadow: 0 5px 15px 3px rgba(177, 183, 208, 0.33);\n}"
        }
      ],
      "id": "4zQnVoPT",
      "createdAt": 1690701310198,
      "updatedAt": 1695362293132
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3BVGYMMN",
      "tagsIds": [
        "EZljjTGm",
        "SFDkpVg8"
      ],
      "description": "animation属性；animation-delay；.circle:nth-of-type(2)",
      "name": "三个跳动的点-loading",
      "content": [
        {
          "label": "Fragment 1",
          "language": "css",
          "value": "<div class=\"loader\">\n  <div class=\"circle\"></div>\n  <div class=\"circle\"></div>\n  <div class=\"circle\"></div>\n</div>\n\n// css\n.loader {\n  opacity: 0;\n  display: flex;\n  position: fixed;\n  bottom: 50px;\n  transition: opacity 0.3s ease-in;\n}\n\n.loader.show {\n  opacity: 1;\n}\n\n.circle {\n  background-color: #fff;\n  width: 10px;\n  height: 10px;\n  border-radius: 50%;\n  margin: 5px;\n  animation: bounce 0.5s ease-in infinite; \n}\n\n.circle:nth-of-type(2) {\n  animation-delay: 0.1s;\n}\n\n.circle:nth-of-type(3) {\n  animation-delay: 0.2s;\n}\n\n@keyframes bounce {\n  0%,\n  100% {\n    transform: translateY(0);\n  }\n\n  50% {\n    transform: translateY(-10px);\n  }\n}"
        }
      ],
      "id": "hcqM-7b8",
      "createdAt": 1691307569615,
      "updatedAt": 1691308416405
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "sCWt0xKF"
      ],
      "description": null,
      "name": "js 循环对比",
      "content": [
        {
          "label": "用时对比和概念",
          "language": "javascript",
          "value": "易错基础题: JS中三类循环对比及性能分析?\n\n  for循环及forEach底层原理\n*+ FOR循环是自己控制循环过程\n    Q1:基于var声明的时候，FOR和WHILE性能差不多 不确定循环次数的情况下使用WHILE\n    Q2:基于let声明的时候，FOR循环性能更好原理: 没有创造全局不释放的变量\n    \n*+  Q3:重写FOR-EACH\n    Array.prototype.forEach = function(callback, context){\n    let self = this,\n        i = 0,\n        len = self.length;\n    context = context == null ? window : context;\n    for (; i < len; i++) {\n        typeof callback === \"function\" ? callback.call(context, self[i], i) : null;\n        }\n    };\n\n*+\tfor in循环的BUG及解决方案\n     if (!obj.hasOwnProperty(key)) break;//只遍历私有属性\n     Q1:迭代所有可枚举属性 私有&公有，按照原型链一级级查找很耗性能\n     Q2:问题很多:不能选代Symbol属性、迭代顺序会以数字属性优先、公有可枚举的一般是自定义属性》属性也会进行迭代\n     \n*+  for of循环的底层机制\n     for of循环的原理是按照迭代器规范遍历的,注意对象没有迭代器iterator规范，所以是不可迭代的\n     Q1:迭代器iterator规范 (Symbol.iterator)[具备next方法，每次执行返回一个对象，具备 value/done 属性]\n     Q2:让对象具备可迭代性并且使用for of循环\n\n\nlet arr = new Array(9999999).fill(0);\n\n//========================= for循环 的速度极快，但是命令式编程的风格，适合处理大数据量的情况\nconsole.time('FOR~~');\nfor(let i = 0; i < arr.lentth; i++) {}\nconsole.timeEnd('FOR~~'); // FOR~~: 0.007080078125 ms\n\n//=========================== while循环 \nconsole.time('WHILE~~');\nlet j = 0;\nwhile (j < arr.length) {\n\tj++;\n}\nconsole.timeEnd('WHILE~~'); //WHILE~~: 17.644775390625 ms\n\n//============================ forEach 是封装过的函数式编程的风格，使用方便但无法管控过程，如不能中断，有性能消耗\nconsole.time('FOREACH~~');\narr.forEach(function (item) {});\nconsole.timeEnd('FOREACH~~'); //FOREACH~~: 60.17822265625 ms\n\n//===========================FOR IN 是最垃圾的循环耗时巨大，其查找机制上一定会搞到原型链上去\nconsole.time('FOR IN~~');\nfor (let key in arr){}\nconsole.timeEnd('FOR IN~~'); //FOR IN~~: 2102.823974609375 ms\n\n//========================= 'FOR OF\nconsole.time('FOR OF~~');\nfor (const val of arr) {}\nconsole.timeEnd('FOR OF~~');//FOR OF~~: 69.118896484375 ms\n\n//+++++++++++++++++++++++++++ FOR OF 的内部机制\narr = [10,20,30];\narr[Symbol.iterator] = function () {\n    let self = this\n    index = 0\n\t\treturn {\n\t\t\t// 必须具备next方法，执行一次next方法，拿到结构中的某一项的值\n    \t// done:false value:每一次获取的值\n    \t\tnext() {\n\t\t\t\t\tif (index > self.length - 1) {\n   \t\t\t\t\t return { //这里返回的是一个对象\n                done: true,\n                value: undefined\n                    }\n             }\n           //index += 2   //这里可以控制迭代的执行过程\n\t\t\t\t\treturn {\n                done: false,\n                //value: self[index]\n                value: self[index++]\n          }\n       }\n    }\n}\n\nfor (const val of arr) {\n    console.log(val)\n}\n\n//++ obj[Symbol.iterator] = Array.prototype[Symbol.iterator] 让不可迭代的对象成为可迭代的\n//类数组对象默认不具备迭代器规范\nlet obj = {\n  0: 200,\n  1: 300,\n  2: 400,\n  length: 3\n}\n//使用 Object.entries(obj) 将对象 obj 转换为键值对数组。然后，通过 for...of 循环和解构赋值来同时访问键和值\nfor (let [key, value] of Object.entries(obj)) {\n  console.log(key, value);\n}\n// 给对象添加一个可迭代的属性；Array.prototype[Symbol.iterator]; 很简单不过是Array.prototype上的一个属性而已\nobj[Symbol.iterator] = Array.prototype[Symbol.iterator];\nfor (let val of obj) {\n  //注意这里很方便，是直接输出属性的值\n\tconsole.log(val)\n};//输出200  300  400\n"
        },
        {
          "label": "forEach应用在对象上",
          "language": "javascript",
          "value": "forEach()方法是用于遍历数组的，它是数组对象的内置方法，不适用于直接遍历普通对象。\n然而，如果你希望在对象上应用类似的迭代方法，可以考虑使用Object.keys()或Object.entries()方法来获取对象的键或键值对数组，然后再使用forEach()方法进行遍历。通过这种方式，我们可以模拟在对象上应用类似于forEach()的遍历操作，但实际上是先获取对象的键或键值对数组，然后再对数组进行遍历。示例\n\nconst obj = {\n  name: \"John\",\n  age: 30,\n  city: \"New York\"\n};\n\nObject.keys(obj).forEach(function(key) {\n  console.log(key + \": \" + obj[key]);\n});\n//输出：\nname: John\nage: 30\ncity: New York"
        },
        {
          "label": "forEach的第二个参数",
          "language": "javascript",
          "value": "function printElement(element) {\n  console.log(this.prefix + element);\n}\n\nconst arr = [1, 2, 3];\n\narr.forEach(printElement, { prefix: 'Number' });\n//第二个参数context是可选的上下文对象，它用于指定回调函数中的this值。\n//输出：\nNumber1\nNumber2\nNumber3\n\n\n//========================================\n第二个参数context是可选的上下文对象，它用于指定回调函数中的this值。\n在JavaScript中，this关键字通常指向当前执行上下文的对象。当使用forEach方法遍历数组时，回调函数内部的this默认指向全局对象（通常是window对象）。但是，有时我们希望在回调函数中访问其他对象的属性或方法，这时可以使用context参数来指定回调函数内部的this值。\n通过将一个对象作为context参数传递给forEach方法，可以确保在回调函数中使用this时引用的是指定的上下文对象。这样，回调函数就可以在访问该对象的属性和方法时获取正确的值。示例：\n\nconst obj = {\n  name: \"John\",\n  sayHello: function() {\n    console.log(`Hello, ${this.name}!`);\n  }\n};\n\nconst arr = [1, 2, 3];\n\narr.forEach(function(element) {\n  // 在这里，this指向obj对象\n  console.log(this); // 输出: {name: \"John\", sayHello: ƒ}\n  this.sayHello(); // 输出: Hello, John!\n}, obj);"
        }
      ],
      "id": "PVB0SQ5Z",
      "createdAt": 1691659440242,
      "updatedAt": 1691741763516
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": "ajax有回调地狱问题，axios是基于Promise封装的ajax库，解决了回调地狱的问题",
      "name": "ajax、axios、fetch",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "==============+ ajax的核心是局部刷新， ajax的四步是其他方式的基础：\n\t// 发送请求，默认是异步的\n\tlet xhr = new XMLHttpRequest;\n\txhr.open(option.method, option.url);//默认是异步的\n\txhr.onreadystatechange = function () {\n\t\tif (/^2\\d{2}$/.test(xhr.status) && xhr.readyState === 4) {\n\t\t\t// 成功从服务器获取结果  JSON字符串\n\t\t\ttypeof option.success === \"function\" ? option.success(JSON.parse(xhr.responseText)) : null;\n\t\t}\n\t};\n\txhr.send(option.data);\n  \n  //-------------------------- jquery的范式对 ajax基于回调函数进行了封装（所以有回调地狱问题），简化了写法\n    $.ajax({\n        url: 'http://127.0.0.1:8888/user/list',\n        method: 'get',\n        success(result) {\n            console.log(result);\n        }\n    });\n    \n    // 用户登录\n// 登录成功 -> 获取用户信息\n\n/* $.ajax有回调地狱问题 */\n/* $.ajax({\n    url: 'http://127.0.0.1:8888/user/login',\n    method: 'post',\n    data: Qs.stringify({\n        account: '18310612838',\n        password: md5('1234567890')\n    }),\n    success(result) {\n        if (result.code === 0) {\n            // 登录成功\n            $.ajax({\n                url: 'http://127.0.0.1:8888/user/list',\n                method: 'get',\n                success(result) {\n                    console.log(result);\n                }\n            });\n        }\n    }\n}); */\n  \n===============+ axios是基于Promise封装的ajax库\n\n/!* Axios也是对ajax的封装，基于Promise管理请求，解决回调地狱问题（await）这里是对上面$.ajax回调地狱的重写 *!/\n(async function () {\n    let result = await axios.post('/user/login', {\n        account: '18310612838',\n        password: md5('1234567890')\n    });\n\n    result = await axios.get('/user/list');\n    console.log(result);\n})(); \n\n===============+ fetch是ES6新增的通信方法，不是ajax,是浏览器内置的函数，基于fetch可以向服务器发送请求，核心原理和AJAX XMLHttpRequest 不一致 (天生就是基于Promise管理的)，不论服务器返回的状态码是多少，都按照PROMISE成功算；只有断网，才算失败\n  \n  (async function () {\n    let result = await fetch('http://127.0.0.1:8888/user/login', {\n        method: 'post',\n        headers: {\n            'Content-Type': 'application/x-www-form-urlencoded' //headers里不设置有报错\n        },\n        body: Qs.stringify({\n            account: '18310612838',\n            password: md5('1234567890')\n        })\n    }).then(response => {\n        return response.json();\n    });\n\n    result = await fetch('http://127.0.0.1:8888/user/list').then(response => {\n        return response.json();\n    });\n    console.log(result);\n})();\n  "
        }
      ],
      "id": "kMrFS6gz",
      "createdAt": 1691917971157,
      "updatedAt": 1691986117392
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "MqWdF2i4",
      "tagsIds": [],
      "description": null,
      "name": "accept 属性",
      "content": [
        {
          "label": "Fragment 1",
          "language": "html",
          "value": "优点：在弹出的选择内容中，将只有accept的类型是可选择的，其他后缀将是灰色不可点击状态\n/*accept用于限定文件的格式 */\n<input type=\"file\" class=\"upload_inp\" accept=\".png,.jpg,.gif\">"
        }
      ],
      "id": "gEtL4cUG",
      "createdAt": 1692107510689,
      "updatedAt": 1692107688686
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "F_GVDzNT",
        "RQFn3oQg"
      ],
      "description": null,
      "name": "事件委托/代理  Event Delegation ",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "    \n+ 事件代理的特点有点在于处理动态创建的子元素时特别有效;\n\n Event Delegation 基于事件冒泡的原理，在DOM树的较高层次上监听事件，而不是在每个子元素上单独绑定事件监听器;事件委托/代理的优势在于减少了事件处理程序的数量，提高了性能，并且可以动态处理新增的子元素，而无需为每个子元素重新绑定事件监听器。特别在对于大量的子元素或动态生成的元素时，使用事件委托/代理可以更加高效地处理事件。\n\n// 使用事件委托/代理，将点击事件委托给父元素\nconst parentElement = document.querySelector('.parent');\n\nparentElement.addEventListener('click', function(event) {\n  // 判断触发事件的元素\n  if (event.target.matches('.child')) {\n    console.log('Child element clicked'); // 执行相应的操作\n  }\n});\n\n\n//============================= 另一个实例\n    upload_list.addEventListener('click', function (ev) {\n        let target = ev.target;\n        if (target.tagName === \"EM\") { //<em>移除</em> 是动态创建的子元素，通过点击父元素获取子元素\n            // 点击的是移除按钮\n            clearHandle();\n        }\n    });\n    \n   // 移除按钮的点击处理\n    const clearHandle = () => {\n        _file = null;\n        upload_tip.style.display = 'block';\n        upload_list.style.display = 'none';\n        upload_list.innerHTML = ``;\n    };\n    \n     // 显示上传的文件,这里动态创建了 <em>移除</em>元素\n    upload_tip.style.display = 'none';\n    upload_list.style.display = 'block';\n    upload_list.innerHTML = `<li>\n        <span>文件：${file.name}</span>\n        <span><em>移除</em></span>\n    </li>`;"
        },
        {
          "label": "基于事件委托实现移除的操作",
          "language": "javascript",
          "value": "// 基于事件委托实现移除的操作\nupload_list.addEventListener('click', function (ev) {\n    let target = ev.target,\n        curLi = null,\n        key;\n    if (target.tagName === 'EM') {\n        curLi = target.parentNode.parentNode;\n        if (!curLi) return;\n        upload_list.removeChild(curLi);\n        key = curLi.getAttribute('key');\n        //核心是这里，重新生成数据\n        _files = _files.filter(item => item.key !== key);\n        if (_files.length === 0) {\n            upload_list.style.display = 'none';\n        }\n    }\n});"
        }
      ],
      "id": "sfP-iTyU",
      "createdAt": 1692108363083,
      "updatedAt": 1692179798860
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "MFd514cI",
      "tagsIds": [
        "vANPuwsS",
        "maUTSzjB"
      ],
      "description": null,
      "name": "flag 使用",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "\n //======================================= 添加或去除特定的css类\n //下面的处理可以代替防抖，根据代码运行的阶段，添加loading、disable或去除，注意写法并不需要else\n const changeDisable = flag => {\n    if (flag) {\n        upload_button_select.classList.add('disable');\n        upload_button_upload.classList.add('loading');\n        return;\n    }\n    upload_button_select.classList.remove('disable');\n    upload_button_upload.classList.remove('loading');\n};\n\n//使用\nchangeDisable(true)\nchangeDisable(false)\n\n\n//================================================ 让按钮不可点击，可以配合上面一起使用\n// 验证是否处于可操作性状态\nconst checkIsDisable = element => {\n    let classList = element.classList;\n    return classList.contains('disable') || classList.contains('loading');\n};\n\nupload_button_upload.addEventListener('click', async function () {\n    // 如果有disable或loading类存在，跳出程序，也就是按钮不可点击状态\n    if (checkIsDisable(this)) return;\n    ..."
        }
      ],
      "id": "t4JrawEr",
      "createdAt": 1692155706073,
      "updatedAt": 1692169608364
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "MFd514cI",
      "tagsIds": [],
      "description": null,
      "name": "Untitled snippet",
      "content": [
        {
          "label": "Fragment 1",
          "language": "plain_text",
          "value": "//================================================ 让按钮不可点击\n// 验证是否处于可操作性状态\nconst checkIsDisable = element => {\n    let classList = element.classList;\n    return classList.contains('disable') || classList.contains('loading');\n};\n\nupload_button_upload.addEventListener('click', async function () {\n    // 如果有disable或loading类存在，跳出程序，也就是按钮不可点击状态\n    if (checkIsDisable(this)) return;\n    ..."
        }
      ],
      "id": "nlXPNR1W",
      "createdAt": 1692158978613,
      "updatedAt": 1692159037751
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "MFd514cI",
      "tagsIds": [],
      "description": null,
      "name": "让按钮不可点击",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "//================================================ 让按钮不可点击\n// 验证是否处于可操作性状态\nconst checkIsDisable = element => {\n    let classList = element.classList;\n    return classList.contains('disable') || classList.contains('loading');\n};\n\nupload_button_upload.addEventListener('click', async function () {\n    // 如果有disable或loading类存在，跳出程序，也就是按钮不可点击状态\n    if (checkIsDisable(this)) return;\n    ..."
        }
      ],
      "id": "FMmlI9_F",
      "createdAt": 1692159031141,
      "updatedAt": 1692169619799
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "mIczLajv"
      ],
      "description": null,
      "name": "基于BASE64实现文件上传",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "/* 基于BASE64实现文件上传 */\n(function () {\n    let upload = document.querySelector('#upload2'),\n        upload_inp = upload.querySelector('.upload_inp'),\n        upload_button_select = upload.querySelector('.upload_button.select');\n\n    // 验证是否处于可操作性状态\n    const checkIsDisable = element => {\n        let classList = element.classList;\n        return classList.contains('disable') || classList.contains('loading');\n    };\n\n    // 把选择的文件读取成为BASE64,传一个file对象，转换为BASE64格式\n    const changeBASE64 = file => {\n        return new Promise(resolve => {\n           //核心是这个 FileReader()是JS内置的方法,实现了BASE64\n            let fileReader = new FileReader();\n            fileReader.readAsDataURL(file);\n            //fileReader需要异步获取所以用.onload\n            fileReader.onload = ev => {\n                resolve(ev.target.result);\n            };\n        });\n    };\n\n    upload_inp.addEventListener('change', async function () {\n        let file = upload_inp.files[0],\n            BASE64,\n            data;\n        if (!file) return;\n        if (file.size > 2 * 1024 * 1024) {\n            alert('上传的文件不能超过2MB~~');\n            return;\n        }\n        upload_button_select.classList.add('loading');\n        BASE64 = await changeBASE64(file);\n        try {\n            data = await instance.post('/upload_single_base64', { //instance是封装过的axios的实例\n                file: encodeURIComponent(BASE64),//编码防止服务端乱码\n                filename: file.name\n            }, {\n                headers: {\n                     //BASE64需要这个文件头\n                    'Content-Type': 'application/x-www-form-urlencoded'\n                }\n            });\n            if (+data.code === 0) {\n                alert(`恭喜您，文件上传成功，您可以基于 ${data.servicePath} 地址去访问~~`);\n                return;\n            }\n            throw data.codeText; //这里抛出错误后，下面才可以catch到\n        } catch (err) {\n            alert('很遗憾，文件上传失败，请您稍后再试~~');\n        } finally { //不论是成功还是失败都执行这里\n            upload_button_select.classList.remove('loading');\n        }\n    });\n    upload_button_select.addEventListener('click', function () {\n        if (checkIsDisable(this)) return;\n        upload_inp.click(); //upload_inp是页面里被隐藏的那个原生input按钮\n    });\n})();"
        }
      ],
      "id": "YXJi0Df9",
      "createdAt": 1692159204691,
      "updatedAt": 1692170102084
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "MFd514cI",
      "tagsIds": [
        "cH71p1QA",
        "Y7mQg92x"
      ],
      "description": null,
      "name": "延迟函数",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "// 延迟函数\nconst delay = function delay(interval) {\n    typeof interval !== \"number\" ? interval = 1000 : null;\n    return new Promise(resolve => {\n        setTimeout(() => {\n            resolve();\n        }, interval);\n    });\n};\n\n// 使用\ndelay(300);\n//或\nawait delay(300);"
        }
      ],
      "id": "I8nV96Qz",
      "createdAt": 1692170614854,
      "updatedAt": 1692170710444
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "TGQqRGFr",
      "tagsIds": [],
      "description": "目的是绕过浏览器的同源策略，让服务器之间请求",
      "name": "代理服务器设置",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "const express = require('express');\nconst app = express(); //创建服务器\n\n//接受对路径 /hero的 GET 请求\napp.get('/hero', async (req，res) =>{\n  // 使用CORS解决对代理服务器的跨域\n  res.header('access-control-allow-origin', '*');\n  //响应一段测试文本\n  res.send('你好，我是你忠实的代理');\n})\n\n//监听9527端口\napp.listen(9527,()=>{\n\tconsole.log('服务器已启动');\n})"
        }
      ],
      "id": "247aPLNq",
      "createdAt": 1692240132065,
      "updatedAt": 1692240409597
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "MFd514cI",
      "tagsIds": [
        "tnE1auCZ"
      ],
      "description": "Reflect.ownKeys()可以判断所有包括Symbol 类型，其他的都不行",
      "name": "判断对象为空",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "//Reflect.ownKeys() 方法\nfunction isEmpty5(obj) {\n\treturn Reflect.ownKeys(obj).length === 0;\n}\n/*Reflect.ownKeys() 方法是 ES6 引入的一个反射 API，它提供了对对象自身属性（包括 Symbol 类型）的访问和操作。在大多数情况下，使用 Object.keys() 或 for...in 循环已经足够来判断对象是否为空。然而，若需要获取对象自身的所有键，包括 Symbol 类型的键，可以使用 Reflect.ownKeys() 方法 */\n\n//使用Object.keys()方法：通过获取对象的所有键，并判断键的数量是否为0，来判断对象是否为空。示例代码如下：\nfunction isObjectEmpty(obj) {\n   return Object.keys(obj).length === 0;\n}\n//使用for...in循环：遍历对象的属性，在循环过程中如果有属性存在，则对象不为空。示例代码如下\nfunction isObjectEmpty(obj) {\n   for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n         return false;\n      }\n   }\n   return true;\n}\n//使用JSON.stringify()方法：将对象转换为JSON字符串，然后判断\nfunction isObjectEmpty(obj) {\n   return JSON.stringify(obj) === '{}';\n}\n\n// 示例使用\nconst myObj = {};\nconsole.log(isObjectEmpty(myObj)); // 输出：true\n\nconst myNonEmptyObj = { name: \"John\", age: 30 };\nconsole.log(isObjectEmpty(myNonEmptyObj)); // 输出：false"
        }
      ],
      "id": "UvF9e-Q_",
      "createdAt": 1692492708846,
      "updatedAt": 1692493461926
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "OEEtQJ4O",
      "tagsIds": [],
      "description": null,
      "name": "Untitled snippetUntitled snippet",
      "content": [
        {
          "label": "Fragment 1",
          "language": "c_cpp",
          "value": "#include <cs50.h>\n#include <stdio.h>\n\n//函数放在调用体的下面报错，可以这样处理\nint get_size(void);\nvoid print_grid(int size);\n\nint main(void)\n{\n  // Get size of grid\n  int n = get_size();\n  \n  // Print grid of bricks\n  print_grid(n);//print  is a void function,it returns nothing\n}\n\nint get_size(void) //void不传参数\n{\n  int n;\n  do\n  {\n  \t\tn = get_int(\"Size: \");\n  }\n  while(n<1); \n  return n;\n}\n\nvoid print_grid(int size)\n{\n    for (int i = 0; i < size; i++)\n    {\n        for (int j = 0; j < size; j++)\n        {\n         \t printf(\"#\");\n        }\n        printf(\"\\n\");\n    }\n}"
        }
      ],
      "id": "PE31rJig",
      "createdAt": 1692495557075,
      "updatedAt": 1692506233108
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3BVGYMMN",
      "tagsIds": [],
      "description": null,
      "name": "appearance 属性",
      "content": [
        {
          "label": "Fragment 1",
          "language": "css",
          "value": "/*去除原生控件的样式*/\n\nselect{\n  appearance:none\n}"
        }
      ],
      "id": "yQnhwFbA",
      "createdAt": 1692539896654,
      "updatedAt": 1692540001944
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3BVGYMMN",
      "tagsIds": [
        "kv-CSfab",
        "6Njm6X7l",
        "wwLDze_V",
        "HU1RtGEO",
        "QO_Fn8iR"
      ],
      "description": null,
      "name": "clip-path",
      "content": [
        {
          "label": "Fragment 1",
          "language": "css",
          "value": "/*clip-path 通过裁剪html元素的可见区域来创建自定义形状*/\n/*搜索 CSS clip-path generator  会有在线工具*/\ncontainert{\n  width: 500px;\n  height: 500px;\n  background-color:rebeccapurple;\n  /*circle(50%)是个圆形而 加at 0 0 将使圆形中心点在元素的左上角，因为有部分超出范围，这样就形成一个扇形 */\n  clip-path:circle(50% at 0 0);\n  transition:all 2s ease; /*这里给hover一个动画效果*/\n}\ncontainer:hover{\n  clip-path:circle(100%);/*这里会有一个动画效果*/\n}\n\n仅使用CSS 即可轻松为形和徽标添加动画效果\nclip-path:path(\"只需在Figma中绘制形状，将其另存为SVG，获取其路径，然后将其粘贴到此处\")\n\n使用下面svg里path的M0.5 73.5V1H20V56H72V73.5H0.5Z这一段即可\n<svg width=\"73\" height=\"74\" viewBox=\"00...>\n\t\t<path d=\"M0.5 73.5V1H20V56H72V73.5H0.5Z\" str...>\n</svg>"
        }
      ],
      "id": "LBUKFHiP",
      "createdAt": 1692582696558,
      "updatedAt": 1692584309900
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3BVGYMMN",
      "tagsIds": [],
      "description": null,
      "name": "aspect-ratio",
      "content": [
        {
          "label": "Fragment 1",
          "language": "css",
          "value": "player{\n  width: 100%;\n  background-color:black;\n  aspect-ratio: 16/9;\n}\n\n/*\naspect-ratio 是 CSS 中用于指定元素宽高比的属性。它可以帮助开发者在不使用具体的宽度和高度值的情况下，仅通过一个比例关系来设置元素的尺寸。\naspect-ratio 属性适用于所有元素，包括块级元素和内联元素。\n它可以与其他布局属性（如 width、height、max-width、max-height）一起使用，以调整元素的实际尺寸。\n如果同时设置了 width 和 height 属性，aspect-ratio 属性优先级更高，将覆盖这两个值。\n当元素的父容器具有固定的宽度时，aspect-ratio 属性可以确保子元素的高度相对于宽度按照比例缩放。\naspect-ratio 属性目前处于实验性阶段，并且仅有部分浏览器支持。您可以使用 -webkit- 前缀来兼容 WebKit 内核的浏览器。\n*/"
        }
      ],
      "id": "hM7iOKIR",
      "createdAt": 1692584807052,
      "updatedAt": 1692585270959
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3BVGYMMN",
      "tagsIds": [],
      "description": null,
      "name": "filter",
      "content": [
        {
          "label": "Fragment 1",
          "language": "css",
          "value": "filter里有很多属性是快速制作交互效果的利器；下面是一个模糊文字变清晰的效果\n\n.spoiler{\n  filter: blur(5px);\n  font-size: 30px;\n}\n.spoiler:active{\n\tfilter: none;\n}\n\n/* 黑白效果*/\nimg{\n\tfilter:grayscale(100%);\n}\n"
        }
      ],
      "id": "mYK0jfvh",
      "createdAt": 1692585425934,
      "updatedAt": 1692585659077
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3BVGYMMN",
      "tagsIds": [
        "7RtIwv96"
      ],
      "description": null,
      "name": "input",
      "content": [
        {
          "label": "Fragment 1",
          "language": "css",
          "value": "更改placeholder\n\ninput::placeholder{\n color:red;\n}\n\n更改点击时默认的黑色边框\n\ninput:focus{\n   /*outline:none;*/\n\toutline: 1px solid red;\n}\n\n更改鼠标光标颜色\ninput{\n caret-color:red;\n}"
        }
      ],
      "id": "CHr-DZs0",
      "createdAt": 1692585772998,
      "updatedAt": 1692586090548
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "ztpcuydj",
      "tagsIds": [],
      "description": null,
      "name": "Untitled snippet",
      "content": [
        {
          "label": "Fragment 1",
          "language": "plain_text",
          "value": ""
        }
      ],
      "id": "h5AOACVx",
      "createdAt": 1693548439599,
      "updatedAt": 1693548462526
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "ztpcuydj",
      "tagsIds": [],
      "description": null,
      "name": "数组中查找字符串",
      "content": [
        {
          "label": "Fragment 1",
          "language": "java",
          "value": "public class Homework01 {\n    //编写一个main方法\n    public static void main(String[] args) {\n\n      String[] strs = {};\n      A02 a02 = new A02();\n      int index = a02.find(\"tom\", strs);\n      System.out.println(\"index=\" + index);\n  }\n}\n//编写类A02，定义方法find，实现查找某字符串是否在字符串数组中,并返回索引,如果找不到,返回-1\n//分析:注意这里在写代码前的分析很重要\n//1.类名 A02\n//2.方法名 find\n//3.返回值 int\n//4.形参 (String, string[])\nclass A02{\n  public int find(String findStr, String[] strs) {\n    //遍历字符串数组,如果找到,则返回索引\n    for (int i = 0; i < strs.length; i++) {\n      if (findStr.equals(strs[i])) {\n        return i;\n      }\n    }\n    //如果没有，就返回-1\n    return -1;   \n   }\n}"
        }
      ],
      "id": "VMXFxFmn",
      "createdAt": 1693548465231,
      "updatedAt": 1693549257538
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "ztpcuydj",
      "tagsIds": [],
      "description": null,
      "name": "更改书籍价格",
      "content": [
        {
          "label": "Fragment 1",
          "language": "java",
          "value": "public class Homework01 {\n  // 编写一个main方法，注意任何一个类都可以有main方法\n  public static void main(String[] args) {\n  Book book = new Book(\"笑傲江湖\",60);\n    book.updatePrice();\n    book.info();\n  }\n}\n/*\n * 具体:如果价格>159,则更改为150，如果价格>100,更改为100，否则不变\n * 分析:Book;  属性 rice,name; 方法名 updatePrice; 形参(); 返回值 void;\n * 提供一个构造器\n */\nclass Book {\n  String name;\n  double price;\n\n  public Book(String name, double price) { //提供一个构造器\n    this.name = name;\n    this.price = price;\n  }\n\n  public void updatePrice() {\n    //如果方法中,没有price 局部变量,this.price等价price，可以写成price\n    if (this.price > 150) {\n      this.price = 150;\n    } else if (this.price > 100) {\n      this.price = 100;\n    }\n  }\n  //显示书籍情况\n  public void info(){\n    System.out.println(\"书名=\" + this.name + \"价格=\" + this.price);\n  }\n}"
        }
      ],
      "id": "1BUokrru",
      "createdAt": 1693550924460,
      "updatedAt": 1693570479151
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "T0GXZDoL",
      "tagsIds": [],
      "description": null,
      "name": "Untitled snippet",
      "content": [
        {
          "label": "Fragment 1",
          "language": "java",
          "value": "//编程思想：先假定数组的第一个元素就是最大值\nint max = arr[i]\n\nif(max<arr[i]){\n   max = arr[i]\n}"
        }
      ],
      "id": "2_G5aZZ0",
      "createdAt": 1693551515015,
      "updatedAt": 1693552192182
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "T0GXZDoL",
      "tagsIds": [],
      "description": null,
      "name": "求数组最大值",
      "content": [
        {
          "label": "Fragment 1",
          "language": "java",
          "value": "//核心：先假定一个最大值，然后循环对比得出结果\nint max = arr[0];\nif (arr[i] > max) {\n\tmax = arr[i];\n}\n\n//完整代码：\npublic class Maxnum {\n    public static void main(String[] args) {\n        int[] arr = new int[] { 1, 34, 3, 4, 5 };\n        int max = arr[0];\n\n        for (int i = 0; i < arr.length; i++) {\n            if (arr[i] > max) {\n                max = arr[i];\n            }\n        }\n        System.out.println(\"Maximum number is: \" + max);\n    }\n}"
        }
      ],
      "id": "xNJ_dlu_",
      "createdAt": 1693552204262,
      "updatedAt": 1693552698055
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "ztpcuydj",
      "tagsIds": [],
      "description": null,
      "name": "数组克隆",
      "content": [
        {
          "label": "Fragment 1",
          "language": "java",
          "value": "public class Copyarr {\n    public static void main(String[] args) {\n        int[] oldArr = { 30, 50, 60 };\n        A03 a03 = new A03();\n        int[] newArr = a03.copyArr(oldArr);\n        //输出结果\n        for(int i = 0; i < newArr.length; i++){\n           System.out.print(newArr[i] + \"\\t\");\n        }\n    }\n}\n\nclass A03 {\n    public int[] copyArr(int[] oldArr) {// 在堆中，创建一个长度为 oldArr.length 数组\n        int[] newArr = new int[oldArr.length];// 遍历 oldArr,将元泰拷贝到newArr\n        for (int i = 0; i < oldArr.length; i++) {\n            newArr[i] = oldArr[i];\n        }\n        return newArr;\n    }\n}"
        }
      ],
      "id": "ScXzxV1c",
      "createdAt": 1693553700202,
      "updatedAt": 1693554146618
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "HbQza7qh",
      "tagsIds": [],
      "description": null,
      "name": "前++ 和后++ 的区别",
      "content": [
        {
          "label": "Fragment 1",
          "language": "java",
          "value": "//只有在作为表达式的时候有区别：++i 先自增后赋值:i++ 先赋值后自增\nint i = 8;\n// int j = ++i; //先自增后赋值; 等价 i=i+1; j=i;  //输出9  9\nint j = i++; //先赋值后自增; 等价 j=i; i=i+1;\nSystem.out.println(\"j=\" + j + \"i=\" + i); //输出8 9"
        },
        {
          "label": "输出结果判断",
          "language": "java",
          "value": "public class Test {\n    public static void main(String[] args) { //这个main并没有运行\n    }\n}\n\nclass Demo {\n    int i = 100;\n\n    public void m() {\n        int j = i++;\n        System.out.println(\"i=\" + i);//101,因为 i=i+1;\n        System.out.println(\"j=\" + j);//100,因为j=i; i=i+1;\n    }\n}\n\nclass realMain {\n\t\t//运行的是这里，因为任何类都可以有main方法\n    public static void main(String[] args) {\n        Demo d1 = new Demo();\n        Demo d2 = d1;\n        d2.m();\n        System.out.println(\"d1.i=\" + d1.i);\n        System.out.println(\"d2.i=\" + d2.i);\n    }\n}"
        }
      ],
      "id": "GhpOjozp",
      "createdAt": 1693619837230,
      "updatedAt": 1693620963043
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "ztpcuydj",
      "tagsIds": [],
      "description": null,
      "name": "剪刀石头布游戏",
      "content": [
        {
          "label": "Fragment 1",
          "language": "java",
          "value": "import java.util.Random;                                                                              \nimport java.util.Scanner;                                                                             \n                                                                                                      \n/*                                                                                                    \n请编写一个猜拳的游戏                                                                                            \n有个人 Tom，设计他的成员变量. 成员方法, 可以电脑猜拳. 电脑每次都会随机生成 0, 1, 2                                                    \n0 表示 石头 1 表示剪刀 2 表示 布                                                                                 \n并要可以显示 Tom的输赢次数（清单）, 假定 玩三次.                                                                          \n */ \n // 测试类,主类\npublic class MoraGame {                                                                               \n                                                                                                     \n    // 测试                                                                                             \n    public static void main(String[] args) {                                                          \n        // 创建一个玩家对象                                                                                   \n        Tom t = new Tom();                                                                            \n        // 用来记录最后输赢的次数                                                                                \n        int isWinCount = 0;                                                                           \n                                                                                                      \n        // 创建一个二维数组，用来接收局数，Tom出拳情况以及电脑出拳情况                                                            \n        int[][] arr1 = new int[3][3];                                                                 \n        int j = 0;                                                                                    \n                                                                                                      \n        // 创建一个一维数组，用来接收输赢情况                                                                          \n        String[] arr2 = new String[3];                                                                \n                                                                                                      \n        Scanner scanner = new Scanner(System.in);                                                     \n        for (int i = 0; i < 3; i++) {   //比赛3次                                                              \n            // 获取玩家出的拳                                                                                \n            System.out.println(\"请输入你要出的拳（0-拳头，1-剪刀，2-布）：\");                                           \n            int num = scanner.nextInt();                                                              \n            t.setTomGuessNum(num);                                                                    \n            int tomGuess = t.getTomGuessNum();                                                        \n            arr1[i][j + 1] = tomGuess;                                                                \n                                                                                                      \n            // 获取电脑出的拳                                                                                \n            int comGuess = t.computerNum();                                                           \n            arr1[i][j + 2] = comGuess;                                                                \n                                                                                                      \n            // 将玩家猜的拳与电脑做比较                                                                           \n            String isWin = t.vsComputer();                                                            \n            arr2[i] = isWin;                                                                          \n            arr1[i][j] = t.count;                                                                     \n                                                                                                      \n            // 对每一局的情况进行输出                                                                            \n           System.out.println(\"=========================================\");                           \n            System.out.println(\"局数\\t玩家的出拳\\t电脑的出拳\\t输赢情况\");                                             \n            System.out.println(t.count + \"\\t\" + tomGuess + \"\\t\\t\" + comGuess + \"\\t\\t\" + t.vsComputer());\n            System.out.println(\"=========================================\");                          \n            System.out.println(\"\\n\\n\");                                                               \n            isWinCount = t.winCount(isWin);                                                           \n        }    \n        scanner.close();\n                                                                                                      \n        // 对游戏的最终结果进行输出                                                                               \n        System.out.println(\"局数\\t玩家的出拳\\t电脑的出拳\\t\\t输赢情况\");                                               \n        for (int a = 0; a < arr1.length; a++) {                                                       \n            for (int b = 0; b < arr1[a].length; b++) {                                                \n                System.out.print(arr1[a][b] + \"\\t\\t\\t\");                                              \n            }                                                                                         \n                                                                                                      \n            System.out.print(arr2[a]);                                                                \n            System.out.println();                                                                     \n        }                                                                                             \n        System.out.println(\"你赢了\" + isWinCount + \"次\");                                                 \n    }                                                                                                 \n                                                                                                      \n}                                                                                                     \n\n// Tom类\nclass Tom {     // 核心代码  \n\t// 玩家出拳的类型 \n    int tomGuessNum; //0,1,2\n\t// 电脑出拳的类型\n    int comGuessNum; //0,1,2\n\t// 玩家赢的次数\n    int winCountNum;  \n\t// 比赛的次数\n    int count = 1;   //一共比赛3次                                                                                 \n     \n\t\n\tpublic void showInfo() {\n\t\t//....\n\t}\n\t\n    /**                                                                                               \n     * 电脑随机生成猜拳的数字的方法                                                                                 \n     * @return                                                                                        \n     */                                                                                               \n    public int computerNum() {                                                                        \n        Random r = new Random();                                                                      \n        comGuessNum = r.nextInt(3);      // 方法 返回 0-2的随机数                                                             \n        // System.out.println(comGuessNum);                                                           \n        return comGuessNum;                                                                           \n    }                                                                                                 \n                                                                                                      \n    /**                                                                                               \n     * 设置玩家猜拳的数字的方法                                                                                   \n     * @param tomGuessNum                                                                             \n     */                                                                                               \n    public void setTomGuessNum(int tomGuessNum) {                                                     \n        if (tomGuessNum > 2 || tomGuessNum < 0) { \n\t\t\t//抛出一个异常, 李同学会写，没有处理\n            throw new IllegalArgumentException(\"数字输入错误\");                                             \n        }                                                                                             \n        this.tomGuessNum = tomGuessNum;                                                               \n    }                                                                                                 \n                                                                                                      \n    public int getTomGuessNum() {                                                                     \n        return tomGuessNum;                                                                           \n    }                                                                                                 \n                                                                                                      \n    /**                                                                                               \n     * 比较猜拳的结果                                                                                        \n     * @return 玩家赢返回true，否则返回false                                                                    \n     */                                                                                               \n    public String vsComputer() { \n\t\t //比较巧\n        if (tomGuessNum == 0 && comGuessNum == 1) {                                                   \n            return \"你赢了\";                                                                             \n        } else if (tomGuessNum == 1 && comGuessNum == 2) {                                            \n            return \"你赢了\";                                                                             \n        } else if (tomGuessNum == 2 && comGuessNum == 0) {                                            \n            return \"你赢了\";                                                                             \n        } else if (tomGuessNum == comGuessNum){                                                       \n            return \"平手\";                                                                              \n        } else {                                                                                      \n            return \"你输了\";                                                                             \n        }                                                                                             \n    }                                                                                                 \n                                                                                                      \n    /**                                                                                               \n     * 记录玩家赢的次数                                                                                       \n     * @return                                                                                        \n     */                                                                                               \n    public int winCount(String s) {                                                                   \n        count++;    //控制玩的次数                                                                                   \n        if (s.equals(\"你赢了\")) {     //统计赢的次数                                                                   \n            winCountNum++;                                                                            \n        }                                                                                             \n        return winCountNum;                                                                           \n    }                                                                                                 \n                                                                                                      \n}  \n"
        }
      ],
      "id": "L8ysN3Fl",
      "createdAt": 1693627321282,
      "updatedAt": 1693627340250
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "HbQza7qh",
      "tagsIds": [],
      "description": null,
      "name": "方法重载",
      "content": [
        {
          "label": "Fragment 1",
          "language": "java",
          "value": "public class Student extends Persont{\n\n    ....\n    //利用super实现代码复用\n    public String say() {\n        return super.say() + \" id=\"+ id + \" score=\" + score;\n    }\n\n}"
        }
      ],
      "id": "9AME0zhr",
      "createdAt": 1693743874799,
      "updatedAt": 1693744087501
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "WiVmIFIe",
      "tagsIds": [
        "VnECTVOl"
      ],
      "description": null,
      "name": "多态--面向对象编程的精华和难点",
      "content": [
        {
          "label": "Fragment 1",
          "language": "java",
          "value": "public class Poly01 {\n    public static void main(String[] args) {\n        Sub sub = new Sub();\n        System.out.println(sub.count); //20\n        sub.display(); //20\n \n        Base b = sub; //向上转型\n        System.out.print(b == sub); //true,因为指向内存的同一个空间\n        System.out.print(b.count); //10,属性没有重写之说! 属性的值看编译类型（而方法是有重写的）\n        b.display(); //20\n    }\n}\n\nclass Base {\n    int count = 10;\n\n    public void display() {\n        System.out.print(this.count);\n    }\n}\n\nclass Sub extends Base {\n    int count = 20;\n\n    public void display() {\n        System.out.print(this.count);\n    }\n}"
        }
      ],
      "id": "yKfnHjzq",
      "createdAt": 1693818463824,
      "updatedAt": 1694257601449
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "WiVmIFIe",
      "tagsIds": [],
      "description": null,
      "name": "多态数组",
      "content": [
        {
          "label": "Fragment 1",
          "language": "java",
          "value": "package com.extend_.poly_.polyarr; //可以去电脑的相关文件夹找到包，里面还有几个类\n\npublic class polyarr {\n    public static void main(String[] args) {\n       \n        Person[] persons = new Person[5]; //创建5个对象\n        persons[0] = new Person(\"jack\", 19);\n        persons[1] = new Student(\"Tom\", 18, 100);\n        persons[2] = new Student(\"smith\", 22, 90);\n        persons[3] = new Teacher(\"scott\", 30, 20000);\n        persons[4] = new Teacher(\"king\", 50, 25000);\n//        循环遍历多态数组，调用say()\n        for (int i = 0; i < persons.length; i++) {\n//     persons[i]编译类型是Person，运行类型是是根据实际情况有JVM来判渐\n            System.out.println(persons[i].say()); //动态绑定机制\n//            以下是为了调用类特有的方法，使用类型判断，结合向下转型\n            if (persons[i] instanceof Student) {\n                Student student = (Student) persons[i];//向下转型\n                student.study();//调用特有的方法\n//               或者 ((Student) persons[i]).study();\n            } else if (persons[i] instanceof Teacher) {\n                Teacher teacher = (Teacher) persons[i];//向下转型\n                teacher.teach();\n            } else {\n                System.out.println(\"你的类型有误\");\n            }\n        }\n    }\n}\n"
        }
      ],
      "id": "D5bF_emc",
      "createdAt": 1693830383812,
      "updatedAt": 1693830537128
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "WiVmIFIe",
      "tagsIds": [],
      "description": null,
      "name": "多态参数",
      "content": [
        {
          "label": "Fragment 1",
          "language": "java",
          "value": "package com.extend_.poly_.polyparameter; //可以在电脑文件夹查找此包的所有类\n\npublic class polyParameter {\n    public static void main(String[] args) {\n        Worker tom = new Worker(\"Tom\", 3000);\n        Manager milan = new Manager(\"milan\", 5000, 200000);\n//      在main方法中创建了一个polyParameter对象的实例，用于调用该类中的方法。\n        polyParameter polyParameter = new polyParameter();\n        polyParameter.showEmpAnnual(tom);//会和Worker类绑定\n        polyParameter.showEmpAnnual(milan);//会和Manager类绑定\n\n        polyParameter.testWork(tom);\n        polyParameter.testWork(milan);\n    }\n//    实现获取任何员工对象的年薪,并在main方法中调用\n  /*  通过将参数的类型声明为父类类型（例如Employee),方法可以接受该父类及其子类的任意实例作为参数。\n      这就是多态的应用，它允许我们使用基类的引用来操作派生类的对象。这样可以增加代码的灵活性，使得方法\n      能够适用于多种不同的子类对象。\n    */\n    public void showEmpAnnual(Employee e){\n        System.out.println(e.getAnnual());  //动态绑定机制\n    }\n    public void testWork(Employee e){\n        if(e instanceof Worker){\n            //向下转型操作\n           ((Worker) e).work();//这里输入e.work(),idea会给你自动生成\n        } else if (e instanceof Manager) {\n           ((Manager) e).manage();//向下转型操作\n        }else{\n            System.out.println(\"不作处理...\");\n        }\n\n    }\n}\n"
        }
      ],
      "id": "COfe9OrN",
      "createdAt": 1693886695734,
      "updatedAt": 1693886754616
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "T0GXZDoL",
      "tagsIds": [],
      "description": null,
      "name": "一段代码完成一个小功能，尽量不要混在一起",
      "content": [
        {
          "label": "Fragment 1",
          "language": "java",
          "value": "String choice = \"\";\n//功能 1\n//建议一段代码，完成一个小功能，尽量不要混在一起,下面的while判断是否为y或n,而if判断了是两者哪一个\nwhile (true) { //要求用户必须输入y/n否则就一直循环\n  System.out.println(\"你确定要退出吗? y/n\");\n  choice = scanner.next();\n  if (\"y\".equals(choice) || \"n\".equals(choice)) {\n  \tbreak;\n  }\n  //下面这样虽然也可以实现，但复杂化了，不利于维护扩展\n  /*if(\"y\".equas(choice)) {\n     loop = false;\n     break;\n   } else if (\"n\".equals(choice)) {\n     break;\n   }*/\n}\n//功能 2\n//当用户退出while,进行判断\n//编程思想:能if的就不要用分支写法if-else,因为太啰嗦不简洁,遇到不符合的条件就跳出程序，而不要执行很多不必要的代码再判断和跳出\nif (choice.equals(\"y\")) {\n  loop = false;\n}"
        }
      ],
      "id": "KMZVg20v",
      "createdAt": 1693994487719,
      "updatedAt": 1693995778454
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "HbQza7qh",
      "tagsIds": [],
      "description": null,
      "name": "get/set方法的灵活之处",
      "content": [
        {
          "label": "Teacher子类",
          "language": "java",
          "value": "//在其他类中调用属性，会用到get/set方法\npublic class Teacher extends Employee {\n    // 特有属性,不写入构造器\n    private int classDays;    //一年上课次数\n    private double cLassSal; //课时费\n\n    // 构造器\n    public Teacher(String name, double sal) {\n        super(name, sal);\n    }\n\n    //重写父类方法 printSal\n    @Override\n    public void printSal() { //老师不能使用super.printSal(),因为有其特有的属性\n        System.out.println(getName() + \"年工资是:\"\n                + (getSal() * getSalMonth() + classDays * classSal));\n                //getSalMonth没有写入构造器,而是在属性里,因为月份会有变化,也体现了set方法的灵活应用\n    }\n}\n"
        },
        {
          "label": "入口调用文件",
          "language": "java",
          "value": "//入口调用的文件\npublic class mainApp {\n    public static void main(String[] args) {\n       //老师测试\n        Teacher teacher = new Teacher(\"顺平\", 2000); //老师有课时费\n        teacher.setclassDays(360);\n        teacher.setclassSal(1000);\n        //通过给上面的set方法设置不同的变量值，下面的打印会相应的变化，这就是set方法的灵活之处！\n        teacher.printSal();\n    \n       Worker jack = new Worker(\"jack\", 10000);\n       jack.setSalMonth(15);//灵活额修改带薪月份\n       jack.printSal();//上面setSaTMonth(15)后, printSal()里会有相应的输出\n       \n       Peasant smith = new Peasant(\"smith\", 20000);\n       smith.printSal();\n    }\n}"
        },
        {
          "label": "父类 Employee",
          "language": "java",
          "value": "public class Employee {\n    // 属性\n    private String name;\n    private double sal;\n//    有变化的写入属性，不要写入构造器,方便子类灵活应用(通过set方法可以自定义)\n    private int salMonth = 12; //默认12,之后可以通过set方法自定义\n    \n//  方法\n//  打印年薪\n    public void printSal(){\n        System.out.print(name + \"年工资是:\" + (sal * salMonth));\n    }\n    \n//构造器,注意运行中有变化的属性不要写入构造器,放在属性里子类可以通过set方法灵活应用\n    public Employee(String name, double sal) {\n        this.name = name;\n        this.sal = sal;\n    }\n    \n  //get/set方法\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public double getSal() {\n        return sal;\n    }\n\n    public void setSal(double sal) {\n        this.sal = sal;\n    }\n\n    public int getSalMonth() {\n        return salMonth;\n    }\n\n    public void setSalMonth(int salMonth) {\n        this.salMonth = salMonth;\n    }\n}"
        }
      ],
      "id": "ZhLaETz9",
      "createdAt": 1694050390778,
      "updatedAt": 1694057007818
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "HbQza7qh",
      "tagsIds": [],
      "description": "子类构造器如何利用父类的参数等",
      "name": "constructor 构造器",
      "content": [
        {
          "label": "父类",
          "language": "java",
          "value": "package com.exercise.constructor_;\n\n/**\n * 设计一个Point类，其 x和 y坐标可以通过构造器提供。\n * 提供一个子类 LabeledPoint,构造器接受一个标签值和 x,y坐标,比如:new LabeledPoint(“Black”,1929,230.07)\n * 写出对应的构造器即可\n */\npublic class Point {\n    private double x;\n    private double y;\n\n    public Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n}"
        },
        {
          "label": "子类",
          "language": "java",
          "value": "package com.exercise.constructor_;\n\npublic class LabeledPoint extends Point {\n    //特有属性\n    private String label;\n    \n    //在idea里alt + reset 会自动生成下面的构造器\n    public LabeledPoint(String label, double x, double y) {\n        super(x, y);\n        this.label = label;\n    }\n}"
        },
        {
          "label": "main",
          "language": "java",
          "value": "package com.exercise.constructor_;\n\npublic class mainApp {\n    public static void main(String[] args) {\n        new LabeledPoint(\"okzu\",123,156);//调用\n    }\n}\n"
        }
      ],
      "id": "YATwlMui",
      "createdAt": 1694093307901,
      "updatedAt": 1694093548780
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "WiVmIFIe",
      "tagsIds": [],
      "description": null,
      "name": "对象的多态--运行类型",
      "content": [
        {
          "label": "Fragment 1",
          "language": "java",
          "value": "package com.exercise.poly_;\n\n/**\n * 创建的对象B的类型在运行中是可以不断变化的\n * 通过 obj.getClass()可以查看运行中的对象类型\n * 但是obj在编译的时候的类型是A，这个是一直不变的，运行中不会变化\n * 编译类型看等号左边，运行类型看等号右边\n * 对象类型在运行中不断变化在实际开发中很常用\n */\n\npublic class A_B_C {\n    public static void main(String[] args) {\n        A obj = new B();//向上转型\n\n        A b1 = obj; //b1指向B,多态的前提是：两个对象(类)存在继承关系\n        //C b1 = obj; 这样就会报错,因为obj的编译类型是A,这个不能改变;\n        // 编译类型不能改变,好比一个人的父母不能改变，但自己的身份性格名字是可以改变的;\n\n        System.out.println(\" obj的运行类型= \" + obj.getClass());//B\n        obj = new C();//向上转型\n        System.out.println(\" obj的运行类型= \" + obj.getClass());//C\n\n        obj = b1;\n        System.out.println(\" obj的运行类型= \" + obj.getClass());//B;注意又切回了B\n    }\n}\n\nclass A { //超类\n\n}\n\nclass B extends A { //父类\n\n}\n\nclass C extends B { //子类\n\n}\n"
        }
      ],
      "id": "K4hHqlZ_",
      "createdAt": 1694250702144,
      "updatedAt": 1694257373788
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "MFd514cI",
      "tagsIds": [],
      "description": null,
      "name": "英文转中文名称映射",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "  // 中文名称映射\n  const idMap = {\n    \"Email\": \"邮件\",\n    \"Username\": \"用户名\",\n    \"FirmName\": \"公司名\",\n  }\n  \n  function getFieldName(input) {\n    const fieldName = input.id.charAt(0).toUpperCase() + input.id.slice(1);\n    return idMap[fieldName] || fieldName; // 使用idMap中的中文形式，如果找不到则返回原字段名\n  }\n"
        }
      ],
      "id": "ZyjkOfPG",
      "createdAt": 1695090221299,
      "updatedAt": 1695090271165
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "MFd514cI",
      "tagsIds": [],
      "description": null,
      "name": "重置所有输入框的状态为初始状态",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": " // 重置所有输入框的状态为初始状态\nconst inputElements = formElement.querySelectorAll(\"input\");\n  inputElements.forEach((input) => {\n    showOrigin(input);\n});\n\nfunction showOrigin(input) {\n  const formControl = input.parentElement;\n  if (formControl) {\n  //formControl.className = \"form-control erro\"; 这里原来多一个erro类，用于给input框添加错误边框\n     formControl.className = \"form-control\";\n  }\n}\n\n//去除掉的css红色边框写法\n.form-control.error input {\n  border-color: var(--error-color);\n}"
        }
      ],
      "id": "0H7NC70d",
      "createdAt": 1695105824340,
      "updatedAt": 1695106047526
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3BVGYMMN",
      "tagsIds": [
        "4x70qi88"
      ],
      "description": null,
      "name": "按钮hover渐变",
      "content": [
        {
          "label": "Fragment 1",
          "language": "css",
          "value": "在:hover之前的元素使用：\ntransition：all 0.4s ease-out 0s\n\n如：\n.Btn{\n  transition：all 0.4s ease-out 0s;\n  background-color:white;\n}\n\n//那么白色到蓝色会有个渐变效果\n.Btn:hover{\n  background-color:blue;\n}\n//第二种方式：\n<--给所有按钮添加hover后的transition背景动画效果-->\nbutton {  \n  transition: background 0.3s ease;  \n}  \n  \nbutton:hover {  \n  background: blue;  \n}"
        }
      ],
      "id": "exohtigO",
      "createdAt": 1695109921777,
      "updatedAt": 1697697187811
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "MFd514cI",
      "tagsIds": [],
      "description": null,
      "name": "dataset的使用",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "dom元素dataset的使用：使用dataset元素可以方便地访问和修改HTML元素的自定义属性。它也可以为JavaScript应用程序提供一种简单的方法来存储额外的信息。要使用dataset元素，您需要在HTML元素上添加属性，并将其前缀“data-”。例如，要添加一个名为“color”的属性，您可以使用data-color属性，如下所示：<div data-color=\"blue\">。然后，您可以使用JavaScript来访问这个属性，如下所示：var color = element.dataset.color;\n\n引跑实际案例-动态改变一个提交表单的标题：\n<div id=\"openModalBtn\" data-title=\"申请试用\">申请试用</div>\n<div id=\"otherBtn\" data-title=\"预约演示\">申请试用</div>\n\nconst openModalBtn = document.getElementById(\"openModalBtn\");\nconst otherBtn = document.getElementById(\"otherBtn\");\n\nfunction openModalHandler() {\n  const title = this.dataset.title; // 访问html定义的 data-title\n  openModal(title); // 打开模态框并显示指定的标题  \n}\n\nopenModalBtn.addEventListener(\"click\", openModalHandler);\notherBtn.addEventListener(\"click\", openModalHandler);\n\n function openModal(title) {\n   modalTitle.textContent = title;\n   //...\n }"
        }
      ],
      "id": "DreLhY2z",
      "createdAt": 1695114698341,
      "updatedAt": 1695115210588
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "静态分页实现",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "//---------------- HTML\n<div class=\"content content_1 active\"></div>\n<div class=\"content content_2\"></div>\n\n<div class=\"pagination\">\n  <span class=\"prev\">上一页</span>\n  <span class=\"page\" data-target=\"content_1\">1</span>\n  <span class=\"page\" data-target=\"content_2\">2</span>\n  <span class=\"next\">下一页</span>\n</div>\n\n//------------------- JS\nconst pages = document.querySelectorAll(\".page\"); //这里是一个可以forEach的类数组\nconst contentContainers = document.querySelectorAll(\".content\");\nconst prevBtn = document.querySelector(\".prev\");\nconst nextBtn = document.querySelector(\".next\");\n\nlet currentPageIndex = 0; //跟踪当前页面索引\n// 初始化时隐藏prevBtn\nprevBtn.style.display = \"none\";\n\npages.forEach((page, index) => {\n    page.addEventListener(\"click\", () => {\n    //console.log(\"page= \",page, \"index= \",index);\n    // 点击页面时，根据索引切换到对应的内容容器\n    showPage(index);\n  });\n});\n\nprevBtn.addEventListener(\"click\", () => {\n  if (currentPageIndex > 0) {\n    // 上一页按钮点击时，显示前一页\n    showPage(currentPageIndex - 1);\n  }\n});\n\nnextBtn.addEventListener(\"click\", () => {\n  if (currentPageIndex < pages.length - 1) {\n    // 下一页按钮点击时，显示下一页\n    showPage(currentPageIndex + 1);\n  }\n});\n\nfunction showPage(index) {\n  window.scrollTo({ top:670, behavior: \"smooth\" });//滚动触发内容显示\n  // 隐藏当前页面\n  contentContainers[currentPageIndex].classList.remove(\"active\");\n  //给分页的数字添加样式\n  pages[currentPageIndex].classList.remove(\"active\");\n\n  \n  // 显示新页面\n  contentContainers[index].classList.add(\"active\");\n  pages[index].classList.add(\"active\");\n  currentPageIndex = index; // 更新当前页面索引\n\n  // 根据当前页面索引显示/隐藏prevBtn和nextBtn\n  if (currentPageIndex === 0) {\n    prevBtn.style.display = \"none\";\n  } else {\n    prevBtn.style.display = \"block\";\n  }\n\n  if (currentPageIndex === pages.length - 1) {\n    nextBtn.style.display = \"none\";\n  } else {\n    nextBtn.style.display = \"block\";\n  }\n}\n"
        }
      ],
      "id": "SYTCTENq",
      "createdAt": 1695965901772,
      "updatedAt": 1695969408527
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "捕获异常 try catch finally",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "捕获异常就是处理错误，当错误发生后，我们对错误进行相应的处理，让程序不至于终止\n在绝大部分时候，我们都无须捕获异常，除非满足以下要求:\n1.我们能够预知某段代码会出现异常\n2.我们知道出现异常后要做什么\n上面的条件任意一个不满足，都不应该处理异常永远不能为了不报错而捕获异常!\ntry{\n   //代码1,错误也是对象，有的话会把错误对象传递给catch的err参数\n   //有错误的话，不会继续执行try里下面的代码，会执行catch代码块\n}\ncatch(err){\n  // 代码2: 当代码1出现异常后，会执行这里的代码，异常对象会传递给err\n  console.log(err.message)\nfinally{ //可省略\n // 代码3可省略。无论是否有异常，都会执行\n}"
        }
      ],
      "id": "z_WM_cWr",
      "createdAt": 1696496965626,
      "updatedAt": 1696497681399
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "MFd514cI",
      "tagsIds": [
        "vXANOYOt",
        "G2We-xe-"
      ],
      "description": null,
      "name": "封装一个通用的防止重复点击的函数",
      "content": [
        {
          "label": "没有处理前",
          "language": "javascript",
          "value": "模拟这样的异步请求逻辑：点击表单提交，需要保存一个东西，先发一个请求出去，后端返回一个id给前端，前端把id存下，下次在点提交的时候就成了编辑，不做限制的话，用户多次点击会保存多条重复的记录\n（未完成）\n<body>\n    <button id=\"btn\">提交</button>\n    <script>\n      const oBtn = document.getElementById(\"btn\");\n      oBtn.addEventListener(\"click\", () => {\n        save();\n      });\n      function save() {\n        return new Promise((resolve, reject) => {\n          setTimeout(() => {\n            Math.random() > 0.5 //随机数，一般的概率\n              ? resolve(2) //模拟成功返回的id\n              : reject(new Error(\"custom error\"));\n          }, 1000);\n        })\n          .then((id) => {\n            console.log(\"save success\");\n          })\n          .catch(console.error);\n      }\n    </script>\n  </body>"
        }
      ],
      "id": "c5erqQ1Y",
      "createdAt": 1696661912314,
      "updatedAt": 1696669032785
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "MFd514cI",
      "tagsIds": [],
      "description": null,
      "name": "老韩重要的编程技巧分享！！",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "         //对输入的参数做一个验证\n         老韩重要的编程技巧分享!!!\n         (1) 写出正确的情况\n         (2) 然后取反即可\n         (3) 这样写，你的思路就不乱\n        if(!(str != null && start >= 0 && end > start && end < str.length())) {\n            throw new RuntimeException(\"参数不正确\");\n        }"
        }
      ],
      "id": "y8xrPQQA",
      "createdAt": 1696749937003,
      "updatedAt": 1696750089619
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "T0GXZDoL",
      "tagsIds": [],
      "description": null,
      "name": "老韩重要的编程技巧分享!!!",
      "content": [
        {
          "label": "Fragment 1",
          "language": "java",
          "value": "  //对输入的参数做一个验证\n         老韩重要的编程技巧分享!!!\n         (1) 写出正确的情况\n         (2) 然后取反即可\n         (3) 这样写，你的思路就不乱\n        if(!(str != null && start >= 0 && end > start && end < str.length())) {\n            throw new RuntimeException(\"参数不正确\");\n        }"
        }
      ],
      "id": "k1IP0_c2",
      "createdAt": 1696750097263,
      "updatedAt": 1696750102975
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "T0GXZDoL",
      "tagsIds": [],
      "description": null,
      "name": "Untitled snippet",
      "content": [
        {
          "label": "Fragment 1",
          "language": "java",
          "value": ""
        }
      ],
      "id": "uWBcnP5s",
      "createdAt": 1696750102941,
      "updatedAt": 1696750109857
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [
        "tocBVsRT",
        "NwaiK6Nk"
      ],
      "description": "比如让菜单列表倒序排列显示",
      "name": "将dom元素反转",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "  /*\n  主要牵扯l两个个概念: \n  1) 用Array.from('伪数组')得到数组,然后使用数组的reverse();\n  2) forEach()的使用\n  */\n  \n  const parentContainer = document.querySelector(\".parent_Container\");\n  const childItems = parentContainer.querySelectorAll(\".child_Item\");\n  //将伪数组转换为数组以便使用数组的方法\n  const childItemArray = Array.from(childItems);\n//使用数组的reverse()方法反转数组\n  childItemArray.reverse();\n//将反转后的数组里的每个元素append到父元素\n  childItemArray.forEach((item) => {\n    parentContainer.appendChild(item);\n  });"
        }
      ],
      "id": "-FN_DPhW",
      "createdAt": 1697615639477,
      "updatedAt": 1697616575113
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "MFd514cI",
      "tagsIds": [],
      "description": null,
      "name": "选择CSS的继承类",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "const selectElement = document.querySelector(\".bootstrap-select>.dropdown-toggle.bs-placeholder\");"
        }
      ],
      "id": "FO3SJzpI",
      "createdAt": 1697702002049,
      "updatedAt": 1697702047715
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "6Ixdd13H",
      "tagsIds": [],
      "description": null,
      "name": "全局加边框",
      "content": [
        {
          "label": "本地添加",
          "language": "css",
          "value": "/* 调试大部分是处理对齐，加边框方便定位问题*/\n\n*{\n  outline:1px dashed tomato;\n}\n"
        },
        {
          "label": "项目上线后 -> 浏览器添加",
          "language": "css",
          "value": "/*复制下面的代码，Ctrl+D当前页面到书签，修改书签网址，粘贴代码\n第一次点击是添加边框\n第二次点击会去除边框\n*/\njavascript: (() => {\n  const headElement = document.head;\n  const styleElement = document.createElement('style');\n  styleElement.setAttribute('debug-css', '');\n  styleElement.innerText = '* { outline: 1px solid tomato; }';\n  const debugElement = headElement.querySelector('[debug-css]');\n  if (debugElement) return debugElement.remove();\n  headElement.append(styleElement);\n})()"
        },
        {
          "label": "终极 ->安装插件VisBug",
          "language": "css",
          "value": "安装浏览器插件VisBug是终极方案！！！"
        }
      ],
      "id": "iJfGAbqV",
      "createdAt": 1697810299328,
      "updatedAt": 1697815296757
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "yJren5oY",
      "tagsIds": [
        "4wrRqnmP",
        "m56TwSRZ",
        "FMTo2l7O",
        "yOmiJD_J",
        "38-kGUGm",
        "IvFchhtk"
      ],
      "description": null,
      "name": "css 查询电脑缩放比例",
      "content": [
        {
          "label": "Fragment 1",
          "language": "css",
          "value": "var scale = window.devicePixelRatio;\nconsole.log(scale);\n\n上面的代码使用了window.devicePixelRatio属性来获取当前设备的缩放比例，并且将它输出到控制台。这个属性返回的是设备实际像素分辨率与CSS像素分辨率之间的比值。\n\n在实际应用中，我们可以使用这个属性来优化页面的显示效果。当设备的缩放比例不为1时，我们可以针对不同的缩放比例设置不同的样式。比如，当缩放比例为2时，我们可以使用更高清晰度的图片，以达到更好的视觉效果。\n\n结合CSS的媒体查询，我们可以为不同的设备设置不同的样式，以达到更好的用户体验。\n\n注意：大缩放率的放上面\n/* 针对缩放比例为2的设备，使用2倍的图片 */\n@media only screen and (-webkit-min-device-pixel-ratio: 2) and (min-device-width: 320px) and (max-device-width: 568px) {\n  .logo {\n    background-image: url(2x-logo.png);\n    background-size: cover;\n  }\n}\n通过上面的代码，我们可以为缩放比例为2的设备设置更高清晰度的图片，并且保持背景图片的尺寸不变，以达到更好的视觉效果。\n\n@media only screen and (-webkit-min-device-pixel-ratio: 1.5) {\n   ::v-deep .el-tabs__item{\n   padding:.5vw 1.5vw;\n   height:unset;\n   }\n }"
        },
        {
          "label": "@media",
          "language": "css",
          "value": "\nTo limit the styles to devices with a screen, you can chain the mediafeatures to the screen media type:\nThis example combines two media features to restrict styles to landscape-oriented devices with a width of at least 30 ems:\n\n@media(min-width: 3em) and (orientation: landscape) {\n/**/\n}\n\nYou can use a comma-separated list to apply styles when the user'sdevice matches any one of various media types, features, or states. Forinstance, the following rule will apply its styles if the user's device has either a minimum height of 680px or is a screen device in portrait mode:\n\n@media (min-height: 680px), screen and(orientation: portrait) {\n/**/\n}\n/*检查当前浏览器是否支持display: flex属性。如果支持，那么以下的CSS规则将会被应用。*/\n@supports (display: flex) {\n  @media screen and (min-width: 900px) {\n    article {\n      display: flex;\n    }\n  }\n}\n\n/* This example applies styles when the user's primary input mechanism (such as a mouse) can hover over elements:*/\n@media (hover: hover) {\n  /* … */\n}\n\n/*这种查询可以用于为支持单色显示模式的设备或浏览器提供特定的样式优化。*/\n@media not all and (monochrome) {\n  /* … */\n}\n\n@media only screen and (min-width: 320px) and (max-width: 480px) and (resolution: 150dpi) {\n  body {\n    line-height: 1.4;\n  }\n}"
        },
        {
          "label": "一个鼠标提示信息实例！",
          "language": "css",
          "value": "/*---- HTML ----*/\n<p>\n  <abbr title=\"National Aeronautics and Space Administration\">NASA</abbr> is a U.S. government agency that is\n  responsible for science and technology related to air and space.\n</p>\n\n/*---- CSS----*/\nabbr {\n  color: chocolate;\n}\n\n@media (hover: hover) {\n  abbr:hover {\n    color:limegreen;\n    transition-duration: 1s;\n  }\n}\n\n@media not all and (hover: hover) {\n  abbr::after {\n    content: ' (' attr(title) ')';\n  }\n}\n\n\n"
        }
      ],
      "id": "cGY2CDkG",
      "createdAt": 1698983160688,
      "updatedAt": 1702191954298
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "y-C8x3sP",
      "tagsIds": [],
      "description": null,
      "name": "Setter方法",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "Setter方法是一种特殊的方法，用于设置对象的属性值，并可以定义在属性值改变时执行的附加逻辑。与Java中的Setter方法类似，JavaScript中的Setter方法也用于控制对对象属性的访问和修改。\n与Java中的Setter方法相比，JavaScript中的Setter方法有一些不同之处。其中最大的区别是，JavaScript中的Setter方法是通过在对象上定义一个特殊的setter属性来完成的。这个setter属性可以是一个函数，当尝试修改该属性的值时，该函数将被调用。\nObject.defineProperty(obj, 'property', {  \n  set: function(value) {  \n    // 在属性值改变时执行的逻辑  \n  }  \n});\n在这个例子中，Object.defineProperty()方法用于在对象obj上定义一个名为property的属性。set选项是一个函数，它将在尝试修改该属性的值时被调用。可以在这个函数中定义任何需要的逻辑，例如验证输入值或更新其他属性的值。\n与Java中的Setter方法不同，JavaScript中的Setter方法可以定义更灵活的逻辑，例如在设置属性值时进行条件判断或触发其他操作。此外，JavaScript中的Setter方法还可以通过使用Object.observe()方法来监听属性变化，以便在属性值改变时执行特定的回调函数。\n总之，JavaScript有Setter方法，并且它们与Java中的Setter方法类似，但具有更多的灵活性和功能。\n以下是一个更真实的代码实例，演示了如何使用Object.defineProperty()定义一个具有Setter方法的属性：\n\nconst person = {};  \nObject.defineProperty(person, 'age', {  \n  set: function(newValue) {  \n    if (newValue < 0 || newValue > 100) {  \n      throw new Error('Age must be between 0 and 100');  \n    }  \n    this._age = newValue;  \n  }  \n});  \n  \n// 尝试设置年龄属性  \nperson.age = 25; // 正常设置，不会抛出异常  \nconsole.log(person.age); // 输出: 25   \nperson.age = 150; // 抛出异常: Age must be between 0 and 100\n\n在这个例子中，我们定义了一个名为age的属性，并使用Object.defineProperty()方法将其添加到person对象中。在定义的Setter函数中，我们检查新值是否在0到100的范围内。如果新值不在此范围内，则抛出一个错误。否则，我们将新值存储在_age私有属性中。\n\n请注意，在这个例子中，我们使用了this关键字来引用person对象。这是因为Setter方法是在person对象上定义的，所以this关键字引用的是person对象本身。"
        }
      ],
      "id": "s6OS7VKZ",
      "createdAt": 1701523517717,
      "updatedAt": 1701523846271
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "MqWdF2i4",
      "tagsIds": [
        "eyNtKXGM"
      ],
      "description": null,
      "name": "loading=\"lazy\" 图片懒加载",
      "content": [
        {
          "label": "Fragment 1",
          "language": "html",
          "value": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n   <link rel=\"stylesheet\" href=\"index.css\">\n   <script src=\"https://unpkg.com/vue@latest\"></script>\n</head>\n<body> \n    <main class=\"app\">\n        <div v-for=\"image in images\">\n            <!-- 原生的img标签都可以像下面实现图片懒加载不管是在vue、react等什么应用里！ -->\n            <!-- 加height属性懒加载lazy才能生效！否则在network里可以看到全部图片都加载了 -->\n            <img :src=\"image\" height=\"600\" loading=\"lazy\" alt=\"\">\n        </div>\n    </main>\n\n    <script src=\"main.js\"></script>\n</body>\n</html>\n\n下面是main.js\n// 这个文件并不实现懒加载，只是方便批量加载图片\n\nconst imageArr = new Array(36)\n    .fill(\"\")\n    // 注意demo (${idx + 1})这里有个空格，因为批量重命名时自动有个空格！\n    .map((_image, idx) =>`./imgs/demo (${idx + 1}).jpg`);\n\nconst app = { //vue的实例\n    data() {\n        return {\n            images:[...imageArr],\n        }\n    }\n\n}\nVue.createApp(app).mount(\".app\")"
        }
      ],
      "id": "97Mwd9sz",
      "createdAt": 1701915016842,
      "updatedAt": 1701934131869
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "yJren5oY",
      "tagsIds": [
        "yOmiJD_J"
      ],
      "description": null,
      "name": "container-name",
      "content": [
        {
          "label": "Fragment 1",
          "language": "css",
          "value": "h1{\n  /*这两个属性可以用于查询*/\n container-name: abc;\n container-type: inline-size;\n}\n\n//另一个实例：\n.container {  \n  container-name: my-container;  \n  contain: style layout paint;  \n}  \n  \n/* 这个样式只会应用到 container 元素及其子元素 */  \n@container my-container {  \n  color: red;  \n}"
        }
      ],
      "id": "FAV6tTaw",
      "createdAt": 1702191274418,
      "updatedAt": 1702197884175
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "3BVGYMMN",
      "tagsIds": [],
      "description": null,
      "name": "clamp()函数实现自适应",
      "content": [
        {
          "label": "Fragment 1",
          "language": "css",
          "value": "假设我们有一个元素，我们希望它的宽度能够灵活地适应不同的屏幕大小，但又不希望它太大或太小。这时候，我们就可以使用clamp()函数来设置宽度。比如，我们可以这样写：\n\n.child {\n   width: clamp(100px, 75%, 200px);\n}\n\n这个元素的宽度会在100像素到200像素之间变化，但如果屏幕足够大，它的宽度会保持在屏幕宽度的75%。这样，无论在大屏幕还是小屏幕上，这个元素都能保持合适的大小，既不会太窄，也不会过于宽阔。\nclamp()函数的这种灵活性，使得它成为响应式设计中的一个非常有用的工具。你可以用它来调整字体大小、元素的间距、甚至是布局的大小。通过灵活运用，你的网站或应用界面在不同设备上都能展现出最佳效果。"
        }
      ],
      "id": "nqDoXmhn",
      "createdAt": 1703138754982,
      "updatedAt": 1703138841328
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "d_FAu2Me",
      "tagsIds": [
        "PbudwP0Z",
        "Qd6JJgfB"
      ],
      "description": null,
      "name": "background 属性",
      "content": [
        {
          "label": "Fragment 1",
          "language": "css",
          "value": ".element{\n\t   background: url(cool.jpg) \n  top left/50px 50px no-repeat;\n}\ntop left 是位置也就是放在容器的左上角\n50px 50px 是图片的长和宽，也就是background-size:50px 50px;\n\n\n下面可以在页面显示两张图片第二个是居中显示的,注意第二个是在下层的\n.element{\n\t   background: url(cool.jpg) \n  top left/50px 50px no-repeat,\n     url(cool.jpg)\n   center/70px 70px no-repeat;   \n}\n\n下面这个很实用，会给图片加个自定义的遮罩\n.hero {\n\t\tbackground:linear-gradient(\n        rgba(0,0,0,0.15),rgba( 0,0,0,0.15)\n    ),\n\t\turl(\"landscape.jpg\") center/cover;\n}\n\nbackground-blend-mode 属性在CSS中用于设置元素的背景图像如何与其背景色或其他背景图像进行混合。当你设置background-blend-mode: color; 时，这意味着背景图像将与背景颜色使用“color”混合模式混合\n.hero{\n  background: linear-gradient(#000,#000),url(\"landscape.jpg\") center/cover;\n  background-blend-mode:color;\n}\n"
        }
      ],
      "id": "sgHPf6sz",
      "createdAt": 1703144280859,
      "updatedAt": 1703153106417
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "d_FAu2Me",
      "tagsIds": [],
      "description": null,
      "name": "object-fit 属性",
      "content": [
        {
          "label": "Fragment 1",
          "language": "plain_text",
          "value": "img{\n  object-fit\n}"
        }
      ],
      "id": "V2Adu7bv",
      "createdAt": 1703153124035,
      "updatedAt": 1703153182199
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "d_FAu2Me",
      "tagsIds": [],
      "description": null,
      "name": "object-fit 属性",
      "content": [
        {
          "label": "Fragment 1",
          "language": "css",
          "value": "img{\n object-fit:contain;\n}\nobject-fit:fill; /* 会变形，忽略原始比例，会充满容器*/\nobject-fit:contain; /* 不会变形，不会充满容器,随着图像比例伸缩到容器边缘，另一侧可能会有空隙*/\nobject-fit:cover; /* 不会变形，会充满容器,可能裁切图片的某些部分以充满容器*/"
        }
      ],
      "id": "ZoI5sWSr",
      "createdAt": 1703153188898,
      "updatedAt": 1703153599034
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "d_FAu2Me",
      "tagsIds": [],
      "description": null,
      "name": "display 和 visibility",
      "content": [
        {
          "label": "Fragment 1",
          "language": "css",
          "value": "\n.box{\n  visibility:hidden;  /*元素不可见但占据着原来的位置空间 */\n}\n注意：\nVisibility属性：\n隐身术的秘密：它有两个可能的值: visible(默认值)和hidden，虽然它“隐身”了，但它仍然占据着原来的空间\n\n\n.box{\n display:none;  /*元素不可见并且不占据位置*/\n}\ndisplay:none;  \n这个属性更像是一位空间魔法师，不占据空间位置(不仅藏起来了，而且连藏身的地方也消失了)，设置后相邻的元素会移动填补这个空缺！\ndisplay属性有none、block inline inline-block flex grid table等\n"
        }
      ],
      "id": "303xQX0B",
      "createdAt": 1703153787444,
      "updatedAt": 1703154383427
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "db9Zyb5Z",
      "tagsIds": [],
      "description": null,
      "name": "动态表单创建",
      "content": [
        {
          "label": "Fragment 1",
          "language": "vue",
          "value": "基本思路：就是各个对象里有个next()方法，判断下一个链接关系\n\nimport {isReactive,reactive } from 'vue\""
        }
      ],
      "id": "LoXtdNx9",
      "createdAt": 1706150399585,
      "updatedAt": 1706150708724
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "db9Zyb5Z",
      "tagsIds": [],
      "description": null,
      "name": "Untitled snippet",
      "content": [
        {
          "label": "Fragment 1",
          "language": "vue",
          "value": "基本思路：就是各个对象里有个next()方法，判断下一个链接关系\n\nimport {isReactive,reactive } from 'vue\""
        }
      ],
      "id": "xWsqLLQK",
      "createdAt": 1706150565730,
      "updatedAt": 1706150710636
    },
    {
      "isDeleted": false,
      "isFavorites": false,
      "folderId": "db9Zyb5Z",
      "tagsIds": [],
      "description": null,
      "name": "动态表单创建",
      "content": [
        {
          "label": "Fragment 1",
          "language": "javascript",
          "value": "就是前面表单的选择项关联下一个表单的呈现状态，会用到链表结构\n\n【动态表单的实现【渡一教育】】 https://www.bilibili.com/video/BV1wi4y1q7Uw/?share_source=copy_web&vd_source=9d8f63206dcddc625bc45eb5cf95eb0f\n\n基本思路：就是各个对象里有个next方法，判断下一个链接关系 \n{  \n   next:() => 下一个表单\n}\n{  \n   next:() => 下一个表单\n}\n...\n\n下面是FormPageDatas.ts文件,是一个对象结构，还不是表单页面\n\nimport {isReactive,reactive} from 'vue\";\n\nexport type FormItemType = 'input'|'select'|'checkbox'|'radio';\n\nexport interface FormItem{ //数据结构\n\t\ttype:FormItemType;\n    payload: any;\n    next:(current:FormItem, acients:FormItem[]) => FormItem | null;\n    parent:FormItem | null;\n}\n\nexport function createFormItem( //辅助函数\n  formItemType: FormItem['type'],\n  payload: FormItem['payload'],\n  next?: FormItem['next'],\n  parent?: FormItem['parent']\n ): FormItem{\n   if(!next){\n      next => () => null;\n   }\n   if(!parent){\n      parent = null;\n   }\n   const nextFunc:FormItem['next']= (current,acients) => {\n   \t let nextItem =next!(current,acients);\n     if (!nextItem)\n\t\t   return null;\n    }\n    nextItem.parent = current;\n    if(!isReactive(nextItem)){\n    \t\tnextItem = reactive(nextItem);\n    }\n\t\t\treturn nextItem;\n   };\n   const formItem:FormItem = reactive({\n   \t\ttype: formItemType,\n      payload,\n\t\t\tnext: nextFunc,\n\t\t\tparent,\n\t\t});\n    \n    return FormItem;\n }\n \n"
        }
      ],
      "id": "KVfERGoL",
      "createdAt": 1706150625610,
      "updatedAt": 1706152199925
    },
    {
      "isDeleted": true,
      "isFavorites": false,
      "folderId": "db9Zyb5Z",
      "tagsIds": [],
      "description": null,
      "name": "Untitled snippet",
      "content": [
        {
          "label": "Fragment 1",
          "language": "vue",
          "value": "基本思路：就是各个对象里有个next()方法，判断下一个链接关系\n\nimport {isReactive,reactive } from 'vue\""
        }
      ],
      "id": "1thna70Y",
      "createdAt": 1706150674521,
      "updatedAt": 1706150678670
    }
  ],
  "tags": [
    {
      "name": "加载",
      "id": "6-jXY9xe",
      "createdAt": 1677638829391,
      "updatedAt": 1677638829391
    },
    {
      "name": "它不会改变原数组，而是返回一个新数组",
      "id": "oX2m4dHL",
      "createdAt": 1677643286276,
      "updatedAt": 1677643286276
    },
    {
      "name": "类数组",
      "id": "8EChA0GN",
      "createdAt": 1677665638339,
      "updatedAt": 1677665638339
    },
    {
      "name": "奇偶数",
      "id": "VMVF-8hD",
      "createdAt": 1677665702294,
      "updatedAt": 1677665702294
    },
    {
      "name": "dom操作",
      "id": "gtzXOkAc",
      "createdAt": 1678279968558,
      "updatedAt": 1678279968558
    },
    {
      "name": "tab页",
      "id": "VeWisvfJ",
      "createdAt": 1678282529320,
      "updatedAt": 1678282529320
    },
    {
      "name": "数组去重",
      "id": "vJCQ8FoN",
      "createdAt": 1678844290405,
      "updatedAt": 1678844290405
    },
    {
      "name": "轮播图",
      "id": "fyros3t1",
      "createdAt": 1678974797126,
      "updatedAt": 1678974797126
    },
    {
      "name": "幻灯",
      "id": "tqUZ3fHJ",
      "createdAt": 1678974966076,
      "updatedAt": 1678974966076
    },
    {
      "name": "鼠标交互",
      "id": "fDPIALBe",
      "createdAt": 1678974982629,
      "updatedAt": 1678974982629
    },
    {
      "name": "setTimeout",
      "id": "cH71p1QA",
      "createdAt": 1678975008697,
      "updatedAt": 1678975008697
    },
    {
      "name": " clearTimeout",
      "id": "y6nX0FDZ",
      "createdAt": 1678975016786,
      "updatedAt": 1678975016786
    },
    {
      "name": "面向对象",
      "id": "z_vLdu5R",
      "createdAt": 1679146698916,
      "updatedAt": 1679146698916
    },
    {
      "name": "js class",
      "id": "sUpoZMyz",
      "createdAt": 1679216746292,
      "updatedAt": 1679216746292
    },
    {
      "name": "pop",
      "id": "BRz1KFJ-",
      "createdAt": 1679219962523,
      "updatedAt": 1679219962523
    },
    {
      "name": "call()",
      "id": "AruGwEwj",
      "createdAt": 1679229643496,
      "updatedAt": 1679229643496
    },
    {
      "name": "call",
      "id": "RfO7-oVw",
      "createdAt": 1679229646732,
      "updatedAt": 1679229646732
    },
    {
      "name": "改变构造函数",
      "id": "4DWwUyl3",
      "createdAt": 1679229687046,
      "updatedAt": 1679229687046
    },
    {
      "name": "Object.create",
      "id": "AI8yBMyD",
      "createdAt": 1679232133214,
      "updatedAt": 1679232133214
    },
    {
      "name": "动态文字",
      "id": "1aEWbIVG",
      "createdAt": 1679278103457,
      "updatedAt": 1679278103457
    },
    {
      "name": "动态文本",
      "id": "HJZBStiS",
      "createdAt": 1679278112422,
      "updatedAt": 1679278112422
    },
    {
      "name": "自动点击",
      "id": "MKyhwiT8",
      "createdAt": 1679401530443,
      "updatedAt": 1679401530443
    },
    {
      "name": "组件刷新",
      "id": "KdczzSfg",
      "createdAt": 1679467630674,
      "updatedAt": 1679467630674
    },
    {
      "name": "路由刷新",
      "id": "3_8WBEfH",
      "createdAt": 1679467650358,
      "updatedAt": 1679467650358
    },
    {
      "name": "forEach",
      "id": "tocBVsRT",
      "createdAt": 1679472651139,
      "updatedAt": 1679472651139
    },
    {
      "name": "foreach",
      "id": "zUBMNMx7",
      "createdAt": 1679472660700,
      "updatedAt": 1679472660700
    },
    {
      "name": "返回首页 ",
      "id": "3SlmB-P_",
      "createdAt": 1679712789060,
      "updatedAt": 1679712789060
    },
    {
      "name": "返回",
      "id": "_QsE2qvC",
      "createdAt": 1679712795639,
      "updatedAt": 1679712795639
    },
    {
      "name": "eletron",
      "id": "weh9OBYF",
      "createdAt": 1679982861163,
      "updatedAt": 1679982861163
    },
    {
      "name": "electron",
      "id": "ppd2KRtj",
      "createdAt": 1679982875186,
      "updatedAt": 1679982875186
    },
    {
      "name": "环境判断",
      "id": "WSSamMkz",
      "createdAt": 1680259912498,
      "updatedAt": 1680259912498
    },
    {
      "name": "事件监听",
      "id": "MsM_-3a9",
      "createdAt": 1680487964881,
      "updatedAt": 1680487964881
    },
    {
      "name": "toggle",
      "id": "oahZqjuX",
      "createdAt": 1680488706112,
      "updatedAt": 1680488706112
    },
    {
      "name": "closest",
      "id": "sDMjHD6T",
      "createdAt": 1680488715915,
      "updatedAt": 1680488715915
    },
    {
      "name": ".forEach",
      "id": "nSNzxlE3",
      "createdAt": 1680489259115,
      "updatedAt": 1680489259115
    },
    {
      "name": "id 值",
      "id": "fHYC1zqy",
      "createdAt": 1680577768395,
      "updatedAt": 1680577768395
    },
    {
      "name": "唯一的id",
      "id": "vqdOKcoe",
      "createdAt": 1680577777282,
      "updatedAt": 1680577777282
    },
    {
      "name": "every",
      "id": "numkSBqD",
      "createdAt": 1680659758089,
      "updatedAt": 1680659758089
    },
    {
      "name": "数组作为参数",
      "id": "cJzn_M8B",
      "createdAt": 1680660260731,
      "updatedAt": 1680660260731
    },
    {
      "name": "参数数组",
      "id": "3r63DuXm",
      "createdAt": 1680660272650,
      "updatedAt": 1680660272650
    },
    {
      "name": "数字判断",
      "id": "BqxVekgI",
      "createdAt": 1680661645220,
      "updatedAt": 1680661645220
    },
    {
      "name": "bind()",
      "id": "A4xczVrR",
      "createdAt": 1680667123678,
      "updatedAt": 1680667123678
    },
    {
      "name": "模板字符串",
      "id": "oKLYhCZS",
      "createdAt": 1680692484587,
      "updatedAt": 1680692484587
    },
    {
      "name": "vscode",
      "id": "GxtphJep",
      "createdAt": 1680703672255,
      "updatedAt": 1680703672255
    },
    {
      "name": "代码格式化",
      "id": "o0h0GUTt",
      "createdAt": 1680703682291,
      "updatedAt": 1680703682291
    },
    {
      "name": "私有变量",
      "id": "p-I-pDGx",
      "createdAt": 1680703910822,
      "updatedAt": 1680703910822
    },
    {
      "name": "Asynchronous",
      "id": "YItK6iVG",
      "createdAt": 1680752307357,
      "updatedAt": 1680752307357
    },
    {
      "name": "图片加载",
      "id": "6dorcrmo",
      "createdAt": 1680772885340,
      "updatedAt": 1680772885340
    },
    {
      "name": "synchronous",
      "id": "YCMjJLAa",
      "createdAt": 1680773529537,
      "updatedAt": 1680773529537
    },
    {
      "name": "emit",
      "id": "QbBV4zvx",
      "createdAt": 1680870408919,
      "updatedAt": 1680870408919
    },
    {
      "name": "emit方法",
      "id": "jFhcfcBn",
      "createdAt": 1680870413971,
      "updatedAt": 1680870413971
    },
    {
      "name": "map",
      "id": "ZaUf5iYC",
      "createdAt": 1681033698635,
      "updatedAt": 1681033698635
    },
    {
      "name": "fetch",
      "id": "AHLUsvel",
      "createdAt": 1681033703879,
      "updatedAt": 1681033703879
    },
    {
      "name": "地图api",
      "id": "uyS3jGYa",
      "createdAt": 1681048590954,
      "updatedAt": 1681048590954
    },
    {
      "name": "map api",
      "id": "UOlf7phy",
      "createdAt": 1681048600839,
      "updatedAt": 1681048600839
    },
    {
      "name": "subtext",
      "id": "ScC0ASaK",
      "createdAt": 1681288694050,
      "updatedAt": 1681288694050
    },
    {
      "name": "Promise",
      "id": "AH4o3Lye",
      "createdAt": 1681355189178,
      "updatedAt": 1681355189178
    },
    {
      "name": "new Error",
      "id": "63ZIwxSn",
      "createdAt": 1681355195158,
      "updatedAt": 1681355195158
    },
    {
      "name": "Error",
      "id": "ExGKPu6S",
      "createdAt": 1681355200863,
      "updatedAt": 1681355200863
    },
    {
      "name": "Image()",
      "id": "3bRgTsPX",
      "createdAt": 1681364626330,
      "updatedAt": 1681364626330
    },
    {
      "name": "获取json",
      "id": "S3kIS3AR",
      "createdAt": 1681459381232,
      "updatedAt": 1681459381232
    },
    {
      "name": "队列函数",
      "id": "DxKZ2j1c",
      "createdAt": 1681459748319,
      "updatedAt": 1681459748319
    },
    {
      "name": "排队函数",
      "id": "lJch_6Ci",
      "createdAt": 1681459754946,
      "updatedAt": 1681459754946
    },
    {
      "name": "间隔函数",
      "id": "h6VovRUY",
      "createdAt": 1681459760127,
      "updatedAt": 1681459760127
    },
    {
      "name": "countries",
      "id": "AOZ115q_",
      "createdAt": 1681462639520,
      "updatedAt": 1681462639520
    },
    {
      "name": "json",
      "id": "ctJ0RMD1",
      "createdAt": 1681462644266,
      "updatedAt": 1681462644266
    },
    {
      "name": "API",
      "id": "RoFzKEEw",
      "createdAt": 1681462751425,
      "updatedAt": 1681462751425
    },
    {
      "name": "Promise.all",
      "id": "0mgkAi-B",
      "createdAt": 1681464830090,
      "updatedAt": 1681464830090
    },
    {
      "name": "map结合async",
      "id": "oXNsTNra",
      "createdAt": 1681526467007,
      "updatedAt": 1681526467007
    },
    {
      "name": "树形",
      "id": "gJiRapX3",
      "createdAt": 1681733962071,
      "updatedAt": 1681733962071
    },
    {
      "name": "tree",
      "id": "T8D8hQN9",
      "createdAt": 1681733966686,
      "updatedAt": 1681733966686
    },
    {
      "name": "Proxy",
      "id": "SZZcOAmF",
      "createdAt": 1681889366913,
      "updatedAt": 1681889366913
    },
    {
      "name": "for of",
      "id": "tkMsewzC",
      "createdAt": 1682239994396,
      "updatedAt": 1682239994396
    },
    {
      "name": "跨域",
      "id": "eWJmuiVv",
      "createdAt": 1682240101931,
      "updatedAt": 1682240101931
    },
    {
      "name": "csp",
      "id": "tgcSxj7Y",
      "createdAt": 1682240122868,
      "updatedAt": 1682240122868
    },
    {
      "name": "回调函数",
      "id": "k7BDpYlW",
      "createdAt": 1682392250879,
      "updatedAt": 1682392250879
    },
    {
      "name": "callback",
      "id": "cRFLDtUi",
      "createdAt": 1682392258095,
      "updatedAt": 1682392258095
    },
    {
      "name": "es6module",
      "id": "K9oTGZ3c",
      "createdAt": 1682586879778,
      "updatedAt": 1682586879778
    },
    {
      "name": "导入导出",
      "id": "jPiHk23T",
      "createdAt": 1682586896041,
      "updatedAt": 1682586896041
    },
    {
      "name": "export",
      "id": "itTFTksg",
      "createdAt": 1682586915139,
      "updatedAt": 1682586915139
    },
    {
      "name": "import",
      "id": "7B1vmnZR",
      "createdAt": 1682586921304,
      "updatedAt": 1682586921304
    },
    {
      "name": "mock",
      "id": "3GrbAyQg",
      "createdAt": 1682672075442,
      "updatedAt": 1682672075442
    },
    {
      "name": "mockdata",
      "id": "rsoj0LnD",
      "createdAt": 1682672082643,
      "updatedAt": 1682672082643
    },
    {
      "name": "拖拽",
      "id": "uf8TkRi0",
      "createdAt": 1682909073832,
      "updatedAt": 1682909073832
    },
    {
      "name": "列表拖拽",
      "id": "BImuQBfA",
      "createdAt": 1682909077344,
      "updatedAt": 1682909077344
    },
    {
      "name": "createElement",
      "id": "N_xlnWtn",
      "createdAt": 1682910021716,
      "updatedAt": 1682910021716
    },
    {
      "name": "appendChild",
      "id": "NwaiK6Nk",
      "createdAt": 1682910027269,
      "updatedAt": 1682910027269
    },
    {
      "name": "className",
      "id": "nO7R5SUy",
      "createdAt": 1682910049366,
      "updatedAt": 1682910049366
    },
    {
      "name": ":not",
      "id": "v8-YaD_f",
      "createdAt": 1682912713863,
      "updatedAt": 1682912713863
    },
    {
      "name": "insertBefore",
      "id": "hUnbIkaC",
      "createdAt": 1682912760841,
      "updatedAt": 1682912760841
    },
    {
      "name": "对象解构",
      "id": "oiiyhcXF",
      "createdAt": 1682914768930,
      "updatedAt": 1682914768930
    },
    {
      "name": "修改对象",
      "id": "CH3Sh008",
      "createdAt": 1682914911183,
      "updatedAt": 1682914911183
    },
    {
      "name": "对象修改",
      "id": "g7tfu6yD",
      "createdAt": 1682914924126,
      "updatedAt": 1682914924126
    },
    {
      "name": "insertAdjacentHTML",
      "id": "dzcTexb5",
      "createdAt": 1682934855009,
      "updatedAt": 1682934855009
    },
    {
      "name": "addEventListener",
      "id": "7N_f-tUT",
      "createdAt": 1683168247285,
      "updatedAt": 1683168247285
    },
    {
      "name": "引跑项目",
      "id": "MapSWFq2",
      "createdAt": 1683800039941,
      "updatedAt": 1683800039941
    },
    {
      "name": "atone",
      "id": "KQaIthCu",
      "createdAt": 1683800045072,
      "updatedAt": 1683800045072
    },
    {
      "name": "router",
      "id": "0DVV1_vt",
      "createdAt": 1684203975738,
      "updatedAt": 1684203975738
    },
    {
      "name": "路由",
      "id": "F3iRFiaA",
      "createdAt": 1684203981673,
      "updatedAt": 1684203981673
    },
    {
      "name": "YQ项目",
      "id": "ap7EPQjh",
      "createdAt": 1684726009184,
      "updatedAt": 1684726009184
    },
    {
      "name": "动态style",
      "id": "U4R_iTAE",
      "createdAt": 1684747510752,
      "updatedAt": 1684747510752
    },
    {
      "name": "动态样式",
      "id": "LWxPHcOo",
      "createdAt": 1684747523744,
      "updatedAt": 1684747523744
    },
    {
      "name": "遍历对象",
      "id": "7BPAbRet",
      "createdAt": 1684810999231,
      "updatedAt": 1684810999231
    },
    {
      "name": "splice",
      "id": "evMV3Veq",
      "createdAt": 1684811921856,
      "updatedAt": 1684811921856
    },
    {
      "name": "splice()",
      "id": "94resVPE",
      "createdAt": 1684811931575,
      "updatedAt": 1684811931575
    },
    {
      "name": "删除元素",
      "id": "IlFuQhsy",
      "createdAt": 1684811948000,
      "updatedAt": 1684811948000
    },
    {
      "name": "v-for",
      "id": "Ejq9XUle",
      "createdAt": 1684812765355,
      "updatedAt": 1684812765355
    },
    {
      "name": "阻止冒泡",
      "id": "WS4qeyy8",
      "createdAt": 1684813144145,
      "updatedAt": 1684813144145
    },
    {
      "name": "事件冒泡",
      "id": "82l3EbqQ",
      "createdAt": 1684813153721,
      "updatedAt": 1684813153721
    },
    {
      "name": "selection-change",
      "id": "9HOc4GA1",
      "createdAt": 1684897441855,
      "updatedAt": 1684897441855
    },
    {
      "name": "filter",
      "id": "Rj0DhGLo",
      "createdAt": 1684897450934,
      "updatedAt": 1684897450934
    },
    {
      "name": "toggleRowSelection",
      "id": "UiLjTXux",
      "createdAt": 1684897459541,
      "updatedAt": 1684897459541
    },
    {
      "name": "validator",
      "id": "YMapeYW6",
      "createdAt": 1684987115631,
      "updatedAt": 1684987115631
    },
    {
      "name": "props",
      "id": "kU7jx3aE",
      "createdAt": 1684987119358,
      "updatedAt": 1684987119358
    },
    {
      "name": "子级",
      "id": "5Dflw_1b",
      "createdAt": 1684987128027,
      "updatedAt": 1684987128027
    },
    {
      "name": "$emit",
      "id": "Fcl20gmo",
      "createdAt": 1685005723747,
      "updatedAt": 1685005723747
    },
    {
      "name": "子传父",
      "id": "eb97zzvl",
      "createdAt": 1685005753347,
      "updatedAt": 1685005753347
    },
    {
      "name": "子组件",
      "id": "JKa1LBV-",
      "createdAt": 1685006359699,
      "updatedAt": 1685006359699
    },
    {
      "name": "事件发送",
      "id": "EbtawnJh",
      "createdAt": 1685006766737,
      "updatedAt": 1685006766737
    },
    {
      "name": "自定义事件",
      "id": "N9T0vt1r",
      "createdAt": 1685006807489,
      "updatedAt": 1685006807489
    },
    {
      "name": "唯一值",
      "id": "wvdogT73",
      "createdAt": 1685068057988,
      "updatedAt": 1685068057988
    },
    {
      "name": "组件通信",
      "id": "4_xeTOND",
      "createdAt": 1685084989537,
      "updatedAt": 1685084989537
    },
    {
      "name": "组件通讯",
      "id": "u9pCoFM3",
      "createdAt": 1685085016855,
      "updatedAt": 1685085016855
    },
    {
      "name": "slot",
      "id": "BBDSI8V5",
      "createdAt": 1685152286632,
      "updatedAt": 1685152286632
    },
    {
      "name": "slots",
      "id": "uoTqJWq5",
      "createdAt": 1685152290921,
      "updatedAt": 1685152290921
    },
    {
      "name": "作用域插槽 ",
      "id": "9H_WKuOk",
      "createdAt": 1685157523378,
      "updatedAt": 1685157523378
    },
    {
      "name": "keep-alive",
      "id": "q717p6YY",
      "createdAt": 1685164030576,
      "updatedAt": 1685164030576
    },
    {
      "name": "chatgpt答案",
      "id": "AyqVhk7R",
      "createdAt": 1685502581246,
      "updatedAt": 1685502581246
    },
    {
      "name": "路由跳转",
      "id": "Vzi-lwKq",
      "createdAt": 1685686415393,
      "updatedAt": 1685686415393
    },
    {
      "name": "url拼接",
      "id": "MgYAa9Ky",
      "createdAt": 1685693108000,
      "updatedAt": 1685693108000
    },
    {
      "name": "弹窗",
      "id": "nGiQa5U6",
      "createdAt": 1685696123691,
      "updatedAt": 1685696123691
    },
    {
      "name": "computed",
      "id": "XIITO5Tv",
      "createdAt": 1685845795818,
      "updatedAt": 1685845795818
    },
    {
      "name": "v-model",
      "id": "0J7JvK0e",
      "createdAt": 1685873345263,
      "updatedAt": 1685873345263
    },
    {
      "name": "$refs",
      "id": "iZ0i6WtJ",
      "createdAt": 1685881363991,
      "updatedAt": 1685881363991
    },
    {
      "name": "linkActiveClass",
      "id": "0nws0COZ",
      "createdAt": 1686195073596,
      "updatedAt": 1686195073596
    },
    {
      "name": "菜单高亮",
      "id": "qfgXWMDf",
      "createdAt": 1686195086794,
      "updatedAt": 1686195086794
    },
    {
      "name": "highlight",
      "id": "hvD6qjEL",
      "createdAt": 1686195095339,
      "updatedAt": 1686195095339
    },
    {
      "name": "数据查询",
      "id": "FIO6bwCb",
      "createdAt": 1686370966409,
      "updatedAt": 1686370966409
    },
    {
      "name": "find()方法",
      "id": "bMuiTH_t",
      "createdAt": 1686371919939,
      "updatedAt": 1686371919939
    },
    {
      "name": "find()",
      "id": "lsitjQdf",
      "createdAt": 1686372428873,
      "updatedAt": 1686372428873
    },
    {
      "name": "动态路由",
      "id": "m0SDyNJf",
      "createdAt": 1686376122829,
      "updatedAt": 1686376122829
    },
    {
      "name": "数组查询",
      "id": "yETmPQp5",
      "createdAt": 1686376246971,
      "updatedAt": 1686376246971
    },
    {
      "name": "[type=\"text\"]",
      "id": "kzDE3A3E",
      "createdAt": 1686885176220,
      "updatedAt": 1686885176220
    },
    {
      "name": "copy",
      "id": "07hR6-Qz",
      "createdAt": 1687244101731,
      "updatedAt": 1687244101731
    },
    {
      "name": "sass",
      "id": "0Hny-xOz",
      "createdAt": 1687314582369,
      "updatedAt": 1687314582369
    },
    {
      "name": "scss",
      "id": "WORBBpq9",
      "createdAt": 1687314588863,
      "updatedAt": 1687314588863
    },
    {
      "name": "postcss",
      "id": "R7WFWPun",
      "createdAt": 1687317753770,
      "updatedAt": 1687317753770
    },
    {
      "name": "字典模式",
      "id": "nNH97xs5",
      "createdAt": 1687329433750,
      "updatedAt": 1687329433750
    },
    {
      "name": "发布者",
      "id": "TwMzSlbz",
      "createdAt": 1687851225985,
      "updatedAt": 1687851225985
    },
    {
      "name": "数组判断",
      "id": "V_npm_YK",
      "createdAt": 1687919266851,
      "updatedAt": 1687919266851
    },
    {
      "name": "数据判断",
      "id": "9XW5Mpot",
      "createdAt": 1687919609540,
      "updatedAt": 1687919609540
    },
    {
      "name": "MVC",
      "id": "9C5XAC_v",
      "createdAt": 1687920644153,
      "updatedAt": 1687920644153
    },
    {
      "name": "分页",
      "id": "ZCfYVnNs",
      "createdAt": 1687922259286,
      "updatedAt": 1687922259286
    },
    {
      "name": "分页的算法",
      "id": "sYJYnob2",
      "createdAt": 1687922270022,
      "updatedAt": 1687922270022
    },
    {
      "name": "dataset",
      "id": "7l5V15ey",
      "createdAt": 1687934585447,
      "updatedAt": 1687934585447
    },
    {
      "name": "parentElement",
      "id": "J2CKWazz",
      "createdAt": 1688020044266,
      "updatedAt": 1688020044266
    },
    {
      "name": "首字母大写",
      "id": "udbxbqmP",
      "createdAt": 1688023003363,
      "updatedAt": 1688023003363
    },
    {
      "name": "classList",
      "id": "CZ0PBSsq",
      "createdAt": 1688091761066,
      "updatedAt": 1688091761066
    },
    {
      "name": "for循环",
      "id": "sCWt0xKF",
      "createdAt": 1688269410167,
      "updatedAt": 1688269410167
    },
    {
      "name": "模块",
      "id": "njDRzcoh",
      "createdAt": 1688869334372,
      "updatedAt": 1688869334372
    },
    {
      "name": "模块化",
      "id": "4LLYvAFl",
      "createdAt": 1688869376074,
      "updatedAt": 1688869376074
    },
    {
      "name": "class",
      "id": "6vOxmQF6",
      "createdAt": 1689839805912,
      "updatedAt": 1689839805912
    },
    {
      "name": "侧边栏",
      "id": "A6GXFH-I",
      "createdAt": 1690033998554,
      "updatedAt": 1690033998554
    },
    {
      "name": "路由高亮",
      "id": "a43hQOW6",
      "createdAt": 1690034014496,
      "updatedAt": 1690034014496
    },
    {
      "name": "对象遍历",
      "id": "MtywOPyV",
      "createdAt": 1690105307053,
      "updatedAt": 1690105307053
    },
    {
      "name": "静态方法",
      "id": "0BWL9dRi",
      "createdAt": 1690426926914,
      "updatedAt": 1690426926914
    },
    {
      "name": "实例方法",
      "id": "Ti7JWPw0",
      "createdAt": 1690427102961,
      "updatedAt": 1690427102961
    },
    {
      "name": "侧边栏伸缩",
      "id": "a_KWSk9m",
      "createdAt": 1690536461990,
      "updatedAt": 1690536461990
    },
    {
      "name": "media",
      "id": "38-kGUGm",
      "createdAt": 1690685669567,
      "updatedAt": 1690685669567
    },
    {
      "name": "grid",
      "id": "4FgER6K6",
      "createdAt": 1690772278570,
      "updatedAt": 1690772278570
    },
    {
      "name": "grid布局",
      "id": "_WKR4zEa",
      "createdAt": 1690772286014,
      "updatedAt": 1690772286014
    },
    {
      "name": "laoding",
      "id": "EZljjTGm",
      "createdAt": 1691307657929,
      "updatedAt": 1691307657929
    },
    {
      "name": "animation",
      "id": "SFDkpVg8",
      "createdAt": 1691308330759,
      "updatedAt": 1691308330759
    },
    {
      "name": "解构赋值",
      "id": "CTWrptR8",
      "createdAt": 1691573104686,
      "updatedAt": 1691573104686
    },
    {
      "name": "事件代理",
      "id": "F_GVDzNT",
      "createdAt": 1692108504340,
      "updatedAt": 1692108504340
    },
    {
      "name": "flag",
      "id": "vANPuwsS",
      "createdAt": 1692155781786,
      "updatedAt": 1692155781786
    },
    {
      "name": "base64",
      "id": "mIczLajv",
      "createdAt": 1692159537439,
      "updatedAt": 1692159537439
    },
    {
      "name": "防抖",
      "id": "maUTSzjB",
      "createdAt": 1692169568545,
      "updatedAt": 1692169568545
    },
    {
      "name": "delay",
      "id": "i2ZLRaT-",
      "createdAt": 1692170692402,
      "updatedAt": 1692170692402
    },
    {
      "name": "delay函数",
      "id": "Y7mQg92x",
      "createdAt": 1692170710391,
      "updatedAt": 1692170710391
    },
    {
      "name": "删除数据",
      "id": "RQFn3oQg",
      "createdAt": 1692179798802,
      "updatedAt": 1692179798802
    },
    {
      "name": "空对象",
      "id": "tnE1auCZ",
      "createdAt": 1692493461875,
      "updatedAt": 1692493461875
    },
    {
      "name": "动画",
      "id": "kv-CSfab",
      "createdAt": 1692583556760,
      "updatedAt": 1692583556760
    },
    {
      "name": "动画效果",
      "id": "6Njm6X7l",
      "createdAt": 1692583563809,
      "updatedAt": 1692583563809
    },
    {
      "name": "svg",
      "id": "wwLDze_V",
      "createdAt": 1692584252953,
      "updatedAt": 1692584252953
    },
    {
      "name": "svg动画",
      "id": "HU1RtGEO",
      "createdAt": 1692584259799,
      "updatedAt": 1692584259799
    },
    {
      "name": "logo动画",
      "id": "QO_Fn8iR",
      "createdAt": 1692584309840,
      "updatedAt": 1692584309840
    },
    {
      "name": "placeholder",
      "id": "7RtIwv96",
      "createdAt": 1692585828073,
      "updatedAt": 1692585828073
    },
    {
      "name": "方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的。",
      "id": "VnECTVOl",
      "createdAt": 1693818721976,
      "updatedAt": 1693818721976
    },
    {
      "name": "random",
      "id": "vXANOYOt",
      "createdAt": 1696661990066,
      "updatedAt": 1696661990066
    },
    {
      "name": "随机值",
      "id": "G2We-xe-",
      "createdAt": 1696662005154,
      "updatedAt": 1696662005154
    },
    {
      "name": "hover",
      "id": "4x70qi88",
      "createdAt": 1697697187739,
      "updatedAt": 1697697187739
    },
    {
      "name": "缩放比",
      "id": "4wrRqnmP",
      "createdAt": 1699259000003,
      "updatedAt": 1699259000003
    },
    {
      "name": "分辨率",
      "id": "m56TwSRZ",
      "createdAt": 1699259008725,
      "updatedAt": 1699259008725
    },
    {
      "name": "@media",
      "id": "FMTo2l7O",
      "createdAt": 1699494901441,
      "updatedAt": 1699494901441
    },
    {
      "name": "媒体查询",
      "id": "yOmiJD_J",
      "createdAt": 1699494908351,
      "updatedAt": 1699494908351
    },
    {
      "name": " hover",
      "id": "IvFchhtk",
      "createdAt": 1699496353800,
      "updatedAt": 1699496353800
    },
    {
      "name": "懒加载",
      "id": "eyNtKXGM",
      "createdAt": 1701915102634,
      "updatedAt": 1701915102634
    },
    {
      "name": "background",
      "id": "PbudwP0Z",
      "createdAt": 1703151739301,
      "updatedAt": 1703151739301
    },
    {
      "name": "图片background",
      "id": "Qd6JJgfB",
      "createdAt": 1703151747859,
      "updatedAt": 1703151747859
    }
  ]
}